"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js":
/*!************************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/LoaderUtils.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeText: () => (/* binding */ decodeText)\n/* harmony export */ });\nfunction decodeText(array) {\n    if (typeof TextDecoder !== \"undefined\") {\n        return new TextDecoder().decode(array);\n    }\n    let s = \"\";\n    for(let i = 0, il = array.length; i < il; i++){\n        s += String.fromCharCode(array[i]);\n    }\n    try {\n        return decodeURIComponent(escape(s));\n    } catch (e) {\n        return s;\n    }\n}\n //# sourceMappingURL=LoaderUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9Mb2FkZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsV0FBV0MsS0FBSztJQUN2QixJQUFJLE9BQU9DLGdCQUFnQixhQUFhO1FBQ3RDLE9BQU8sSUFBSUEsY0FBY0MsTUFBTSxDQUFDRjtJQUNsQztJQUNBLElBQUlHLElBQUk7SUFDUixJQUFLLElBQUlDLElBQUksR0FBR0MsS0FBS0wsTUFBTU0sTUFBTSxFQUFFRixJQUFJQyxJQUFJRCxJQUFLO1FBQzlDRCxLQUFLSSxPQUFPQyxZQUFZLENBQUNSLEtBQUssQ0FBQ0ksRUFBRTtJQUNuQztJQUNBLElBQUk7UUFDRixPQUFPSyxtQkFBbUJDLE9BQU9QO0lBQ25DLEVBQUUsT0FBT1EsR0FBRztRQUNWLE9BQU9SO0lBQ1Q7QUFDRjtBQUdFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL0xvYWRlclV0aWxzLmpzP2U1Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGVjb2RlVGV4dChhcnJheSkge1xuICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShhcnJheSk7XG4gIH1cbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKHMpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5leHBvcnQge1xuICBkZWNvZGVUZXh0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9hZGVyVXRpbHMuanMubWFwXG4iXSwibmFtZXMiOlsiZGVjb2RlVGV4dCIsImFycmF5IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJzIiwiaSIsImlsIiwibGVuZ3RoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwiZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst version = /* @__PURE__ */ (()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsTUFBTUMsVUFBMEIsYUFBSCxHQUFJLEtBQU1DLFNBQVNGLDJDQUFRQSxDQUFDRyxPQUFPLENBQUMsUUFBUSxJQUFHO0FBRzFFLENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvX3BvbHlmaWxsL2NvbnN0YW50cy5qcz9mMTdlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJFVklTSU9OIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCB2ZXJzaW9uID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBwYXJzZUludChSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csIFwiXCIpKSkoKTtcbmV4cG9ydCB7XG4gIHZlcnNpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwXG4iXSwibmFtZXMiOlsiUkVWSVNJT04iLCJ2ZXJzaW9uIiwicGFyc2VJbnQiLCJyZXBsYWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/libs/MeshoptDecoder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshoptDecoder: () => (/* binding */ MeshoptDecoder)\n/* harmony export */ });\nlet generated;\nconst MeshoptDecoder = ()=>{\n    if (generated) return generated;\n    const wasm_base = \"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\";\n    const wasm_simd = \"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\";\n    const detector = new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        4,\n        1,\n        96,\n        0,\n        0,\n        3,\n        3,\n        2,\n        0,\n        0,\n        5,\n        3,\n        1,\n        0,\n        1,\n        12,\n        1,\n        0,\n        10,\n        22,\n        2,\n        12,\n        0,\n        65,\n        0,\n        65,\n        0,\n        65,\n        0,\n        252,\n        10,\n        0,\n        0,\n        11,\n        7,\n        0,\n        65,\n        0,\n        253,\n        15,\n        26,\n        11\n    ]);\n    const wasmpack = new Uint8Array([\n        32,\n        0,\n        65,\n        253,\n        3,\n        1,\n        2,\n        34,\n        4,\n        106,\n        6,\n        5,\n        11,\n        8,\n        7,\n        20,\n        13,\n        33,\n        12,\n        16,\n        128,\n        9,\n        116,\n        64,\n        19,\n        113,\n        127,\n        15,\n        10,\n        21,\n        22,\n        14,\n        255,\n        66,\n        24,\n        54,\n        136,\n        107,\n        18,\n        23,\n        192,\n        26,\n        114,\n        118,\n        132,\n        17,\n        77,\n        101,\n        130,\n        144,\n        27,\n        87,\n        131,\n        44,\n        45,\n        74,\n        156,\n        154,\n        70,\n        167\n    ]);\n    if (typeof WebAssembly !== \"object\") {\n        return {\n            supported: false\n        };\n    }\n    let wasm = wasm_base;\n    if (WebAssembly.validate(detector)) {\n        wasm = wasm_simd;\n    }\n    let instance;\n    const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result)=>{\n        instance = result.instance;\n        instance.exports.__wasm_call_ctors();\n    });\n    function unpack(data) {\n        const result = new Uint8Array(data.length);\n        for(let i = 0; i < data.length; ++i){\n            const ch = data.charCodeAt(i);\n            result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n        }\n        let write = 0;\n        for(let i = 0; i < data.length; ++i){\n            result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n        }\n        return result.buffer.slice(0, write);\n    }\n    function decode(fun, target, count, size, source, filter) {\n        const sbrk = instance.exports.sbrk;\n        const count4 = count + 3 & ~3;\n        const tp = sbrk(count4 * size);\n        const sp = sbrk(source.length);\n        const heap = new Uint8Array(instance.exports.memory.buffer);\n        heap.set(source, sp);\n        const res = fun(tp, count, size, sp, source.length);\n        if (res === 0 && filter) {\n            filter(tp, count4, size);\n        }\n        target.set(heap.subarray(tp, tp + count * size));\n        sbrk(tp - sbrk(0));\n        if (res !== 0) {\n            throw new Error(`Malformed buffer data: ${res}`);\n        }\n    }\n    const filters = {\n        // legacy index-based enums for glTF\n        0: \"\",\n        1: \"meshopt_decodeFilterOct\",\n        2: \"meshopt_decodeFilterQuat\",\n        3: \"meshopt_decodeFilterExp\",\n        // string-based enums for glTF\n        NONE: \"\",\n        OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n        QUATERNION: \"meshopt_decodeFilterQuat\",\n        EXPONENTIAL: \"meshopt_decodeFilterExp\"\n    };\n    const decoders = {\n        // legacy index-based enums for glTF\n        0: \"meshopt_decodeVertexBuffer\",\n        1: \"meshopt_decodeIndexBuffer\",\n        2: \"meshopt_decodeIndexSequence\",\n        // string-based enums for glTF\n        ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n        TRIANGLES: \"meshopt_decodeIndexBuffer\",\n        INDICES: \"meshopt_decodeIndexSequence\"\n    };\n    generated = {\n        ready: promise,\n        supported: true,\n        decodeVertexBuffer (target, count, size, source, filter) {\n            decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);\n        },\n        decodeIndexBuffer (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n        },\n        decodeIndexSequence (target, count, size, source) {\n            decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n        },\n        decodeGltfBuffer (target, count, size, source, mode, filter) {\n            decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);\n        }\n    };\n    return generated;\n};\n //# sourceMappingURL=MeshoptDecoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xpYnMvTWVzaG9wdERlY29kZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLElBQUlBO0FBQ0osTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUlELFdBQ0YsT0FBT0E7SUFDVCxNQUFNRSxZQUFZO0lBQ2xCLE1BQU1DLFlBQVk7SUFDbEIsTUFBTUMsV0FBVyxJQUFJQyxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsTUFBTUMsV0FBVyxJQUFJRCxXQUFXO1FBQzlCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNEO0lBQ0QsSUFBSSxPQUFPRSxnQkFBZ0IsVUFBVTtRQUNuQyxPQUFPO1lBQ0xDLFdBQVc7UUFDYjtJQUNGO0lBQ0EsSUFBSUMsT0FBT1A7SUFDWCxJQUFJSyxZQUFZRyxRQUFR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QUFrQjNCLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLE1BQU07WUFDM0NMLE9BQU9oQixTQUFTTSxPQUFPLENBQUN3Qyx5QkFBeUIsRUFBRTVCLFFBQVFDLE9BQU9DLE1BQU1DO1FBQzFFO1FBQ0EwQixxQkFBb0I3QixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxNQUFNO1lBQzdDTCxPQUFPaEIsU0FBU00sT0FBTyxDQUFDMEMsMkJBQTJCLEVBQUU5QixRQUFRQyxPQUFPQyxNQUFNQztRQUM1RTtRQUNBNEIsa0JBQWlCL0IsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFNkIsSUFBSSxFQUFFNUIsTUFBTTtZQUN4RE4sT0FDRWhCLFNBQVNNLE9BQU8sQ0FBQ2dDLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDLEVBQ2hDaEMsUUFDQUMsT0FDQUMsTUFDQUMsUUFDQXJCLFNBQVNNLE9BQU8sQ0FBQzJCLE9BQU8sQ0FBQ1gsT0FBTyxDQUFDO1FBRXJDO0lBQ0Y7SUFDQSxPQUFPakM7QUFDVDtBQUdFLENBQ0YsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbGlicy9NZXNob3B0RGVjb2Rlci5qcz9hN2Y0Il0sInNvdXJjZXNDb250ZW50IjpbImxldCBnZW5lcmF0ZWQ7XG5jb25zdCBNZXNob3B0RGVjb2RlciA9ICgpID0+IHtcbiAgaWYgKGdlbmVyYXRlZClcbiAgICByZXR1cm4gZ2VuZXJhdGVkO1xuICBjb25zdCB3YXNtX2Jhc2UgPSBcIkI5aDl6OXRGQkJCRjhmTDlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYTlnRWFhYUZhRU1jQkZGRkdHR0VJSUlMRjl3RkZGTEVGQkZLTkZhRkN4L0lGTU8vTEZWSzl0djl0OXZxOTVHQnQ5ZjlmOTM5aDl6OXQ5ZjlqOWg5czlzOWY5alc5dnE5ekJCcDl0djl6OW85djl3VzlmOWt2OWo5djlrdjlXdnFXdjk0aDkxOW05bXZxQkY4Wjl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NGg5MTltOW12cUJHeTl0djl6OW85djl3VzlmOWt2OWo5djlrdjlKOXU5a3Y5NDlUdlo5MXY5dTlqdkJFbjl0djl6OW85djl3VzlmOWt2OWo5djlrdjY5cDlzV3ZxOVA5aldCSWk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlSOTE5aFdCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlGOTQ5d0JLSTl6OWlxbEJPYyt4OHljR0JNL3FRRlRhOGpVVVVVQkNVL0VCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUdUa1VVVUJSTkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJWQUVDRkpSSUNCUmNHWEVYQWNBRjlQUUZBVkFGQWNsQWNBVkpBRjlKeVJNR1hHWEFHOUZRQkFNQ2JKSEtDOXdaUlNBS0NJckNFSkNHclJRQU5DVUdKUmZDQlJiQUlSVEVYR1hBT0FUbEFROVBRQkNCUklTRU1BVEFRSlJJR1hBUzlGUUJDQlJ0Q0JSRUVYR1hBT0FJbENpOVBRQkNCUklTTE1BTkNVL0NCSkFFSlJLR1hHWEdYR1hHWEFUQUVDS3JKMkJCQXRDS1pyQ0VaZklCRkdFQk1BS2hCODNFQkFLQ05KaEI4M0VCU0VNQUtBSTJCSUFJMkJCSG1DS3JIWUFZQ0U2SFl5ODZCQkFLQ0ZKQUlDSUpBWUpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NHSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDRUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ0lKQVlBbUpIWTJCQkFJMkJGSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ0xKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NLSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDT0pBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ05KQVlBbUpIWTJCQkFJMkJHSG1DS3JIUEFQQ0U2SFB5ODZCQkFLQ1ZKQVlBUEpIWTJCQkFtQ0lyQ0VaSFBBUENFNkhQeTg2QkJBS0NjSkFZQVBKSFkyQkJBbUNHckNFWkhQQVBDRTZIUHk4NkJCQUtDTUpBWUFQSkhZMkJCQW1DRVpIbUFtQ0U2SG15ODZCQkFLQ1NKQVlBbUpIbTJCQkFJMkJFSElDS3JIWUFZQ0U2SFl5ODZCQkFLQ1FKQW1BWUpIbTJCQkFJQ0lyQ0VaSFlBWUNFNkhZeTg2QkJBS0NmSkFtQVlKSG0yQkJBSUNHckNFWkhZQVlDRTZIWXk4NkJCQUtDYkpBbUFZSkhLMkJCQUlDRVpISUFJQ0U2SEl5ODZCQkFLQUlKUklTR01BS0FJMkJOQUkyQkJIbUNJckhZQVlDYjZIWXk4NkJCQUtDRkpBSUNOSkFZSkhZMkJCQW1DYlpIbUFtQ2I2SG15ODZCQkFLQ0dKQVlBbUpIbTJCQkFJMkJGSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ0VKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NJSkFtQVlKSG0yQkJBSTJCR0hZQ0lySFBBUENiNkhQeTg2QkJBS0NMSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDS0pBbUFZSkhtMkJCQUkyQkVIWUNJckhQQVBDYjZIUHk4NkJCQUtDT0pBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ05KQW1BWUpIbTJCQkFJMkJJSFlDSXJIUEFQQ2I2SFB5ODZCQkFLQ1ZKQW1BUEpIbTJCQkFZQ2JaSFlBWUNiNkhZeTg2QkJBS0NjSkFtQVlKSG0yQkJBSTJCTEhZQ0lySFBBUENiNkhQeTg2QkJBS0NNSkFtQVBKSG0yQkJBWUNiWkhZQVlDYjZIWXk4NkJCQUtDU0pBbUFZSkhtMkJCQUkyQktIWUNJckhQQVBDYjZIUHk4NkJCQUtDUUpBbUFQSkhtMkJCQVlDYlpIWUFZQ2I2SFl5ODZCQkFLQ2ZKQW1BWUpIbTJCQkFJMkJPSElDSXJIWUFZQ2I2SFl5ODZCQkFLQ2JKQW1BWUpISzJCQkFJQ2JaSElBSUNiNkhJeTg2QkJBS0FJSlJJU0ZNQUtBSThwQkI4M0JCQUtDTkpBSUNOSjhwQkI4M0JCQUlDVEpSSU1BdENHSlJ0QUVDVEpIRUFTOUpRQk1NR1hBSVFCQ0JSSVNFTUdYQU05RlFCQU5BYkoyQkJSdENCUktBZlJFRVhBRUFOQ1UvQ0JKQUtKMkJCSFRDRnJDQkFUQ0ZabDl6QXRKSHQ4NkJCQUVBR0pSRUFLQ0ZKSEtBTTlIUUJNTUFmQ0ZKUmZBSVJUQWJDRkpIYkFHOUhRQk1NQUJBY0FHOXNKQU5DVUdKQU1BRzlzVGtVVVVCcEFOQU5DVUdKQU1DYUpBRzlzSkFHVGtVVVVCcE1BTUNCQUl5QWNKUmNBSVFCTUM5K1JLU0ZNQ0JDOTlBT0FJbEFHQ0FBR0NBOUx5NnlSS01BTENVL0VCSjhrVVVVVUJBS00rT21GVGE4alVVVVVCQ29GbEhMOGtVVVVVQkM5K1JLR1hBRkNFOXVIT0N0SkFJOUxRQkNhUktBRTJCQkhOQy93RlpDL2dGOUhRQkFOQ2JaSFZDRjlMUUJBTENvQkpDZ0ZDVUZUK0pVVVVCcEFMQzg0SmhhODNFQkFMQzh3SmhhODNFQkFMQzhvSmhhODNFQkFMQ0FKaGE4M0VCQUxDaUpoYTgzRUJBTENUSmhhODNFQkFMaGE4M0VOQUxoYTgzRUJBRUFJSkM5d0pSY0FFQ0ZKSE5BT0pSTUdYQUY5RlFCQ1FDYkFWQ0Y2eVJTQUJSRUNCUlZDQlJRQ0JSZkNCUklDQlJLRVhHWEFNQWN1UUJDOStSS1NFTUdYR1hBTjJCQkhPQy92RjlMUUJBTENvQkpBT0NJckNhOXpBS0pDYlpDRVdKSGI4b0dJUlRBYjhvR0JSdEdYQU9DYlpIYkFTOVBRQkFMQU9DYTl6QUlKQ2JaQ0dXSjhvR0JBVkFieVJPQWI5RlJiR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFPODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQU9qR0JBRUNJSkFUakdCTUFWQWJKUlZBTENvQkpBS0NFV0pIbUFPakdCQW1BVGpHSUFMQUlDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkhLQ0VXSkhUQXRqR0JBVEFPakdJQUlBYkpSSUFLQ0ZKUktTR01HWEdYQWJDYjZRQkFRQWJKQWJDOTg5ekpDRkpSUVNGTUFNMUJCSGJDZ0ZaUk9HWEdYQWJDYTlNUUJBTUNGSlJNU0ZNQU0xQkZIYkNnQlpDT1dBT0NnQlpxUk9HWEFiQ2E5TVFCQU1DR0pSTVNGTUFNMUJHSGJDZ0JaQ2ZXQU9xUk9HWEFiQ2E5TVFCQU1DRUpSTVNGTUFNMUJFSGJDZ0JaQ2RXQU9xUk9HWEFiQ2E5TVFCQU1DSUpSTVNGTUFNMkJJQzhjV0FPcVJPQU1DTEpSTU1BT0NGckNCQU9DRlpsOXpBUUpSUU1HWEdYQUdDRzlIUUJBQkF0ODdGQkFCQ0lKQVE4N0ZCQUJDR0pBVDg3RkJTRk1BRUF0akdCQUVDTkpBUWpHQkFFQ0lKQVRqR0JNQUxDb0JKQUtDRVdKSE9BUWpHQkFPQVRqR0lBTEFJQ0dXSkFRakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIT0F0akdCQU9BUWpHSUFJQ0ZKUklBS0NGSlJLU0ZNR1hBT0NERjlMUUJBTEFJQWNBT0NiWkoyQkJIYkNJckhUbENiWkNHV0o4b0dCQVZDRkpIdEFUeVJPQUxBSUFibENiWkNHV0o4b0dCQXRBVDlGSG1KSHRBYkNiWkhUeVJiQVQ5RlJUR1hHWEFHQ0c5SFFCQUJBVjg3RkJBQkNJSkFiODdGQkFCQ0dKQU84N0ZCU0ZNQUVBVmpHQkFFQ05KQWJqR0JBRUNJSkFPakdCTUFMQUlDR1dKQVZqR0JBTENvQkpBS0NFV0pIWUFPakdCQVlBVmpHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0ZKQ2JaQ0VXSkhZQWJqR0JBWUFPakdJQUxBSUFtSkNiWkhJQ0dXSkFiakdCQUxDb0JKQUtDR0pDYlpIS0NFV0pIT0FWakdCQU9BYmpHSUFLQ0ZKUktBSUFUSlJJQXRBVEpSVlNGTUFWQ0JBTTJCQkhZeUhUQU9DLytGNkhQSlJPQVlDYlpSdEdYR1hBWUNJckhtUUJBT0NGSlJiU0ZNQU9SYkFMQUlBbWxDYlpDR1dKOG9HQlJPTUdYR1hBdFFCQWJDRkpSVlNGTUFiUlZBTEFJQVlsQ2JaQ0dXSjhvR0JSYk1HWEdYQVA5RlFCQU1DRkpSWVNGTUFNMUJGSFlDZ0ZaUlRHWEdYQVlDYTlNUUJBTUNHSlJZU0ZNQU0xQkdIWUNnQlpDT1dBVENnQlpxUlRHWEFZQ2E5TVFCQU1DRUpSWVNGTUFNMUJFSFlDZ0JaQ2ZXQVRxUlRHWEFZQ2E5TVFCQU1DSUpSWVNGTUFNMUJJSFlDZ0JaQ2RXQVRxUlRHWEFZQ2E5TVFCQU1DTEpSWVNGTUFNQ0tKUllBTTJCTEM4Y1dBVHFSVE1BVENGckNCQVRDRlpsOXpBUUpIUVJUTUdYR1hBbUNiNlFCQVlSUFNGTUFZMUJCSE1DZ0ZaUk9HWEdYQU1DYTlNUUJBWUNGSlJQU0ZNQVkxQkZITUNnQlpDT1dBT0NnQlpxUk9HWEFNQ2E5TVFCQVlDR0pSUFNGTUFZMUJHSE1DZ0JaQ2ZXQU9xUk9HWEFNQ2E5TVFCQVlDRUpSUFNGTUFZMUJFSE1DZ0JaQ2RXQU9xUk9HWEFNQ2E5TVFCQVlDSUpSUFNGTUFZQ0xKUlBBWTJCSUM4Y1dBT3FST01BT0NGckNCQU9DRlpsOXpBUUpIUVJPTUdYR1hBdENiNlFCQVBSTVNGTUFQMUJCSE1DZ0ZaUmJHWEdYQU1DYTlNUUJBUENGSlJNU0ZNQVAxQkZITUNnQlpDT1dBYkNnQlpxUmJHWEFNQ2E5TVFCQVBDR0pSTVNGTUFQMUJHSE1DZ0JaQ2ZXQWJxUmJHWEFNQ2E5TVFCQVBDRUpSTVNGTUFQMUJFSE1DZ0JaQ2RXQWJxUmJHWEFNQ2E5TVFCQVBDSUpSTVNGTUFQQ0xKUk1BUDJCSUM4Y1dBYnFSYk1BYkNGckNCQWJDRlpsOXpBUUpIUVJiTUdYR1hBR0NHOUhRQkFCQVQ4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVRqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTENvQkpBS0NFV0pIWUFPakdCQVlBVGpHSUFMQUlDR1dKQVRqR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlDRkpISUNiWkNHV0pBT2pHQkFMQ29CSkFLQ0dKQ2JaQ0VXSkhPQVRqR0JBT0FiakdJQUxBSUFtOUZBbUNiNnFKSElDYlpDR1dKQWJqR0JBSUF0OUZBdENiNnFKUklBS0NFSlJLTUFOQ0ZKUk5BQkNLSlJCQUVDU0pSRUFLQ2JaUktBSUNiWlJJQWZDRUpIZkFGOUpRQk1NQ0JDOTlBTUFjNnlSS01BTENvRko4a1VVVVVCQUtNL3RJRkdhOGpVVVVVQkNUbFJMQzkrUktHWEFGQ0xKQUk5TFFCQ2FSS0FFMkJCQy8rRlpDL1FGOUhRQkFMaEI4M0VOQUVDRkpSS0FFQUlKQzk4SlJFR1hBRjlGUUJHWEFHQ0c2UUJFWEdYQUtBRTlKUUJDOStiTUFLMUJCSEdDZ0ZaUklHWEdYQUdDYTlNUUJBS0NGSlJLU0ZNQUsxQkZIR0NnQlpDT1dBSUNnQlpxUklHWEFHQ2E5TVFCQUtDR0pSS1NGTUFLMUJHSEdDZ0JaQ2ZXQUlxUklHWEFHQ2E5TVFCQUtDRUpSS1NGTUFLMUJFSEdDZ0JaQ2RXQUlxUklHWEFHQ2E5TVFCQUtDSUpSS1NGTUFLMkJJQzhjV0FJcVJJQUtDTEpSS01BTENOSkFJQ0ZaQ0dXcUhHQUlDR3JDQkFJQ0ZyQ0ZabDl6QUc4b0dCSkhJakdCQUJBSWpHQkFCQ0lKUkJBRkNhSkhGUUJTR01NRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUJBSUNHckNCQUlDRnJDRlpsOXpBTENOSkFJQ0ZaQ0dXcUhJOG9HQkpIRzg3RkJBSUFHakdCQUJDR0pSQkFGQ2FKSEZRQk1NQ0JDOTlBS0FFNnlSS01BS00rbExLRmFGOTlHYUc5OUZhRzk5R1hHWEFHQ0k5SFFCQUY5RlFGRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNHSkhHMUJCK3lBQjFCQkhFK3lISStMK1RBQkNGSkhMMUJCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQkIvK2hBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODZCQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODZCQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODZCQkFCQ0lKUkJBRkNhSkhGUUJTR01NQUY5RlFCRVhHWEdYOURCQkI4LzlEQkJCKy9BQkNJSkhHOHVGQit5QUI4dUZCSEUreUhJK0wrVEFCQ0dKSEw4dUZCSEsreUhPK0wrVEhOOURCQkJCOWdIVnlBTjlEQi8rZzZBTkFOK1U5REJCQkJBTkFWeUhjQWMrTUhNQUVDYTN5QUkrU0hJQUkrVUFjQU1BS0NhM3lBTytTSGNBYytVK1MrUytSK1ZITytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SRVNGTUNVVVVVOTRSRU1BR0FFODdGQkdYR1g5REJCQjgvOURCQkIrL0FjOURCQkJCOWd5QWNBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BTEFHODdGQkdYR1g5REJCQjgvOURCQkIrL0FJOURCQkJCOWd5QUlBTytVK1NITitMOURCQkI5UDlkOUZRQkFOK29SR1NGTUNVVVVVOTRSR01BQkFHODdGQkFCQ05KUkJBRkNhSkhGUUJNTU0vU0VJRWFFOTlFYUY5OUdYQUY5RlFCQ0JSRUFCUklFWEdYR1g5RC96STgxOC9BSUNLSjh1RkJITENFcSt5K1ZIS0FJOHVGQit5K1VITzlEQi8rZzYrVTlEQkJCOC85REJCQisvQU85REJCQkI5Z3krU0hOK0w5REJCQjlQOWQ5RlFCQU4rb1JWU0ZNQ1VVVVU5NFJWTUFJQ0lKOHVGQlJjQUlDR0o4dUZCUk1BQkFMQ0ZKQ0VaQUVxQ0ZXSkFWODdGQkdYR1hBS0FNK3krVUhOOURCLytnNitVOURCQkI4LzlEQkJCKy9BTjlEQkJCQjlneStTSFMrTDlEQkJCOVA5ZDlGUUJBUytvUk1TRk1DVVVVVTk0Uk1NQUJBTENHSkNFWkFFcUNGV0pBTTg3RkJHWEdYQUtBYyt5K1VISzlEQi8rZzYrVTlEQkJCOC85REJCQisvQUs5REJCQkI5Z3krU0hTK0w5REJCQjlQOWQ5RlFCQVMrb1JjU0ZNQ1VVVVU5NFJjTUFCQUxDYUpDRVpBRXFDRldKQWM4N0ZCR1hHWDlEQkJVOC9BT0FPK1UrVEFOQU4rVStUQUtBSytVK1RITzlEQkJCQkFPOURCQkJCOWd5K1I5REIvK2c2K1U5REJCQjgvK1NITytMOURCQkI5UDlkOUZRQkFPK29SY1NGTUNVVVVVOTRSY01BQkFMQ0VaQUVxQ0ZXSkFjODdGQkFJQ05KUklBRUNJSlJFQUZDYUpIRlFCTU1NOUpCR1hBR0NHckFGOXNIRjlGUUJFWEFCQUI4b0dCSEdDTldDTjkxK3lBR0NpOTFDbldDVVVVLzhFSisrK1U4NEdCQUJDSUpSQkFGQ2FKSEZRQk1NTTlURkVhQ0JDQjhvR1VrVVVCSEZBQkNFSkM5OFpKSEJqR1VrVVVCR1hHWEFCOC9CQ1RXSEd1UUJDYVJFQUJBR2xDZ2dFSkNUclhCQ2E2UUZNQUZSRU1BRU0vbEZGRmFHWEdYQUZBQnFDRVo5RlFCQUJSRVNGTUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFGOG9HQmpHQkFFQ0lKQUZDSUo4b0dCakdCQUVDTkpBRkNOSjhvR0JqR0JBRUNTSkFGQ1NKOG9HQmpHQkFFQ1RKUkVBRkNUSlJGQUdDOXdKSEdDYjlMUUJNTUFHQ0k5SlFCRVhBRUFGOG9HQmpHQkFGQ0lKUkZBRUNJSlJFQUdDOThKSEdDRTlMUUJNTUdYQUc5RlFCRVhBRUFGMkJCODZCQkFFQ0ZKUkVBRkNGSlJGQUdDYUpIR1FCTU1BQk1vRkZHYUdYR1hBQkNFWjlGUUJBQlJFU0ZNQUZDZ0ZaQytCd3NOOXNSSUdYR1hBR0NUOVBRQkFCUkVTRk1BQlJFRVhBRUFJakdCQUVDU0pBSWpHQkFFQ05KQUlqR0JBRUNJSkFJakdCQUVDVEpSRUFHQzl3SkhHQ2I5TFFCTU1BR0NJOUpRQkVYQUVBSWpHQkFFQ0lKUkVBR0M5OEpIR0NFOUxRQk1NR1hBRzlGUUJFWEFFQUY4NkJCQUVDRkpSRUFHQ2FKSEdRQk1NQUJNTU1GQkNVTk1JVDlrQkJcIjtcbiAgY29uc3Qgd2FzbV9zaW1kID0gXCJCOWg5ejl0RkJCQkZpSTlnQkI5Z0xhYWFhYUZhOWdFYWFhQjlnRmFGYUVNY0JCRkJGRkdHR0VJTEY5d0ZGRkxFRkJGS05GYUZDeC9hRk1PL0xGVks5dHY5dDl2cTk1R0J0OWY5ZjkzOWg5ejl0OWY5ajloOXM5czlmOWpXOXZxOXpCQnA5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5V3ZxV3Y5NGg5MTltOW12cUJHOFo5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTRoOTE5bTltdnFCSXk5dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y5Sjl1OWt2OTQ5VHZaOTF2OXU5anZCTG45dHY5ejlvOXY5d1c5ZjlrdjlqOXY5a3Y2OXA5c1d2cTlQOWpXQktpOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5UjkxOWhXQk9uOXR2OXo5bzl2OXdXOWY5a3Y5ajl2OWt2NjlwOXNXdnE5Rjk0OXdCTkk5ejlpcWxCVmMrTjlJY0lCVEVNOStGTGE4alVVVVVCQ1RsUkJDQlJGRVhDQlJHQ0JSRUVYQUJDTkpBR0pBRUNVYUFGQUdyQ0ZaSEl5ODZCQkFFQUlKUkVBR0NGSkhHQ045SFFCTUFGQ3grWVVVQkpBRTg2QkJBRkNFV0N4a1VVQkpBQjhwRU44M0VCQUZDRkpIRkNVRzlIUUJNTWs4bExiYUU5N0Y5K0ZhTDk3OGpVVVVVQkNVL0tCbEhMOGtVVVVVQkM5K1JLR1hBR0NGSkFJOUxRQkNhUktBRTJCQkMrZ0Y5SFFCQUxBRUFJSkhPQUdsQUcvOGNCQkNVb0JBRzl1Qy93Z0JaSEtDVUdBS0NVRzlKeVJOQUVDRkpSS0NCUlZHWEVYQVZBRjlQUUZBTkFGQVZsQVZBTkpBRjlKeVJjR1hHWEFHOUZRQkFjQ2JKSElDOXdaSE1DRTlzUlNBTUNGV1JRQUlDSXJDRUpDR3JSZkNCUmJFWEFLUlRDQlJ0R1hFWEdYQU9BVGxBZjlQUUJDQlJLU0xNQUxDVS9DQkpBdEFNOXNKUm1BVEFmSlJLQ0JSRUdYQU1Db0I5SlFCQU9BS2xDL2dCOUpRQkNCUklFWEFtQUlKUkVHWEdYR1hHWEdYQVRBSUNLckoyQkJIWUNFWmZJQkZHRUJNQUVDQkR0RE1JQlNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUJBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUJBS0NUSlJLTUdYR1hHWEdYR1hBWUNHckNFWmZJQkZHRUJNQUVDQkR0RE1JVFNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSVRBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSVRBS0NUSlJLTUdYR1hHWEdYR1hBWUNJckNFWmZJQkZHRUJNQUVDQkR0RE1JQVNFTUFFQUtEQkJJQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkhQQ0dEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DMCtHK01pRHREOU9IZENFRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NJSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTR01BRUFLREJCTkFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25DK1ArZSs4LzRCRHREOU9IZENiRGJEOGpIUEFQRFFCRkdFTlZjTUlMS09TUWZiSGVEOGRCaCtCc3hveG9Vd04wQWVEOGRGaHhvVXdrd2srZ1VhMHNIbmhUa0Fuc0huaE5rQW5zSG43Q2dGWkhpQ0VXQ3hrVVVCSkRCRUJBaUN4K1lVVUJKREJCQkhlQWVEUUJCQkJCQkJCQkJCQkJCQkJBbmhBazdDZ0ZaSGlDRVdDeGtVVUJKREJFQkQ5dURRQkZHRUlMS09UdG1ZUGRlbkRmQWRBUEQ5U0RNSUFBS0NOSkFlRGVCSkFpQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSUFBS0NUSlJLTUdYR1hHWEdYR1hBWUNLcmZJQkZHRUJNQUVDQkR0RE1JOHdTRU1BRUFLREJCSUFLREJCQkhQQ0lEK01GQVBEUUJURnRHbUVZSVBMZEtlT25IUENHRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uQzArRytNaUR0RDlPSGRDRURiRDhqSFBBUERRQkZHRU5WY01JTEtPU1FmYkhlRDhkQmgrQnN4b3hvVXdOMEFlRDhkRmh4b1V3a3drK2dVYTBzSG5oVGtBbnNIbmhOa0Fuc0huN0NnRlpIWUNFV0N4a1VVQkpEQkVCQVlDeCtZVVVCSkRCQkJIZUFlRFFCQkJCQkJCQkJCQkJCQkJCQW5oQWs3Q2dGWkhZQ0VXQ3hrVVVCSkRCRUJEOXVEUUJGR0VJTEtPVHRtWVBkZW5EZkFkQVBEOVNETUk4d0FLQ0lKQWVEZUJKQVlDeCtZVVVCSjJCQkpSS1NHTUFFQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSFlDRVdDeGtVVUJKREJFQkFZQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIWUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JOHdBS0NOSkFlRGVCSkFZQ3grWVVVQkoyQkJKUktTRk1BRUFLREJCQkRNSTh3QUtDVEpSS01BSUNvQkpSRUFJQ1VGSkFNOUxRRkFFUklBT0FLbEMvZkI5TFFCTU1HWEFFQU05UFFCQUVDRXJSSUVYR1hBT0FLbENpOVBRQkNCUktTT01BbUFFSlJZR1hHWEdYR1hHWEFUQUVDS3JKMkJCQUlDS1pyQ0VaZklCRkdFQk1BWUNCRHRETUlCU0VNQVlBS0RCQklBS0RCQkJIUENJRCtNRkFQRFFCVEZ0R21FWUlQTGRLZU9uSFBDR0QrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMwK0crTWlEdEQ5T0hkQ0VEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ0lKQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NHTUFZQUtEQkJOQUtEQkJCSFBDSUQrTUZBUERRQlRGdEdtRVlJUExkS2VPbkMrUCtlKzgvNEJEdEQ5T0hkQ2JEYkQ4akhQQVBEUUJGR0VOVmNNSUxLT1NRZmJIZUQ4ZEJoK0JzeG94b1V3TjBBZUQ4ZEZoeG9Vd2t3aytnVWEwc0huaFRrQW5zSG5oTmtBbnNIbjdDZ0ZaSGlDRVdDeGtVVUJKREJFQkFpQ3grWVVVQkpEQkJCSGVBZURRQkJCQkJCQkJCQkJCQkJCQkFuaEFrN0NnRlpIaUNFV0N4a1VVQkpEQkVCRDl1RFFCRkdFSUxLT1R0bVlQZGVuRGZBZEFQRDlTRE1JQkFLQ05KQWVEZUJKQWlDeCtZVVVCSjJCQkpSS1NGTUFZQUtEQkJCRE1JQkFLQ1RKUktNQUlDR0pSSUFFQ1RKSEVBTTlKUUJNTUdYQUs5RlFCQUtSVEF0Q0ZKSHRDSTZRR1NGTU1DQlJLU0VNR1hBTTlGUUJBTENVR0pBYkpSRUFMQWJKREJHQlJlQ0JSWUVYQUVBTENVL0NCSkFZSkhJREJJQkhkQ0ZEOXRBZENGRGJIUEQ5T0Q5aEQ5UkhkQUlBTUpEQklCSDhaQ0ZEOXRBOFpBUEQ5T0Q5aEQ5Ukg4WkRRQlRGdEdtRVlJUExkS2VPbkhwQUlBUUpEQklCSHlDRkQ5dEF5QVBEOU9EOWhEOVJIeUFJQVNKREJJQkg4Y0NGRDl0QThjQVBEOU9EOWhEOVJIOGNEUUJURnRHbUVZSVBMZEtlT25IOGREUUJGVHRHRW1ZSUxQZEtPZW5IUEFQRFFCRkdFQkZHRUJGR0VCRkdFQWVEOXVIZUR5QmpHQkFFQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKSElBZUFwQThkRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIUEFQRFFCRkdFQkZHRUJGR0VCRkdFRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFJTEtPSUxLT0lMS09JTEtPRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFOVmNNTlZjTU5WY01OVmNNRDl1SGVEeUJqR0JBSUFHSkhJQWVBUEFQRFFTUWZiU1FmYlNRZmJTUWZiRDl1SGVEeUJqR0JBSUFHSkhJQWVBZEE4WkRRTmlWOFpjcE15UzhjUThkZjhlYjhmSGRBeUE4Y0RRTmlWOFpjcE15UzhjUThkZjhlYjhmSDhaRFFCRlR0R0VtWUlMUGRLT2VuSFBBUERRQkZHRUJGR0VCRkdFQkZHRUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRSUxLT0lMS09JTEtPSUxLT0Q5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRTlZjTU5WY01OVmNNTlZjTUQ5dUhlRHlCakdCQUlBR0pISUFlQVBBUERRU1FmYlNRZmJTUWZiU1FmYkQ5dUhlRHlCakdCQUlBR0pISUFlQWRBOFpEUU5WaThaY01weVNROGM4ZGZiOGU4ZkhQQVBEUUJGR0VCRkdFQkZHRUJGR0VEOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUUlMS09JTEtPSUxLT0lMS09EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUU5WY01OVmNNTlZjTU5WY01EOXVIZUR5QmpHQkFJQUdKSElBZUFQQVBEUVNRZmJTUWZiU1FmYlNRZmJEOXVIZUR5QmpHQkFJQUdKUkVBWUNUSkhZQU05SlFCTU1BYkNJSkhiQUc5SlFCTU1BQkFWQUc5c0pBTENVR0pBY0FHOXMvOGNCQkFMQUxDVUdKQWNDYUpBRzlzSkFHLzhjQkJNQWNDQkFLeUFWSlJWQUtRQk1DOStSS1NGTUNCQzk5QU9BS2xBR0NBQUdDQTlMeTZ5UktNQUxDVS9LQko4a1VVVVVCQUtNTkJUK0JVVVVCTStLbUZUYThqVVVVVUJDb0ZsSEw4a1VVVVVCQzkrUktHWEFGQ0U5dUhPQ3RKQUk5TFFCQ2FSS0FFMkJCSE5DL3dGWkMvZ0Y5SFFCQU5DYlpIVkNGOUxRQkFMQ29CSkNnRkNVRi84TUJBTEM4NEpoYTgzRUJBTEM4d0poYTgzRUJBTEM4b0poYTgzRUJBTENBSmhhODNFQkFMQ2lKaGE4M0VCQUxDVEpoYTgzRUJBTGhhODNFTkFMaGE4M0VCQUVBSUpDOXdKUmNBRUNGSkhOQU9KUk1HWEFGOUZRQkNRQ2JBVkNGNnlSU0FCUkVDQlJWQ0JSUUNCUmZDQlJJQ0JSS0VYR1hBTUFjdVFCQzkrUktTRU1HWEdYQU4yQkJIT0MvdkY5TFFCQUxDb0JKQU9DSXJDYTl6QUtKQ2JaQ0VXSkhiOG9HSVJUQWI4b0dCUnRHWEFPQ2JaSGJBUzlQUUJBTEFPQ2E5ekFJSkNiWkNHV0o4b0dCQVZBYnlST0FiOUZSYkdYR1hBR0NHOUhRQkFCQXQ4N0ZCQUJDSUpBTzg3RkJBQkNHSkFUODdGQlNGTUFFQXRqR0JBRUNOSkFPakdCQUVDSUpBVGpHQk1BVkFiSlJWQUxDb0JKQUtDRVdKSG1BT2pHQkFtQVRqR0lBTEFJQ0dXSkFPakdCQUxDb0JKQUtDRkpDYlpIS0NFV0pIVEF0akdCQVRBT2pHSUFJQWJKUklBS0NGSlJLU0dNR1hHWEFiQ2I2UUJBUUFiSkFiQzk4OXpKQ0ZKUlFTRk1BTTFCQkhiQ2dGWlJPR1hHWEFiQ2E5TVFCQU1DRkpSTVNGTUFNMUJGSGJDZ0JaQ09XQU9DZ0JacVJPR1hBYkNhOU1RQkFNQ0dKUk1TRk1BTTFCR0hiQ2dCWkNmV0FPcVJPR1hBYkNhOU1RQkFNQ0VKUk1TRk1BTTFCRUhiQ2dCWkNkV0FPcVJPR1hBYkNhOU1RQkFNQ0lKUk1TRk1BTTJCSUM4Y1dBT3FST0FNQ0xKUk1NQU9DRnJDQkFPQ0ZabDl6QVFKUlFNR1hHWEFHQ0c5SFFCQUJBdDg3RkJBQkNJSkFRODdGQkFCQ0dKQVQ4N0ZCU0ZNQUVBdGpHQkFFQ05KQVFqR0JBRUNJSkFUakdCTUFMQ29CSkFLQ0VXSkhPQVFqR0JBT0FUakdJQUxBSUNHV0pBUWpHQkFMQ29CSkFLQ0ZKQ2JaSEtDRVdKSE9BdGpHQkFPQVFqR0lBSUNGSlJJQUtDRkpSS1NGTUdYQU9DREY5TFFCQUxBSUFjQU9DYlpKMkJCSGJDSXJIVGxDYlpDR1dKOG9HQkFWQ0ZKSHRBVHlST0FMQUlBYmxDYlpDR1dKOG9HQkF0QVQ5RkhtSkh0QWJDYlpIVHlSYkFUOUZSVEdYR1hBR0NHOUhRQkFCQVY4N0ZCQUJDSUpBYjg3RkJBQkNHSkFPODdGQlNGTUFFQVZqR0JBRUNOSkFiakdCQUVDSUpBT2pHQk1BTEFJQ0dXSkFWakdCQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVZqR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NGSkNiWkNFV0pIWUFiakdCQVlBT2pHSUFMQUlBbUpDYlpISUNHV0pBYmpHQkFMQ29CSkFLQ0dKQ2JaSEtDRVdKSE9BVmpHQkFPQWJqR0lBS0NGSlJLQUlBVEpSSUF0QVRKUlZTRk1BVkNCQU0yQkJIWXlIVEFPQy8rRjZIUEpST0FZQ2JaUnRHWEdYQVlDSXJIbVFCQU9DRkpSYlNGTUFPUmJBTEFJQW1sQ2JaQ0dXSjhvR0JST01HWEdYQXRRQkFiQ0ZKUlZTRk1BYlJWQUxBSUFZbENiWkNHV0o4b0dCUmJNR1hHWEFQOUZRQkFNQ0ZKUllTRk1BTTFCRkhZQ2dGWlJUR1hHWEFZQ2E5TVFCQU1DR0pSWVNGTUFNMUJHSFlDZ0JaQ09XQVRDZ0JacVJUR1hBWUNhOU1RQkFNQ0VKUllTRk1BTTFCRUhZQ2dCWkNmV0FUcVJUR1hBWUNhOU1RQkFNQ0lKUllTRk1BTTFCSUhZQ2dCWkNkV0FUcVJUR1hBWUNhOU1RQkFNQ0xKUllTRk1BTUNLSlJZQU0yQkxDOGNXQVRxUlRNQVRDRnJDQkFUQ0ZabDl6QVFKSFFSVE1HWEdYQW1DYjZRQkFZUlBTRk1BWTFCQkhNQ2dGWlJPR1hHWEFNQ2E5TVFCQVlDRkpSUFNGTUFZMUJGSE1DZ0JaQ09XQU9DZ0JacVJPR1hBTUNhOU1RQkFZQ0dKUlBTRk1BWTFCR0hNQ2dCWkNmV0FPcVJPR1hBTUNhOU1RQkFZQ0VKUlBTRk1BWTFCRUhNQ2dCWkNkV0FPcVJPR1hBTUNhOU1RQkFZQ0lKUlBTRk1BWUNMSlJQQVkyQklDOGNXQU9xUk9NQU9DRnJDQkFPQ0ZabDl6QVFKSFFST01HWEdYQXRDYjZRQkFQUk1TRk1BUDFCQkhNQ2dGWlJiR1hHWEFNQ2E5TVFCQVBDRkpSTVNGTUFQMUJGSE1DZ0JaQ09XQWJDZ0JacVJiR1hBTUNhOU1RQkFQQ0dKUk1TRk1BUDFCR0hNQ2dCWkNmV0FicVJiR1hBTUNhOU1RQkFQQ0VKUk1TRk1BUDFCRUhNQ2dCWkNkV0FicVJiR1hBTUNhOU1RQkFQQ0lKUk1TRk1BUENMSlJNQVAyQklDOGNXQWJxUmJNQWJDRnJDQkFiQ0ZabDl6QVFKSFFSYk1HWEdYQUdDRzlIUUJBQkFUODdGQkFCQ0lKQWI4N0ZCQUJDR0pBTzg3RkJTRk1BRUFUakdCQUVDTkpBYmpHQkFFQ0lKQU9qR0JNQUxDb0JKQUtDRVdKSFlBT2pHQkFZQVRqR0lBTEFJQ0dXSkFUakdCQUxDb0JKQUtDRkpDYlpDRVdKSFlBYmpHQkFZQU9qR0lBTEFJQ0ZKSElDYlpDR1dKQU9qR0JBTENvQkpBS0NHSkNiWkNFV0pIT0FUakdCQU9BYmpHSUFMQUlBbTlGQW1DYjZxSkhJQ2JaQ0dXSkFiakdCQUlBdDlGQXRDYjZxSlJJQUtDRUpSS01BTkNGSlJOQUJDS0pSQkFFQ1NKUkVBS0NiWlJLQUlDYlpSSUFmQ0VKSGZBRjlKUUJNTUNCQzk5QU1BYzZ5UktNQUxDb0ZKOGtVVVVVQkFLTS90SUZHYThqVVVVVUJDVGxSTEM5K1JLR1hBRkNMSkFJOUxRQkNhUktBRTJCQkMvK0ZaQy9RRjlIUUJBTGhCODNFTkFFQ0ZKUktBRUFJSkM5OEpSRUdYQUY5RlFCR1hBR0NHNlFCRVhHWEFLQUU5SlFCQzkrYk1BSzFCQkhHQ2dGWlJJR1hHWEFHQ2E5TVFCQUtDRkpSS1NGTUFLMUJGSEdDZ0JaQ09XQUlDZ0JacVJJR1hBR0NhOU1RQkFLQ0dKUktTRk1BSzFCR0hHQ2dCWkNmV0FJcVJJR1hBR0NhOU1RQkFLQ0VKUktTRk1BSzFCRUhHQ2dCWkNkV0FJcVJJR1hBR0NhOU1RQkFLQ0lKUktTRk1BSzJCSUM4Y1dBSXFSSUFLQ0xKUktNQUxDTkpBSUNGWkNHV3FIR0FJQ0dyQ0JBSUNGckNGWmw5ekFHOG9HQkpISWpHQkFCQUlqR0JBQkNJSlJCQUZDYUpIRlFCU0dNTUVYR1hBS0FFOUpRQkM5K2JNQUsxQkJIR0NnRlpSSUdYR1hBR0NhOU1RQkFLQ0ZKUktTRk1BSzFCRkhHQ2dCWkNPV0FJQ2dCWnFSSUdYQUdDYTlNUUJBS0NHSlJLU0ZNQUsxQkdIR0NnQlpDZldBSXFSSUdYQUdDYTlNUUJBS0NFSlJLU0ZNQUsxQkVIR0NnQlpDZFdBSXFSSUdYQUdDYTlNUUJBS0NJSlJLU0ZNQUsyQklDOGNXQUlxUklBS0NMSlJLTUFCQUlDR3JDQkFJQ0ZyQ0ZabDl6QUxDTkpBSUNGWkNHV3FISThvR0JKSEc4N0ZCQUlBR2pHQkFCQ0dKUkJBRkNhSkhGUUJNTUNCQzk5QUtBRTZ5UktNQUtNL2RMRUs5N0ZhRjk3R1hHWEFHQ0k5SFFCQUY5RlFGQ0JSR0VYQUJBQkRCQkJIRUNpRCtyRkNpRCtzRkQvNkZISUFFQ05EK3JGQ2lEK3NGRC82RkFJRC9nRkFFQ1REK3JGQ2lEK3NGRC82RkhMRC9nRkQva0ZEL2xGSEtDQkR0RCsyRkhPQUlDVVVVVTk0RHRITkQ5T0Q5UkQva0ZISTlEQkIvK2hEWUFJQUlEL21GQUtBS0QvbUZBTEFPQUxBTkQ5T0Q5UkQva0ZISUFJRC9tRkQva0ZEL2tGRC9qRkQvbkZITEQvbUY5REJCWDlMRFlIT0Qva0ZDZ0ZEdEQ5T0FFQ1VVVTk0RHREOU9EOVFBSUFMRC9tRkFPRC9rRkNORCtyRkNVLytFRHREOU9EOVFBS0FMRC9tRkFPRC9rRkNURCtyRkNVVS84T0R0RDlPRDlRRE1CQkFCQ1RKUkJBR0NJSkhHQUY5SlFCU0dNTUFGOUZRQkNCUkdFWEFCQ1RKSFZBVkRCQkJIRUNCRHRIT0NVVTk4RDhjRkNVVTk4RDhjRUhORDlPQUJEQkJCSEtBRURRSUxLT1NRZmJQZGVuOGM4ZDhlOGZDZ2dGRHREOU9ELzZGQUtBRURRQkZHRU5WY01UdG1ZaThacHlIRUNURCtzRkQvNkZISUQvZ0ZBRUNURCtyRkNURCtzRkQvNkZITEQvZ0ZEL2tGRC9sRkhFOURCLytnNkRZQUxBRUFPRCsyRkhPQUxDVVVVVTk0RHRIY0Q5T0Q5UkQva0ZITEFMRC9tRkFFQUVEL21GQUlBT0FJQWNEOU9EOVJEL2tGSEVBRUQvbUZEL2tGRC9rRkQvakZEL25GSElEL21GOURCQlg5TERZSE9EL2tGQ1REK3JGQUxBSUQvbUZBT0Qva0ZDZ2dFRHREOU9EOVFITEFFQUlEL21GQU9EL2tGQ2FEYkNCRG5HQ0JEbkVDQkRuS0NCRG5PQ0JEbmNDQkRuTUNCRG5mQ0JEbmJEOU9IRURRTlZpOFpjTXB5U1E4YzhkZmI4ZThmRDlRRE1CQkFCQUtBTkQ5T0FMQUVEUUJGVHRHRW1ZSUxQZEtPZW5EOVFETUJCQUJDQUpSQkFHQ0lKSEdBRjlKUUJNTU0vaEVJR2FGOTdGYUw5NzhqVVVVVUJDVGxSRUdYQUY5RlFCQ0JSSUVYQUVBQkRCQkJITEFCQ1RKSEtEQkJCSE9EUUlMS09TUWZiUGRlbjhjOGQ4ZThmSE5DVEQrc0ZIVkNJRCtyRkRNSUJBQjlEQkJVOC9EWTlEL3pJODE4L0RZQVZDRUR0RDlRRC82RkQvbkZIVkFMQU9EUUJGR0VOVmNNVHRtWWk4WnB5SExDVEQrckZDVEQrc0ZELzZGRC9tRkhPQU9EL21GQVZBTENURCtzRkQvNkZEL21GSGNBY0QvbUZBVkFOQ1REK3JGQ1REK3NGRC82RkQvbUZITkFORC9tRkQva0ZEL2tGRC9sRkNCRHREKzRGRC9qRjlEQi8rZzZEWUhWRC9tRjlEQkJYOUxEWUhMRC9rRkNnZ0VEdEhNRDlPQWNBVkQvbUZBTEQva0ZDVEQrckZEOVFIY0FOQVZEL21GQUxEL2tGQ1REK3JGQU9BVkQvbUZBTEQva0ZBTUQ5T0Q5UUhWRFFCRlR0R0VtWUlMUGRLT2VuSExEOGRCQUVEQklCRHlCK3QrSjgzRUJBQkNOSkFMRDhkRkFFREJJQkR5Rit0K0o4M0VCQUtBY0FWRFFOVmk4WmNNcHlTUThjOGRmYjhlOGZIVkQ4ZEJBRURCSUJEeUcrdCtKODNFQkFCQ2lKQVZEOGRGQUVEQklCRHlFK3QrSjgzRUJBQkNBSlJCQUlDSUpISUFGOUpRQk1NTTlqRkY5N0dYQUdDR3JBRjlzSEc5RlFCQ0JSRkVYQUJBQkRCQkJIRUNORCtyRkNORCtzRkQvNkZBRUNpRCtzRkNuRCtyRkNVVVUvOEVEdEQrdUZEL21GRE1CQkFCQ1RKUkJBRkNJSkhGQUc5SlFCTU1NOVRGRWFDQkNCOG9HVWtVVUJIRkFCQ0VKQzk4WkpIQmpHVWtVVUJHWEdYQUI4L0JDVFdIR3VRQkNhUkVBQkFHbENnZ0VKQ1RyWEJDYTZRRk1BRlJFTUFFTU1NRkJDVU5NSVQ5dEJCXCI7XG4gIGNvbnN0IGRldGVjdG9yID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDAsXG4gICAgOTcsXG4gICAgMTE1LFxuICAgIDEwOSxcbiAgICAxLFxuICAgIDAsXG4gICAgMCxcbiAgICAwLFxuICAgIDEsXG4gICAgNCxcbiAgICAxLFxuICAgIDk2LFxuICAgIDAsXG4gICAgMCxcbiAgICAzLFxuICAgIDMsXG4gICAgMixcbiAgICAwLFxuICAgIDAsXG4gICAgNSxcbiAgICAzLFxuICAgIDEsXG4gICAgMCxcbiAgICAxLFxuICAgIDEyLFxuICAgIDEsXG4gICAgMCxcbiAgICAxMCxcbiAgICAyMixcbiAgICAyLFxuICAgIDEyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICA2NSxcbiAgICAwLFxuICAgIDY1LFxuICAgIDAsXG4gICAgMjUyLFxuICAgIDEwLFxuICAgIDAsXG4gICAgMCxcbiAgICAxMSxcbiAgICA3LFxuICAgIDAsXG4gICAgNjUsXG4gICAgMCxcbiAgICAyNTMsXG4gICAgMTUsXG4gICAgMjYsXG4gICAgMTFcbiAgXSk7XG4gIGNvbnN0IHdhc21wYWNrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgIDMyLFxuICAgIDAsXG4gICAgNjUsXG4gICAgMjUzLFxuICAgIDMsXG4gICAgMSxcbiAgICAyLFxuICAgIDM0LFxuICAgIDQsXG4gICAgMTA2LFxuICAgIDYsXG4gICAgNSxcbiAgICAxMSxcbiAgICA4LFxuICAgIDcsXG4gICAgMjAsXG4gICAgMTMsXG4gICAgMzMsXG4gICAgMTIsXG4gICAgMTYsXG4gICAgMTI4LFxuICAgIDksXG4gICAgMTE2LFxuICAgIDY0LFxuICAgIDE5LFxuICAgIDExMyxcbiAgICAxMjcsXG4gICAgMTUsXG4gICAgMTAsXG4gICAgMjEsXG4gICAgMjIsXG4gICAgMTQsXG4gICAgMjU1LFxuICAgIDY2LFxuICAgIDI0LFxuICAgIDU0LFxuICAgIDEzNixcbiAgICAxMDcsXG4gICAgMTgsXG4gICAgMjMsXG4gICAgMTkyLFxuICAgIDI2LFxuICAgIDExNCxcbiAgICAxMTgsXG4gICAgMTMyLFxuICAgIDE3LFxuICAgIDc3LFxuICAgIDEwMSxcbiAgICAxMzAsXG4gICAgMTQ0LFxuICAgIDI3LFxuICAgIDg3LFxuICAgIDEzMSxcbiAgICA0NCxcbiAgICA0NSxcbiAgICA3NCxcbiAgICAxNTYsXG4gICAgMTU0LFxuICAgIDcwLFxuICAgIDE2N1xuICBdKTtcbiAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiB7XG4gICAgICBzdXBwb3J0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBsZXQgd2FzbSA9IHdhc21fYmFzZTtcbiAgaWYgKFdlYkFzc2VtYmx5LnZhbGlkYXRlKGRldGVjdG9yKSkge1xuICAgIHdhc20gPSB3YXNtX3NpbWQ7XG4gIH1cbiAgbGV0IGluc3RhbmNlO1xuICBjb25zdCBwcm9taXNlID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUodW5wYWNrKHdhc20pLCB7fSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgaW5zdGFuY2UgPSByZXN1bHQuaW5zdGFuY2U7XG4gICAgaW5zdGFuY2UuZXhwb3J0cy5fX3dhc21fY2FsbF9jdG9ycygpO1xuICB9KTtcbiAgZnVuY3Rpb24gdW5wYWNrKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBjaCA9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHJlc3VsdFtpXSA9IGNoID4gOTYgPyBjaCAtIDcxIDogY2ggPiA2NCA/IGNoIC0gNjUgOiBjaCA+IDQ3ID8gY2ggKyA0IDogY2ggPiA0NiA/IDYzIDogNjI7XG4gICAgfVxuICAgIGxldCB3cml0ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICByZXN1bHRbd3JpdGUrK10gPSByZXN1bHRbaV0gPCA2MCA/IHdhc21wYWNrW3Jlc3VsdFtpXV0gOiAocmVzdWx0W2ldIC0gNjApICogNjQgKyByZXN1bHRbKytpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5idWZmZXIuc2xpY2UoMCwgd3JpdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZShmdW4sIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgZmlsdGVyKSB7XG4gICAgY29uc3Qgc2JyayA9IGluc3RhbmNlLmV4cG9ydHMuc2JyaztcbiAgICBjb25zdCBjb3VudDQgPSBjb3VudCArIDMgJiB+MztcbiAgICBjb25zdCB0cCA9IHNicmsoY291bnQ0ICogc2l6ZSk7XG4gICAgY29uc3Qgc3AgPSBzYnJrKHNvdXJjZS5sZW5ndGgpO1xuICAgIGNvbnN0IGhlYXAgPSBuZXcgVWludDhBcnJheShpbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgIGhlYXAuc2V0KHNvdXJjZSwgc3ApO1xuICAgIGNvbnN0IHJlcyA9IGZ1bih0cCwgY291bnQsIHNpemUsIHNwLCBzb3VyY2UubGVuZ3RoKTtcbiAgICBpZiAocmVzID09PSAwICYmIGZpbHRlcikge1xuICAgICAgZmlsdGVyKHRwLCBjb3VudDQsIHNpemUpO1xuICAgIH1cbiAgICB0YXJnZXQuc2V0KGhlYXAuc3ViYXJyYXkodHAsIHRwICsgY291bnQgKiBzaXplKSk7XG4gICAgc2Jyayh0cCAtIHNicmsoMCkpO1xuICAgIGlmIChyZXMgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGJ1ZmZlciBkYXRhOiAke3Jlc31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmlsdGVycyA9IHtcbiAgICAvLyBsZWdhY3kgaW5kZXgtYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICAwOiBcIlwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICAyOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIDM6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJFeHBcIixcbiAgICAvLyBzdHJpbmctYmFzZWQgZW51bXMgZm9yIGdsVEZcbiAgICBOT05FOiBcIlwiLFxuICAgIE9DVEFIRURSQUw6IFwibWVzaG9wdF9kZWNvZGVGaWx0ZXJPY3RcIixcbiAgICBRVUFURVJOSU9OOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyUXVhdFwiLFxuICAgIEVYUE9ORU5USUFMOiBcIm1lc2hvcHRfZGVjb2RlRmlsdGVyRXhwXCJcbiAgfTtcbiAgY29uc3QgZGVjb2RlcnMgPSB7XG4gICAgLy8gbGVnYWN5IGluZGV4LWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgMDogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIDE6IFwibWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlclwiLFxuICAgIDI6IFwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlXCIsXG4gICAgLy8gc3RyaW5nLWJhc2VkIGVudW1zIGZvciBnbFRGXG4gICAgQVRUUklCVVRFUzogXCJtZXNob3B0X2RlY29kZVZlcnRleEJ1ZmZlclwiLFxuICAgIFRSSUFOR0xFUzogXCJtZXNob3B0X2RlY29kZUluZGV4QnVmZmVyXCIsXG4gICAgSU5ESUNFUzogXCJtZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2VcIlxuICB9O1xuICBnZW5lcmF0ZWQgPSB7XG4gICAgcmVhZHk6IHByb21pc2UsXG4gICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgIGRlY29kZVZlcnRleEJ1ZmZlcih0YXJnZXQsIGNvdW50LCBzaXplLCBzb3VyY2UsIGZpbHRlcikge1xuICAgICAgZGVjb2RlKFxuICAgICAgICBpbnN0YW5jZS5leHBvcnRzLm1lc2hvcHRfZGVjb2RlVmVydGV4QnVmZmVyLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4QnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSkge1xuICAgICAgZGVjb2RlKGluc3RhbmNlLmV4cG9ydHMubWVzaG9wdF9kZWNvZGVJbmRleEJ1ZmZlciwgdGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKTtcbiAgICB9LFxuICAgIGRlY29kZUluZGV4U2VxdWVuY2UodGFyZ2V0LCBjb3VudCwgc2l6ZSwgc291cmNlKSB7XG4gICAgICBkZWNvZGUoaW5zdGFuY2UuZXhwb3J0cy5tZXNob3B0X2RlY29kZUluZGV4U2VxdWVuY2UsIHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSk7XG4gICAgfSxcbiAgICBkZWNvZGVHbHRmQnVmZmVyKHRhcmdldCwgY291bnQsIHNpemUsIHNvdXJjZSwgbW9kZSwgZmlsdGVyKSB7XG4gICAgICBkZWNvZGUoXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZGVjb2RlcnNbbW9kZV1dLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvdW50LFxuICAgICAgICBzaXplLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbZmlsdGVyc1tmaWx0ZXJdXVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBnZW5lcmF0ZWQ7XG59O1xuZXhwb3J0IHtcbiAgTWVzaG9wdERlY29kZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNob3B0RGVjb2Rlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJnZW5lcmF0ZWQiLCJNZXNob3B0RGVjb2RlciIsIndhc21fYmFzZSIsIndhc21fc2ltZCIsImRldGVjdG9yIiwiVWludDhBcnJheSIsIndhc21wYWNrIiwiV2ViQXNzZW1ibHkiLCJzdXBwb3J0ZWQiLCJ3YXNtIiwidmFsaWRhdGUiLCJpbnN0YW5jZSIsInByb21pc2UiLCJpbnN0YW50aWF0ZSIsInVucGFjayIsInRoZW4iLCJyZXN1bHQiLCJleHBvcnRzIiwiX193YXNtX2NhbGxfY3RvcnMiLCJkYXRhIiwibGVuZ3RoIiwiaSIsImNoIiwiY2hhckNvZGVBdCIsIndyaXRlIiwiYnVmZmVyIiwic2xpY2UiLCJkZWNvZGUiLCJmdW4iLCJ0YXJnZXQiLCJjb3VudCIsInNpemUiLCJzb3VyY2UiLCJmaWx0ZXIiLCJzYnJrIiwiY291bnQ0IiwidHAiLCJzcCIsImhlYXAiLCJtZW1vcnkiLCJzZXQiLCJyZXMiLCJzdWJhcnJheSIsIkVycm9yIiwiZmlsdGVycyIsIk5PTkUiLCJPQ1RBSEVEUkFMIiwiUVVBVEVSTklPTiIsIkVYUE9ORU5USUFMIiwiZGVjb2RlcnMiLCJBVFRSSUJVVEVTIiwiVFJJQU5HTEVTIiwiSU5ESUNFUyIsInJlYWR5IiwiZGVjb2RlVmVydGV4QnVmZmVyIiwibWVzaG9wdF9kZWNvZGVWZXJ0ZXhCdWZmZXIiLCJkZWNvZGVJbmRleEJ1ZmZlciIsIm1lc2hvcHRfZGVjb2RlSW5kZXhCdWZmZXIiLCJkZWNvZGVJbmRleFNlcXVlbmNlIiwibWVzaG9wdF9kZWNvZGVJbmRleFNlcXVlbmNlIiwiZGVjb2RlR2x0ZkJ1ZmZlciIsIm1vZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/DRACOLoader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DRACOLoader: () => (/* binding */ DRACOLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst _taskCache = /* @__PURE__ */ new WeakMap();\nclass DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.decoderPath = \"\";\n        this.decoderConfig = {};\n        this.decoderBinary = null;\n        this.decoderPending = null;\n        this.workerLimit = 4;\n        this.workerPool = [];\n        this.workerNextTaskID = 1;\n        this.workerSourceURL = \"\";\n        this.defaultAttributeIDs = {\n            position: \"POSITION\",\n            normal: \"NORMAL\",\n            color: \"COLOR\",\n            uv: \"TEX_COORD\"\n        };\n        this.defaultAttributeTypes = {\n            position: \"Float32Array\",\n            normal: \"Float32Array\",\n            color: \"Float32Array\",\n            uv: \"Float32Array\"\n        };\n    }\n    setDecoderPath(path) {\n        this.decoderPath = path;\n        return this;\n    }\n    setDecoderConfig(config) {\n        this.decoderConfig = config;\n        return this;\n    }\n    setWorkerLimit(workerLimit) {\n        this.workerLimit = workerLimit;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, (buffer)=>{\n            const taskConfig = {\n                attributeIDs: this.defaultAttributeIDs,\n                attributeTypes: this.defaultAttributeTypes,\n                useUniqueIDs: false\n            };\n            this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n        }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */ decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n        const taskConfig = {\n            attributeIDs: attributeIDs || this.defaultAttributeIDs,\n            attributeTypes: attributeTypes || this.defaultAttributeTypes,\n            useUniqueIDs: !!attributeIDs\n        };\n        this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n    decodeGeometry(buffer, taskConfig) {\n        for(const attribute in taskConfig.attributeTypes){\n            const type = taskConfig.attributeTypes[attribute];\n            if (type.BYTES_PER_ELEMENT !== void 0) {\n                taskConfig.attributeTypes[attribute] = type.name;\n            }\n        }\n        const taskKey = JSON.stringify(taskConfig);\n        if (_taskCache.has(buffer)) {\n            const cachedTask = _taskCache.get(buffer);\n            if (cachedTask.key === taskKey) {\n                return cachedTask.promise;\n            } else if (buffer.byteLength === 0) {\n                throw new Error(\"THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.\");\n            }\n        }\n        let worker;\n        const taskID = this.workerNextTaskID++;\n        const taskCost = buffer.byteLength;\n        const geometryPending = this._getWorker(taskID, taskCost).then((_worker)=>{\n            worker = _worker;\n            return new Promise((resolve, reject)=>{\n                worker._callbacks[taskID] = {\n                    resolve,\n                    reject\n                };\n                worker.postMessage({\n                    type: \"decode\",\n                    id: taskID,\n                    taskConfig,\n                    buffer\n                }, [\n                    buffer\n                ]);\n            });\n        }).then((message)=>this._createGeometry(message.geometry));\n        geometryPending.catch(()=>true).then(()=>{\n            if (worker && taskID) {\n                this._releaseTask(worker, taskID);\n            }\n        });\n        _taskCache.set(buffer, {\n            key: taskKey,\n            promise: geometryPending\n        });\n        return geometryPending;\n    }\n    _createGeometry(geometryData) {\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n        if (geometryData.index) {\n            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1));\n        }\n        for(let i = 0; i < geometryData.attributes.length; i++){\n            const attribute = geometryData.attributes[i];\n            const name = attribute.name;\n            const array = attribute.array;\n            const itemSize = attribute.itemSize;\n            geometry.setAttribute(name, new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize));\n        }\n        return geometry;\n    }\n    _loadLibrary(url, responseType) {\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.decoderPath);\n        loader.setResponseType(responseType);\n        loader.setWithCredentials(this.withCredentials);\n        return new Promise((resolve, reject)=>{\n            loader.load(url, resolve, void 0, reject);\n        });\n    }\n    preload() {\n        this._initDecoder();\n        return this;\n    }\n    _initDecoder() {\n        if (this.decoderPending) return this.decoderPending;\n        const useJS = typeof WebAssembly !== \"object\" || this.decoderConfig.type === \"js\";\n        const librariesPending = [];\n        if (useJS) {\n            librariesPending.push(this._loadLibrary(\"draco_decoder.js\", \"text\"));\n        } else {\n            librariesPending.push(this._loadLibrary(\"draco_wasm_wrapper.js\", \"text\"));\n            librariesPending.push(this._loadLibrary(\"draco_decoder.wasm\", \"arraybuffer\"));\n        }\n        this.decoderPending = Promise.all(librariesPending).then((libraries)=>{\n            const jsContent = libraries[0];\n            if (!useJS) {\n                this.decoderConfig.wasmBinary = libraries[1];\n            }\n            const fn = DRACOWorker.toString();\n            const body = [\n                \"/* draco decoder */\",\n                jsContent,\n                \"\",\n                \"/* worker */\",\n                fn.substring(fn.indexOf(\"{\") + 1, fn.lastIndexOf(\"}\"))\n            ].join(\"\\n\");\n            this.workerSourceURL = URL.createObjectURL(new Blob([\n                body\n            ]));\n        });\n        return this.decoderPending;\n    }\n    _getWorker(taskID, taskCost) {\n        return this._initDecoder().then(()=>{\n            if (this.workerPool.length < this.workerLimit) {\n                const worker2 = new Worker(this.workerSourceURL);\n                worker2._callbacks = {};\n                worker2._taskCosts = {};\n                worker2._taskLoad = 0;\n                worker2.postMessage({\n                    type: \"init\",\n                    decoderConfig: this.decoderConfig\n                });\n                worker2.onmessage = function(e) {\n                    const message = e.data;\n                    switch(message.type){\n                        case \"decode\":\n                            worker2._callbacks[message.id].resolve(message);\n                            break;\n                        case \"error\":\n                            worker2._callbacks[message.id].reject(message);\n                            break;\n                        default:\n                            console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n                    }\n                };\n                this.workerPool.push(worker2);\n            } else {\n                this.workerPool.sort(function(a, b) {\n                    return a._taskLoad > b._taskLoad ? -1 : 1;\n                });\n            }\n            const worker = this.workerPool[this.workerPool.length - 1];\n            worker._taskCosts[taskID] = taskCost;\n            worker._taskLoad += taskCost;\n            return worker;\n        });\n    }\n    _releaseTask(worker, taskID) {\n        worker._taskLoad -= worker._taskCosts[taskID];\n        delete worker._callbacks[taskID];\n        delete worker._taskCosts[taskID];\n    }\n    debug() {\n        console.log(\"Task load: \", this.workerPool.map((worker)=>worker._taskLoad));\n    }\n    dispose() {\n        for(let i = 0; i < this.workerPool.length; ++i){\n            this.workerPool[i].terminate();\n        }\n        this.workerPool.length = 0;\n        return this;\n    }\n}\nfunction DRACOWorker() {\n    let decoderConfig;\n    let decoderPending;\n    onmessage = function(e) {\n        const message = e.data;\n        switch(message.type){\n            case \"init\":\n                decoderConfig = message.decoderConfig;\n                decoderPending = new Promise(function(resolve) {\n                    decoderConfig.onModuleLoaded = function(draco) {\n                        resolve({\n                            draco\n                        });\n                    };\n                    DracoDecoderModule(decoderConfig);\n                });\n                break;\n            case \"decode\":\n                const buffer = message.buffer;\n                const taskConfig = message.taskConfig;\n                decoderPending.then((module)=>{\n                    const draco = module.draco;\n                    const decoder = new draco.Decoder();\n                    const decoderBuffer = new draco.DecoderBuffer();\n                    decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n                    try {\n                        const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n                        const buffers = geometry.attributes.map((attr)=>attr.array.buffer);\n                        if (geometry.index) buffers.push(geometry.index.array.buffer);\n                        self.postMessage({\n                            type: \"decode\",\n                            id: message.id,\n                            geometry\n                        }, buffers);\n                    } catch (error) {\n                        console.error(error);\n                        self.postMessage({\n                            type: \"error\",\n                            id: message.id,\n                            error: error.message\n                        });\n                    } finally{\n                        draco.destroy(decoderBuffer);\n                        draco.destroy(decoder);\n                    }\n                });\n                break;\n        }\n    };\n    function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n        const attributeIDs = taskConfig.attributeIDs;\n        const attributeTypes = taskConfig.attributeTypes;\n        let dracoGeometry;\n        let decodingStatus;\n        const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            dracoGeometry = new draco.Mesh();\n            decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n        } else if (geometryType === draco.POINT_CLOUD) {\n            dracoGeometry = new draco.PointCloud();\n            decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n        } else {\n            throw new Error(\"THREE.DRACOLoader: Unexpected geometry type.\");\n        }\n        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n            throw new Error(\"THREE.DRACOLoader: Decoding failed: \" + decodingStatus.error_msg());\n        }\n        const geometry = {\n            index: null,\n            attributes: []\n        };\n        for(const attributeName in attributeIDs){\n            const attributeType = self[attributeTypes[attributeName]];\n            let attribute;\n            let attributeID;\n            if (taskConfig.useUniqueIDs) {\n                attributeID = attributeIDs[attributeName];\n                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n            } else {\n                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n                if (attributeID === -1) continue;\n                attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n            }\n            geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n        }\n        if (geometryType === draco.TRIANGULAR_MESH) {\n            geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n        }\n        draco.destroy(dracoGeometry);\n        return geometry;\n    }\n    function decodeIndex(draco, decoder, dracoGeometry) {\n        const numFaces = dracoGeometry.num_faces();\n        const numIndices = numFaces * 3;\n        const byteLength = numIndices * 4;\n        const ptr = draco._malloc(byteLength);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        return {\n            array: index,\n            itemSize: 1\n        };\n    }\n    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n        const numComponents = attribute.num_components();\n        const numPoints = dracoGeometry.num_points();\n        const numValues = numPoints * numComponents;\n        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n        const dataType = getDracoDataType(draco, attributeType);\n        const ptr = draco._malloc(byteLength);\n        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n        draco._free(ptr);\n        return {\n            name: attributeName,\n            array,\n            itemSize: numComponents\n        };\n    }\n    function getDracoDataType(draco, attributeType) {\n        switch(attributeType){\n            case Float32Array:\n                return draco.DT_FLOAT32;\n            case Int8Array:\n                return draco.DT_INT8;\n            case Int16Array:\n                return draco.DT_INT16;\n            case Int32Array:\n                return draco.DT_INT32;\n            case Uint8Array:\n                return draco.DT_UINT8;\n            case Uint16Array:\n                return draco.DT_UINT16;\n            case Uint32Array:\n                return draco.DT_UINT32;\n        }\n    }\n}\n //# sourceMappingURL=DRACOLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRFJBQ09Mb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNEU7QUFDNUUsTUFBTUksYUFBYSxhQUFhLEdBQUcsSUFBSUM7QUFDdkMsTUFBTUMsb0JBQW9CTix5Q0FBTUE7SUFDOUJPLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsQ0FBQztRQUN0QixJQUFJLENBQUNDLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRyxFQUFFO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztZQUN6QkMsVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO1FBQ0EsSUFBSSxDQUFDQyxxQkFBcUIsR0FBRztZQUMzQkosVUFBVTtZQUNWQyxRQUFRO1lBQ1JDLE9BQU87WUFDUEMsSUFBSTtRQUNOO0lBQ0Y7SUFDQUUsZUFBZUMsSUFBSSxFQUFFO1FBQ25CLElBQUksQ0FBQ2YsV0FBVyxHQUFHZTtRQUNuQixPQUFPLElBQUk7SUFDYjtJQUNBQyxpQkFBaUJDLE1BQU0sRUFBRTtRQUN2QixJQUFJLENBQUNoQixhQUFhLEdBQUdnQjtRQUNyQixPQUFPLElBQUk7SUFDYjtJQUNBQyxlQUFlZCxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxXQUFXLEdBQUdBO1FBQ25CLE9BQU8sSUFBSTtJQUNiO0lBQ0FlLEtBQUtDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRTtRQUNyQyxNQUFNQyxTQUFTLElBQUloQyw2Q0FBVUEsQ0FBQyxJ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QUtDO2dCQUNILE9BQU94RCxNQUFNeUQsUUFBUTtZQUN2QixLQUFLQztnQkFDSCxPQUFPMUQsTUFBTTJELFFBQVE7WUFDdkIsS0FBS0M7Z0JBQ0gsT0FBTzVELE1BQU02RCxTQUFTO1lBQ3hCLEtBQUt0QjtnQkFDSCxPQUFPdkMsTUFBTThELFNBQVM7UUFDMUI7SUFDRjtBQUNGO0FBR0UsQ0FDRix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0RSQUNPTG9hZGVyLmpzPzc0ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBGaWxlTG9hZGVyLCBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSBcInRocmVlXCI7XG5jb25zdCBfdGFza0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBEUkFDT0xvYWRlciBleHRlbmRzIExvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLmRlY29kZXJQYXRoID0gXCJcIjtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSB7fTtcbiAgICB0aGlzLmRlY29kZXJCaW5hcnkgPSBudWxsO1xuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBudWxsO1xuICAgIHRoaXMud29ya2VyTGltaXQgPSA0O1xuICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgIHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDE7XG4gICAgdGhpcy53b3JrZXJTb3VyY2VVUkwgPSBcIlwiO1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHtcbiAgICAgIHBvc2l0aW9uOiBcIlBPU0lUSU9OXCIsXG4gICAgICBub3JtYWw6IFwiTk9STUFMXCIsXG4gICAgICBjb2xvcjogXCJDT0xPUlwiLFxuICAgICAgdXY6IFwiVEVYX0NPT1JEXCJcbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVR5cGVzID0ge1xuICAgICAgcG9zaXRpb246IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBub3JtYWw6IFwiRmxvYXQzMkFycmF5XCIsXG4gICAgICBjb2xvcjogXCJGbG9hdDMyQXJyYXlcIixcbiAgICAgIHV2OiBcIkZsb2F0MzJBcnJheVwiXG4gICAgfTtcbiAgfVxuICBzZXREZWNvZGVyUGF0aChwYXRoKSB7XG4gICAgdGhpcy5kZWNvZGVyUGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RGVjb2RlckNvbmZpZyhjb25maWcpIHtcbiAgICB0aGlzLmRlY29kZXJDb25maWcgPSBjb25maWc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0V29ya2VyTGltaXQod29ya2VyTGltaXQpIHtcbiAgICB0aGlzLndvcmtlckxpbWl0ID0gd29ya2VyTGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMubWFuYWdlcik7XG4gICAgbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgbG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICBsb2FkZXIubG9hZChcbiAgICAgIHVybCxcbiAgICAgIChidWZmZXIpID0+IHtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IHtcbiAgICAgICAgICBhdHRyaWJ1dGVJRHM6IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlczogdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICAgICAgdXNlVW5pcXVlSURzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihvbkxvYWQpLmNhdGNoKG9uRXJyb3IpO1xuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbkVycm9yXG4gICAgKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgS2VwdCBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eSB3aXRoIHByZXZpb3VzIERSQUNPTG9hZGVyIHZlcnNpb25zLiAqL1xuICBkZWNvZGVEcmFjb0ZpbGUoYnVmZmVyLCBjYWxsYmFjaywgYXR0cmlidXRlSURzLCBhdHRyaWJ1dGVUeXBlcykge1xuICAgIGNvbnN0IHRhc2tDb25maWcgPSB7XG4gICAgICBhdHRyaWJ1dGVJRHM6IGF0dHJpYnV0ZUlEcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVJRHMsXG4gICAgICBhdHRyaWJ1dGVUeXBlczogYXR0cmlidXRlVHlwZXMgfHwgdGhpcy5kZWZhdWx0QXR0cmlidXRlVHlwZXMsXG4gICAgICB1c2VVbmlxdWVJRHM6ICEhYXR0cmlidXRlSURzXG4gICAgfTtcbiAgICB0aGlzLmRlY29kZUdlb21ldHJ5KGJ1ZmZlciwgdGFza0NvbmZpZykudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgZGVjb2RlR2VvbWV0cnkoYnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgaW4gdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlcykge1xuICAgICAgY29uc3QgdHlwZSA9IHRhc2tDb25maWcuYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlXTtcbiAgICAgIGlmICh0eXBlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGFza0NvbmZpZy5hdHRyaWJ1dGVUeXBlc1thdHRyaWJ1dGVdID0gdHlwZS5uYW1lO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0YXNrS2V5ID0gSlNPTi5zdHJpbmdpZnkodGFza0NvbmZpZyk7XG4gICAgaWYgKF90YXNrQ2FjaGUuaGFzKGJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IGNhY2hlZFRhc2sgPSBfdGFza0NhY2hlLmdldChidWZmZXIpO1xuICAgICAgaWYgKGNhY2hlZFRhc2sua2V5ID09PSB0YXNrS2V5KSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRUYXNrLnByb21pc2U7XG4gICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgd29ya2VyO1xuICAgIGNvbnN0IHRhc2tJRCA9IHRoaXMud29ya2VyTmV4dFRhc2tJRCsrO1xuICAgIGNvbnN0IHRhc2tDb3N0ID0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZ2VvbWV0cnlQZW5kaW5nID0gdGhpcy5fZ2V0V29ya2VyKHRhc2tJRCwgdGFza0Nvc3QpLnRoZW4oKF93b3JrZXIpID0+IHtcbiAgICAgIHdvcmtlciA9IF93b3JrZXI7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHlwZTogXCJkZWNvZGVcIiwgaWQ6IHRhc2tJRCwgdGFza0NvbmZpZywgYnVmZmVyIH0sIFtidWZmZXJdKTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKG1lc3NhZ2UpID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KG1lc3NhZ2UuZ2VvbWV0cnkpKTtcbiAgICBnZW9tZXRyeVBlbmRpbmcuY2F0Y2goKCkgPT4gdHJ1ZSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAod29ya2VyICYmIHRhc2tJRCkge1xuICAgICAgICB0aGlzLl9yZWxlYXNlVGFzayh3b3JrZXIsIHRhc2tJRCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX3Rhc2tDYWNoZS5zZXQoYnVmZmVyLCB7XG4gICAgICBrZXk6IHRhc2tLZXksXG4gICAgICBwcm9taXNlOiBnZW9tZXRyeVBlbmRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4gZ2VvbWV0cnlQZW5kaW5nO1xuICB9XG4gIF9jcmVhdGVHZW9tZXRyeShnZW9tZXRyeURhdGEpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIGlmIChnZW9tZXRyeURhdGEuaW5kZXgpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KG5ldyBCdWZmZXJBdHRyaWJ1dGUoZ2VvbWV0cnlEYXRhLmluZGV4LmFycmF5LCAxKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2VvbWV0cnlEYXRhLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5RGF0YS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgY29uc3QgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgX2xvYWRMaWJyYXJ5KHVybCwgcmVzcG9uc2VUeXBlKSB7XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLmRlY29kZXJQYXRoKTtcbiAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKHJlc3BvbnNlVHlwZSk7XG4gICAgbG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0aGlzLndpdGhDcmVkZW50aWFscyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxvYWRlci5sb2FkKHVybCwgcmVzb2x2ZSwgdm9pZCAwLCByZWplY3QpO1xuICAgIH0pO1xuICB9XG4gIHByZWxvYWQoKSB7XG4gICAgdGhpcy5faW5pdERlY29kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfaW5pdERlY29kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGVjb2RlclBlbmRpbmcpXG4gICAgICByZXR1cm4gdGhpcy5kZWNvZGVyUGVuZGluZztcbiAgICBjb25zdCB1c2VKUyA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gXCJvYmplY3RcIiB8fCB0aGlzLmRlY29kZXJDb25maWcudHlwZSA9PT0gXCJqc1wiO1xuICAgIGNvbnN0IGxpYnJhcmllc1BlbmRpbmcgPSBbXTtcbiAgICBpZiAodXNlSlMpIHtcbiAgICAgIGxpYnJhcmllc1BlbmRpbmcucHVzaCh0aGlzLl9sb2FkTGlicmFyeShcImRyYWNvX2RlY29kZXIuanNcIiwgXCJ0ZXh0XCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlicmFyaWVzUGVuZGluZy5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KFwiZHJhY29fd2FzbV93cmFwcGVyLmpzXCIsIFwidGV4dFwiKSk7XG4gICAgICBsaWJyYXJpZXNQZW5kaW5nLnB1c2godGhpcy5fbG9hZExpYnJhcnkoXCJkcmFjb19kZWNvZGVyLndhc21cIiwgXCJhcnJheWJ1ZmZlclwiKSk7XG4gICAgfVxuICAgIHRoaXMuZGVjb2RlclBlbmRpbmcgPSBQcm9taXNlLmFsbChsaWJyYXJpZXNQZW5kaW5nKS50aGVuKChsaWJyYXJpZXMpID0+IHtcbiAgICAgIGNvbnN0IGpzQ29udGVudCA9IGxpYnJhcmllc1swXTtcbiAgICAgIGlmICghdXNlSlMpIHtcbiAgICAgICAgdGhpcy5kZWNvZGVyQ29uZmlnLndhc21CaW5hcnkgPSBsaWJyYXJpZXNbMV07XG4gICAgICB9XG4gICAgICBjb25zdCBmbiA9IERSQUNPV29ya2VyLnRvU3RyaW5nKCk7XG4gICAgICBjb25zdCBib2R5ID0gW1xuICAgICAgICBcIi8qIGRyYWNvIGRlY29kZXIgKi9cIixcbiAgICAgICAganNDb250ZW50LFxuICAgICAgICBcIlwiLFxuICAgICAgICBcIi8qIHdvcmtlciAqL1wiLFxuICAgICAgICBmbi5zdWJzdHJpbmcoZm4uaW5kZXhPZihcIntcIikgKyAxLCBmbi5sYXN0SW5kZXhPZihcIn1cIikpXG4gICAgICBdLmpvaW4oXCJcXG5cIik7XG4gICAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2JvZHldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlclBlbmRpbmc7XG4gIH1cbiAgX2dldFdvcmtlcih0YXNrSUQsIHRhc2tDb3N0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXREZWNvZGVyKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAodGhpcy53b3JrZXJQb29sLmxlbmd0aCA8IHRoaXMud29ya2VyTGltaXQpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyMiA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJTb3VyY2VVUkwpO1xuICAgICAgICB3b3JrZXIyLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgd29ya2VyMi5fdGFza0Nvc3RzID0ge307XG4gICAgICAgIHdvcmtlcjIuX3Rhc2tMb2FkID0gMDtcbiAgICAgICAgd29ya2VyMi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiaW5pdFwiLCBkZWNvZGVyQ29uZmlnOiB0aGlzLmRlY29kZXJDb25maWcgfSk7XG4gICAgICAgIHdvcmtlcjIub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlLmRhdGE7XG4gICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkZWNvZGVcIjpcbiAgICAgICAgICAgICAgd29ya2VyMi5fY2FsbGJhY2tzW21lc3NhZ2UuaWRdLnJlc29sdmUobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIHdvcmtlcjIuX2NhbGxiYWNrc1ttZXNzYWdlLmlkXS5yZWplY3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgXCInICsgbWVzc2FnZS50eXBlICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclBvb2wucHVzaCh3b3JrZXIyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYS5fdGFza0xvYWQgPiBiLl90YXNrTG9hZCA/IC0xIDogMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLndvcmtlclBvb2xbdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDFdO1xuICAgICAgd29ya2VyLl90YXNrQ29zdHNbdGFza0lEXSA9IHRhc2tDb3N0O1xuICAgICAgd29ya2VyLl90YXNrTG9hZCArPSB0YXNrQ29zdDtcbiAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfSk7XG4gIH1cbiAgX3JlbGVhc2VUYXNrKHdvcmtlciwgdGFza0lEKSB7XG4gICAgd29ya2VyLl90YXNrTG9hZCAtPSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX2NhbGxiYWNrc1t0YXNrSURdO1xuICAgIGRlbGV0ZSB3b3JrZXIuX3Rhc2tDb3N0c1t0YXNrSURdO1xuICB9XG4gIGRlYnVnKCkge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJUYXNrIGxvYWQ6IFwiLFxuICAgICAgdGhpcy53b3JrZXJQb29sLm1hcCgod29ya2VyKSA9PiB3b3JrZXIuX3Rhc2tMb2FkKVxuICAgICk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud29ya2VyUG9vbC5sZW5ndGg7ICsraSkge1xuICAgICAgdGhpcy53b3JrZXJQb29sW2ldLnRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLndvcmtlclBvb2wubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gRFJBQ09Xb3JrZXIoKSB7XG4gIGxldCBkZWNvZGVyQ29uZmlnO1xuICBsZXQgZGVjb2RlclBlbmRpbmc7XG4gIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZS5kYXRhO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICBkZWNvZGVyQ29uZmlnID0gbWVzc2FnZS5kZWNvZGVyQ29uZmlnO1xuICAgICAgICBkZWNvZGVyUGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICBkZWNvZGVyQ29uZmlnLm9uTW9kdWxlTG9hZGVkID0gZnVuY3Rpb24oZHJhY28pIHtcbiAgICAgICAgICAgIHJlc29sdmUoeyBkcmFjbyB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIERyYWNvRGVjb2Rlck1vZHVsZShkZWNvZGVyQ29uZmlnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRlY29kZVwiOlxuICAgICAgICBjb25zdCBidWZmZXIgPSBtZXNzYWdlLmJ1ZmZlcjtcbiAgICAgICAgY29uc3QgdGFza0NvbmZpZyA9IG1lc3NhZ2UudGFza0NvbmZpZztcbiAgICAgICAgZGVjb2RlclBlbmRpbmcudGhlbigobW9kdWxlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZHJhY28gPSBtb2R1bGUuZHJhY287XG4gICAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBkcmFjby5EZWNvZGVyKCk7XG4gICAgICAgICAgY29uc3QgZGVjb2RlckJ1ZmZlciA9IG5ldyBkcmFjby5EZWNvZGVyQnVmZmVyKCk7XG4gICAgICAgICAgZGVjb2RlckJ1ZmZlci5Jbml0KG5ldyBJbnQ4QXJyYXkoYnVmZmVyKSwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm1hcCgoYXR0cikgPT4gYXR0ci5hcnJheS5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4KVxuICAgICAgICAgICAgICBidWZmZXJzLnB1c2goZ2VvbWV0cnkuaW5kZXguYXJyYXkuYnVmZmVyKTtcbiAgICAgICAgICAgIHNlbGYucG9zdE1lc3NhZ2UoeyB0eXBlOiBcImRlY29kZVwiLCBpZDogbWVzc2FnZS5pZCwgZ2VvbWV0cnkgfSwgYnVmZmVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHR5cGU6IFwiZXJyb3JcIiwgaWQ6IG1lc3NhZ2UuaWQsIGVycm9yOiBlcnJvci5tZXNzYWdlIH0pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBkcmFjby5kZXN0cm95KGRlY29kZXJCdWZmZXIpO1xuICAgICAgICAgICAgZHJhY28uZGVzdHJveShkZWNvZGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGRlY29kZUdlb21ldHJ5KGRyYWNvLCBkZWNvZGVyLCBkZWNvZGVyQnVmZmVyLCB0YXNrQ29uZmlnKSB7XG4gICAgY29uc3QgYXR0cmlidXRlSURzID0gdGFza0NvbmZpZy5hdHRyaWJ1dGVJRHM7XG4gICAgY29uc3QgYXR0cmlidXRlVHlwZXMgPSB0YXNrQ29uZmlnLmF0dHJpYnV0ZVR5cGVzO1xuICAgIGxldCBkcmFjb0dlb21ldHJ5O1xuICAgIGxldCBkZWNvZGluZ1N0YXR1cztcbiAgICBjb25zdCBnZW9tZXRyeVR5cGUgPSBkZWNvZGVyLkdldEVuY29kZWRHZW9tZXRyeVR5cGUoZGVjb2RlckJ1ZmZlcik7XG4gICAgaWYgKGdlb21ldHJ5VHlwZSA9PT0gZHJhY28uVFJJQU5HVUxBUl9NRVNIKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLk1lc2goKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb01lc2goZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlBPSU5UX0NMT1VEKSB7XG4gICAgICBkcmFjb0dlb21ldHJ5ID0gbmV3IGRyYWNvLlBvaW50Q2xvdWQoKTtcbiAgICAgIGRlY29kaW5nU3RhdHVzID0gZGVjb2Rlci5EZWNvZGVCdWZmZXJUb1BvaW50Q2xvdWQoZGVjb2RlckJ1ZmZlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmV4cGVjdGVkIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH1cbiAgICBpZiAoIWRlY29kaW5nU3RhdHVzLm9rKCkgfHwgZHJhY29HZW9tZXRyeS5wdHIgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkRSQUNPTG9hZGVyOiBEZWNvZGluZyBmYWlsZWQ6IFwiICsgZGVjb2RpbmdTdGF0dXMuZXJyb3JfbXNnKCkpO1xuICAgIH1cbiAgICBjb25zdCBnZW9tZXRyeSA9IHsgaW5kZXg6IG51bGwsIGF0dHJpYnV0ZXM6IFtdIH07XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZUlEcykge1xuICAgICAgY29uc3QgYXR0cmlidXRlVHlwZSA9IHNlbGZbYXR0cmlidXRlVHlwZXNbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgbGV0IGF0dHJpYnV0ZTtcbiAgICAgIGxldCBhdHRyaWJ1dGVJRDtcbiAgICAgIGlmICh0YXNrQ29uZmlnLnVzZVVuaXF1ZUlEcykge1xuICAgICAgICBhdHRyaWJ1dGVJRCA9IGF0dHJpYnV0ZUlEc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKGRyYWNvR2VvbWV0cnksIGF0dHJpYnV0ZUlEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZUlEID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGVJZChkcmFjb0dlb21ldHJ5LCBkcmFjb1thdHRyaWJ1dGVJRHNbYXR0cmlidXRlTmFtZV1dKTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZUlEID09PSAtMSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXR0cmlidXRlID0gZGVjb2Rlci5HZXRBdHRyaWJ1dGUoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlSUQpO1xuICAgICAgfVxuICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlcy5wdXNoKGRlY29kZUF0dHJpYnV0ZShkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlKSk7XG4gICAgfVxuICAgIGlmIChnZW9tZXRyeVR5cGUgPT09IGRyYWNvLlRSSUFOR1VMQVJfTUVTSCkge1xuICAgICAgZ2VvbWV0cnkuaW5kZXggPSBkZWNvZGVJbmRleChkcmFjbywgZGVjb2RlciwgZHJhY29HZW9tZXRyeSk7XG4gICAgfVxuICAgIGRyYWNvLmRlc3Ryb3koZHJhY29HZW9tZXRyeSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG4gIGZ1bmN0aW9uIGRlY29kZUluZGV4KGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5KSB7XG4gICAgY29uc3QgbnVtRmFjZXMgPSBkcmFjb0dlb21ldHJ5Lm51bV9mYWNlcygpO1xuICAgIGNvbnN0IG51bUluZGljZXMgPSBudW1GYWNlcyAqIDM7XG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IG51bUluZGljZXMgKiA0O1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShkcmFjb0dlb21ldHJ5LCBieXRlTGVuZ3RoLCBwdHIpO1xuICAgIGNvbnN0IGluZGV4ID0gbmV3IFVpbnQzMkFycmF5KGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bUluZGljZXMpLnNsaWNlKCk7XG4gICAgZHJhY28uX2ZyZWUocHRyKTtcbiAgICByZXR1cm4geyBhcnJheTogaW5kZXgsIGl0ZW1TaXplOiAxIH07XG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlQXR0cmlidXRlKGRyYWNvLCBkZWNvZGVyLCBkcmFjb0dlb21ldHJ5LCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGUpIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gYXR0cmlidXRlLm51bV9jb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gZHJhY29HZW9tZXRyeS5udW1fcG9pbnRzKCk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gbnVtUG9pbnRzICogbnVtQ29tcG9uZW50cztcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gbnVtVmFsdWVzICogYXR0cmlidXRlVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBjb25zdCBkYXRhVHlwZSA9IGdldERyYWNvRGF0YVR5cGUoZHJhY28sIGF0dHJpYnV0ZVR5cGUpO1xuICAgIGNvbnN0IHB0ciA9IGRyYWNvLl9tYWxsb2MoYnl0ZUxlbmd0aCk7XG4gICAgZGVjb2Rlci5HZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMoZHJhY29HZW9tZXRyeSwgYXR0cmlidXRlLCBkYXRhVHlwZSwgYnl0ZUxlbmd0aCwgcHRyKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBhdHRyaWJ1dGVUeXBlKGRyYWNvLkhFQVBGMzIuYnVmZmVyLCBwdHIsIG51bVZhbHVlcykuc2xpY2UoKTtcbiAgICBkcmFjby5fZnJlZShwdHIpO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBhdHRyaWJ1dGVOYW1lLFxuICAgICAgYXJyYXksXG4gICAgICBpdGVtU2l6ZTogbnVtQ29tcG9uZW50c1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RHJhY29EYXRhVHlwZShkcmFjbywgYXR0cmlidXRlVHlwZSkge1xuICAgIHN3aXRjaCAoYXR0cmlidXRlVHlwZSkge1xuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9GTE9BVDMyO1xuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQ4O1xuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgICByZXR1cm4gZHJhY28uRFRfSU5UMTY7XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9JTlQzMjtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQ4O1xuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgICAgcmV0dXJuIGRyYWNvLkRUX1VJTlQxNjtcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICAgIHJldHVybiBkcmFjby5EVF9VSU5UMzI7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBEUkFDT0xvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURSQUNPTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkxvYWRlciIsIkZpbGVMb2FkZXIiLCJCdWZmZXJHZW9tZXRyeSIsIkJ1ZmZlckF0dHJpYnV0ZSIsIl90YXNrQ2FjaGUiLCJXZWFrTWFwIiwiRFJBQ09Mb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJkZWNvZGVyUGF0aCIsImRlY29kZXJDb25maWciLCJkZWNvZGVyQmluYXJ5IiwiZGVjb2RlclBlbmRpbmciLCJ3b3JrZXJMaW1pdCIsIndvcmtlclBvb2wiLCJ3b3JrZXJOZXh0VGFza0lEIiwid29ya2VyU291cmNlVVJMIiwiZGVmYXVsdEF0dHJpYnV0ZUlEcyIsInBvc2l0aW9uIiwibm9ybWFsIiwiY29sb3IiLCJ1diIsImRlZmF1bHRBdHRyaWJ1dGVUeXBlcyIsInNldERlY29kZXJQYXRoIiwicGF0aCIsInNldERlY29kZXJDb25maWciLCJjb25maWciLCJzZXRXb3JrZXJMaW1pdCIsImxvYWQiLCJ1cmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsImxvYWRlciIsInNldFBhdGgiLCJzZXRSZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVxdWVzdEhlYWRlciIsInNldFdpdGhDcmVkZW50aWFscyIsIndpdGhDcmVkZW50aWFscyIsImJ1ZmZlciIsInRhc2tDb25maWciLCJhdHRyaWJ1dGVJRHMiLCJhdHRyaWJ1dGVUeXBlcyIsInVzZVVuaXF1ZUlEcyIsImRlY29kZUdlb21ldHJ5IiwidGhlbiIsImNhdGNoIiwiZGVjb2RlRHJhY29GaWxlIiwiY2FsbGJhY2siLCJhdHRyaWJ1dGUiLCJ0eXBlIiwiQllURVNfUEVSX0VMRU1FTlQiLCJuYW1lIiwidGFza0tleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYXMiLCJjYWNoZWRUYXNrIiwiZ2V0Iiwia2V5IiwicHJvbWlzZSIsImJ5dGVMZW5ndGgiLCJFcnJvciIsIndvcmtlciIsInRhc2tJRCIsInRhc2tDb3N0IiwiZ2VvbWV0cnlQZW5kaW5nIiwiX2dldFdvcmtlciIsIl93b3JrZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIl9jYWxsYmFja3MiLCJwb3N0TWVzc2FnZSIsImlkIiwibWVzc2FnZSIsIl9jcmVhdGVHZW9tZXRyeSIsImdlb21ldHJ5IiwiX3JlbGVhc2VUYXNrIiwic2V0IiwiZ2VvbWV0cnlEYXRhIiwiaW5kZXgiLCJzZXRJbmRleCIsImFycmF5IiwiaSIsImF0dHJpYnV0ZXMiLCJsZW5ndGgiLCJpdGVtU2l6ZSIsInNldEF0dHJpYnV0ZSIsIl9sb2FkTGlicmFyeSIsInJlc3BvbnNlVHlwZSIsInByZWxvYWQiLCJfaW5pdERlY29kZXIiLCJ1c2VKUyIsIldlYkFzc2VtYmx5IiwibGlicmFyaWVzUGVuZGluZyIsInB1c2giLCJhbGwiLCJsaWJyYXJpZXMiLCJqc0NvbnRlbnQiLCJ3YXNtQmluYXJ5IiwiZm4iLCJEUkFDT1dvcmtlciIsInRvU3RyaW5nIiwiYm9keSIsInN1YnN0cmluZyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImpvaW4iLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJCbG9iIiwid29ya2VyMiIsIldvcmtlciIsIl90YXNrQ29zdHMiLCJfdGFza0xvYWQiLCJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsImNvbnNvbGUiLCJlcnJvciIsInNvcnQiLCJhIiwiYiIsImRlYnVnIiwibG9nIiwibWFwIiwiZGlzcG9zZSIsInRlcm1pbmF0ZSIsIm9uTW9kdWxlTG9hZGVkIiwiZHJhY28iLCJEcmFjb0RlY29kZXJNb2R1bGUiLCJtb2R1bGUiLCJkZWNvZGVyIiwiRGVjb2RlciIsImRlY29kZXJCdWZmZXIiLCJEZWNvZGVyQnVmZmVyIiwiSW5pdCIsIkludDhBcnJheSIsImJ1ZmZlcnMiLCJhdHRyIiwic2VsZiIsImRlc3Ryb3kiLCJkcmFjb0dlb21ldHJ5IiwiZGVjb2RpbmdTdGF0dXMiLCJnZW9tZXRyeVR5cGUiLCJHZXRFbmNvZGVkR2VvbWV0cnlUeXBlIiwiVFJJQU5HVUxBUl9NRVNIIiwiTWVzaCIsIkRlY29kZUJ1ZmZlclRvTWVzaCIsIlBPSU5UX0NMT1VEIiwiUG9pbnRDbG91ZCIsIkRlY29kZUJ1ZmZlclRvUG9pbnRDbG91ZCIsIm9rIiwicHRyIiwiZXJyb3JfbXNnIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVJRCIsIkdldEF0dHJpYnV0ZUJ5VW5pcXVlSWQiLCJHZXRBdHRyaWJ1dGVJZCIsIkdldEF0dHJpYnV0ZSIsImRlY29kZUF0dHJpYnV0ZSIsImRlY29kZUluZGV4IiwibnVtRmFjZXMiLCJudW1fZmFjZXMiLCJudW1JbmRpY2VzIiwiX21hbGxvYyIsIkdldFRyaWFuZ2xlc1VJbnQzMkFycmF5IiwiVWludDMyQXJyYXkiLCJIRUFQRjMyIiwic2xpY2UiLCJfZnJlZSIsIm51bUNvbXBvbmVudHMiLCJudW1fY29tcG9uZW50cyIsIm51bVBvaW50cyIsIm51bV9wb2ludHMiLCJudW1WYWx1ZXMiLCJkYXRhVHlwZSIsImdldERyYWNvRGF0YVR5cGUiLCJHZXRBdHRyaWJ1dGVEYXRhQXJyYXlGb3JBbGxQb2ludHMiLCJGbG9hdDMyQXJyYXkiLCJEVF9GTE9BVDMyIiwiRFRfSU5UOCIsIkludDE2QXJyYXkiLCJEVF9JTlQxNiIsIkludDMyQXJyYXkiLCJEVF9JTlQzMiIsIlVpbnQ4QXJyYXkiLCJEVF9VSU5UOCIsIlVpbnQxNkFycmF5IiwiRFRfVUlOVDE2IiwiRFRfVUlOVDMyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nconst hasColorSpace = _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__.version >= 152;\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_1__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType;\n    }\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0g7QUFDaEY7QUFDZ0I7QUFDcEQsTUFBTVMsZ0JBQWdCRCwyREFBT0EsSUFBSTtBQUNqQyxNQUFNRSxrQkFBa0JWLG9EQUFpQkE7SUFDdkNXLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdaLGdEQUFhQTtJQUMzQjtJQUNBYSxNQUFNQyxNQUFNLEVBQUU7UUFDWixNQUFNQyxlQUFlLEtBQUs7UUFDMUIsTUFBTUMsY0FBY0QsZ0JBQWdCO1FBQ3BDLE1BQU1FLGNBQWM7UUFDcEIsTUFBTUMsY0FBYztRQUNwQixNQUFNQyxjQUFjLENBQUMsS0FBS0YsV0FBVSxJQUFLO1FBQ3pDLE1BQU1HLGNBQWMsS0FBS0Y7UUFDekIsTUFBTUcsY0FBY0QsY0FBYztRQUNsQyxNQUFNRSxRQUFRO1FBQ2QsTUFBTUMsV0FBVyxLQUFLRCxRQUFRO1FBQzlCLE1BQU1FLFdBQVcsQ0FBQyxLQUFLRixLQUFJLElBQUs7UUFDaEMsTUFBTUcscUJBQXFCO1FBQzNCLE1BQU1DLG9CQUFvQjtRQUMxQixNQUFNQyxvQkFBb0IsSUFBSUQsb0JBQW9CRDtRQUNsRCxNQUFNRyxhQUFhO1FBQ25CLE1BQU1DLGVBQWU7UUFDckIsTUFBTUMsYUFBYTtRQUNuQixNQUFNQyxhQUFhO1FBQ25CLE1BQU1DLFlBQVk7UUFDbEIsTUFBTUMsaUJBQWlCO1FBQ3ZCLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsVUFBVTtRQUNoQixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLE1BQU07UUFDWixNQUFNQyxVQUFVQyxLQUFLQyxHQUFHLENBQUMsV0FBVztRQUNwQyxTQUFTQyxxQkFBcUJDLE1BQU0sRUFBRUMsR0FBRztZQUN2QyxJQUFJQyxJQUFJO1lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUk5QixjQUFjLEVBQUU4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R0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsRUFBRTtZQUM5QmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEVBQUU7WUFDOUJjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxFQUFFO1lBQzlCYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdB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UUFBUUcsU0FBUyxHQUFHcGEsK0NBQVlBO1lBQ2hDaWEsUUFBUUksZUFBZSxHQUFHO1lBQzFCSixRQUFRSyxLQUFLLEdBQUc7WUFDaEIsSUFBSVQsUUFDRkEsT0FBT0ksU0FBU0M7UUFDcEI7UUFDQSxPQUFPLEtBQUssQ0FBQ1AsS0FBS0MsS0FBS0ksZ0JBQWdCRixZQUFZQztJQUNyRDtBQUNGO0FBR0UsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL0VYUkxvYWRlci5qcz83ZTQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERhdGFUZXh0dXJlTG9hZGVyLCBIYWxmRmxvYXRUeXBlLCBGbG9hdFR5cGUsIFJHQkFGb3JtYXQsIFJlZEZvcm1hdCwgTGluZWFyRmlsdGVyLCBEYXRhVXRpbHMgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHVuemxpYlN5bmMgfSBmcm9tIFwiZmZsYXRlXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL19wb2x5ZmlsbC9jb25zdGFudHMuanNcIjtcbmNvbnN0IGhhc0NvbG9yU3BhY2UgPSB2ZXJzaW9uID49IDE1MjtcbmNsYXNzIEVYUkxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgVVNIT1JUX1JBTkdFID0gMSA8PCAxNjtcbiAgICBjb25zdCBCSVRNQVBfU0laRSA9IFVTSE9SVF9SQU5HRSA+PiAzO1xuICAgIGNvbnN0IEhVRl9FTkNCSVRTID0gMTY7XG4gICAgY29uc3QgSFVGX0RFQ0JJVFMgPSAxNDtcbiAgICBjb25zdCBIVUZfRU5DU0laRSA9ICgxIDw8IEhVRl9FTkNCSVRTKSArIDE7XG4gICAgY29uc3QgSFVGX0RFQ1NJWkUgPSAxIDw8IEhVRl9ERUNCSVRTO1xuICAgIGNvbnN0IEhVRl9ERUNNQVNLID0gSFVGX0RFQ1NJWkUgLSAxO1xuICAgIGNvbnN0IE5CSVRTID0gMTY7XG4gICAgY29uc3QgQV9PRkZTRVQgPSAxIDw8IE5CSVRTIC0gMTtcbiAgICBjb25zdCBNT0RfTUFTSyA9ICgxIDw8IE5CSVRTKSAtIDE7XG4gICAgY29uc3QgU0hPUlRfWkVST0NPREVfUlVOID0gNTk7XG4gICAgY29uc3QgTE9OR19aRVJPQ09ERV9SVU4gPSA2MztcbiAgICBjb25zdCBTSE9SVEVTVF9MT05HX1JVTiA9IDIgKyBMT05HX1pFUk9DT0RFX1JVTiAtIFNIT1JUX1pFUk9DT0RFX1JVTjtcbiAgICBjb25zdCBVTE9OR19TSVpFID0gODtcbiAgICBjb25zdCBGTE9BVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDMyX1NJWkUgPSA0O1xuICAgIGNvbnN0IElOVDE2X1NJWkUgPSAyO1xuICAgIGNvbnN0IElOVDhfU0laRSA9IDE7XG4gICAgY29uc3QgU1RBVElDX0hVRkZNQU4gPSAwO1xuICAgIGNvbnN0IERFRkxBVEUgPSAxO1xuICAgIGNvbnN0IFVOS05PV04gPSAwO1xuICAgIGNvbnN0IExPU1NZX0RDVCA9IDE7XG4gICAgY29uc3QgUkxFID0gMjtcbiAgICBjb25zdCBsb2dCYXNlID0gTWF0aC5wb3coMi43MTgyODE4LCAyLjIpO1xuICAgIGZ1bmN0aW9uIHJldmVyc2VMdXRGcm9tQml0bWFwKGJpdG1hcCwgbHV0KSB7XG4gICAgICB2YXIgayA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFVTSE9SVF9SQU5HRTsgKytpKSB7XG4gICAgICAgIGlmIChpID09IDAgfHwgYml0bWFwW2kgPj4gM10gJiAxIDw8IChpICYgNykpIHtcbiAgICAgICAgICBsdXRbaysrXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuID0gayAtIDE7XG4gICAgICB3aGlsZSAoayA8IFVTSE9SVF9SQU5HRSlcbiAgICAgICAgbHV0W2srK10gPSAwO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkNsZWFyRGVjVGFibGUoaGRlYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfREVDU0laRTsgaSsrKSB7XG4gICAgICAgIGhkZWNbaV0gPSB7fTtcbiAgICAgICAgaGRlY1tpXS5sZW4gPSAwO1xuICAgICAgICBoZGVjW2ldLmxpdCA9IDA7XG4gICAgICAgIGhkZWNbaV0ucCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdldEJpdHNSZXR1cm4gPSB7IGw6IDAsIGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Qml0cyhuQml0cywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCkge1xuICAgICAgd2hpbGUgKGxjIDwgbkJpdHMpIHtcbiAgICAgICAgYyA9IGMgPDwgOCB8IHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBsYyArPSA4O1xuICAgICAgfVxuICAgICAgbGMgLT0gbkJpdHM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmwgPSBjID4+IGxjICYgKDEgPDwgbkJpdHMpIC0gMTtcbiAgICAgIGdldEJpdHNSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRCaXRzUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGNvbnN0IGh1ZlRhYmxlQnVmZmVyID0gbmV3IEFycmF5KDU5KTtcbiAgICBmdW5jdGlvbiBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IDU4OyArK2kpXG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgSFVGX0VOQ1NJWkU7ICsraSlcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaGNvZGVbaV1dICs9IDE7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gNTg7IGkgPiAwOyAtLWkpIHtcbiAgICAgICAgdmFyIG5jID0gYyArIGh1ZlRhYmxlQnVmZmVyW2ldID4+IDE7XG4gICAgICAgIGh1ZlRhYmxlQnVmZmVyW2ldID0gYztcbiAgICAgICAgYyA9IG5jO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfRU5DU0laRTsgKytpKSB7XG4gICAgICAgIHZhciBsID0gaGNvZGVbaV07XG4gICAgICAgIGlmIChsID4gMClcbiAgICAgICAgICBoY29kZVtpXSA9IGwgfCBodWZUYWJsZUJ1ZmZlcltsXSsrIDw8IDY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZlVucGFja0VuY1RhYmxlKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIGltLCBpTSwgaGNvZGUpIHtcbiAgICAgIHZhciBwID0gaW5PZmZzZXQ7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIGlmIChwLnZhbHVlIC0gaW5PZmZzZXQudmFsdWUgPiBuaSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGdldEJpdHMoNiwgYywgbGMsIHVJbnQ4QXJyYXkyLCBwKTtcbiAgICAgICAgdmFyIGwgPSBnZXRCaXRzUmV0dXJuLmw7XG4gICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgIGxjID0gZ2V0Qml0c1JldHVybi5sYztcbiAgICAgICAgaGNvZGVbaW1dID0gbDtcbiAgICAgICAgaWYgKGwgPT0gTE9OR19aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICBpZiAocC52YWx1ZSAtIGluT2Zmc2V0LnZhbHVlID4gbmkpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ2V0Qml0cyg4LCBjLCBsYywgdUludDhBcnJheTIsIHApO1xuICAgICAgICAgIHZhciB6ZXJ1biA9IGdldEJpdHNSZXR1cm4ubCArIFNIT1JURVNUX0xPTkdfUlVOO1xuICAgICAgICAgIGMgPSBnZXRCaXRzUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRCaXRzUmV0dXJuLmxjO1xuICAgICAgICAgIGlmIChpbSArIHplcnVuID4gaU0gKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh6ZXJ1bi0tKVxuICAgICAgICAgICAgaGNvZGVbaW0rK10gPSAwO1xuICAgICAgICAgIGltLS07XG4gICAgICAgIH0gZWxzZSBpZiAobCA+PSBTSE9SVF9aRVJPQ09ERV9SVU4pIHtcbiAgICAgICAgICB2YXIgemVydW4gPSBsIC0gU0hPUlRfWkVST0NPREVfUlVOICsgMjtcbiAgICAgICAgICBpZiAoaW0gKyB6ZXJ1biA+IGlNICsgMSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoemVydW4tLSlcbiAgICAgICAgICAgIGhjb2RlW2ltKytdID0gMDtcbiAgICAgICAgICBpbS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBodWZDYW5vbmljYWxDb2RlVGFibGUoaGNvZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZMZW5ndGgoY29kZSkge1xuICAgICAgcmV0dXJuIGNvZGUgJiA2MztcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQ29kZShjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSA+PiA2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZCdWlsZERlY1RhYmxlKGhjb2RlLCBpbSwgaU0sIGhkZWNvZCkge1xuICAgICAgZm9yICg7IGltIDw9IGlNOyBpbSsrKSB7XG4gICAgICAgIHZhciBjID0gaHVmQ29kZShoY29kZVtpbV0pO1xuICAgICAgICB2YXIgbCA9IGh1Zkxlbmd0aChoY29kZVtpbV0pO1xuICAgICAgICBpZiAoYyA+PiBsKSB7XG4gICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwgPiBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBwbCA9IGhkZWNvZFtjID4+IGwgLSBIVUZfREVDQklUU107XG4gICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBsLmxpdCsrO1xuICAgICAgICAgIGlmIChwbC5wKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBsLnA7XG4gICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KHBsLmxpdCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsLmxpdCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICBwbC5wW2ldID0gcFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGwucCA9IG5ldyBBcnJheSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGwucFtwbC5saXQgLSAxXSA9IGltO1xuICAgICAgICB9IGVsc2UgaWYgKGwpIHtcbiAgICAgICAgICB2YXIgcGxPZmZzZXQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxIDw8IEhVRl9ERUNCSVRTIC0gbDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHBsID0gaGRlY29kWyhjIDw8IEhVRl9ERUNCSVRTIC0gbCkgKyBwbE9mZnNldF07XG4gICAgICAgICAgICBpZiAocGwubGVuIHx8IHBsLnApIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhYmxlIGVudHJ5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbC5sZW4gPSBsO1xuICAgICAgICAgICAgcGwubGl0ID0gaW07XG4gICAgICAgICAgICBwbE9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGdldENoYXJSZXR1cm4gPSB7IGM6IDAsIGxjOiAwIH07XG4gICAgZnVuY3Rpb24gZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KSB7XG4gICAgICBjID0gYyA8PCA4IHwgcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICBsYyArPSA4O1xuICAgICAgZ2V0Q2hhclJldHVybi5jID0gYztcbiAgICAgIGdldENoYXJSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgY29uc3QgZ2V0Q29kZVJldHVybiA9IHsgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRDb2RlKHBvLCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyT2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgIGlmIChwbyA9PSBybGMpIHtcbiAgICAgICAgaWYgKGxjIDwgOCkge1xuICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIH1cbiAgICAgICAgbGMgLT0gODtcbiAgICAgICAgdmFyIGNzID0gYyA+PiBsYztcbiAgICAgICAgdmFyIGNzID0gbmV3IFVpbnQ4QXJyYXkoW2NzXSlbMF07XG4gICAgICAgIGlmIChvdXRCdWZmZXJPZmZzZXQudmFsdWUgKyBjcyA+IG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcyA9IG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUgLSAxXTtcbiAgICAgICAgd2hpbGUgKGNzLS0gPiAwKSB7XG4gICAgICAgICAgb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSsrXSA9IHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3V0QnVmZmVyT2Zmc2V0LnZhbHVlIDwgb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICAgIG91dEJ1ZmZlcltvdXRCdWZmZXJPZmZzZXQudmFsdWUrK10gPSBwbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGdldENvZGVSZXR1cm4uYyA9IGM7XG4gICAgICBnZXRDb2RlUmV0dXJuLmxjID0gbGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVJbnQxNih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYgNjU1MzU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEludDE2KHZhbHVlKSB7XG4gICAgICB2YXIgcmVmID0gVUludDE2KHZhbHVlKTtcbiAgICAgIHJldHVybiByZWYgPiAzMjc2NyA/IHJlZiAtIDY1NTM2IDogcmVmO1xuICAgIH1cbiAgICBjb25zdCB3ZGVjMTRSZXR1cm4gPSB7IGE6IDAsIGI6IDAgfTtcbiAgICBmdW5jdGlvbiB3ZGVjMTQobCwgaCkge1xuICAgICAgdmFyIGxzID0gSW50MTYobCk7XG4gICAgICB2YXIgaHMgPSBJbnQxNihoKTtcbiAgICAgIHZhciBoaSA9IGhzO1xuICAgICAgdmFyIGFpID0gbHMgKyAoaGkgJiAxKSArIChoaSA+PiAxKTtcbiAgICAgIHZhciBhcyA9IGFpO1xuICAgICAgdmFyIGJzID0gYWkgLSBoaTtcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYXM7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3ZGVjMTYobCwgaCkge1xuICAgICAgdmFyIG0gPSBVSW50MTYobCk7XG4gICAgICB2YXIgZCA9IFVJbnQxNihoKTtcbiAgICAgIHZhciBiYiA9IG0gLSAoZCA+PiAxKSAmIE1PRF9NQVNLO1xuICAgICAgdmFyIGFhID0gZCArIGJiIC0gQV9PRkZTRVQgJiBNT0RfTUFTSztcbiAgICAgIHdkZWMxNFJldHVybi5hID0gYWE7XG4gICAgICB3ZGVjMTRSZXR1cm4uYiA9IGJiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3YXYyRGVjb2RlKGJ1ZmZlcjIsIGosIG54LCBveCwgbnksIG95LCBteCkge1xuICAgICAgdmFyIHcxNCA9IG14IDwgMSA8PCAxNDtcbiAgICAgIHZhciBuID0gbnggPiBueSA/IG55IDogbng7XG4gICAgICB2YXIgcCA9IDE7XG4gICAgICB2YXIgcDI7XG4gICAgICB3aGlsZSAocCA8PSBuKVxuICAgICAgICBwIDw8PSAxO1xuICAgICAgcCA+Pj0gMTtcbiAgICAgIHAyID0gcDtcbiAgICAgIHAgPj49IDE7XG4gICAgICB3aGlsZSAocCA+PSAxKSB7XG4gICAgICAgIHZhciBweSA9IDA7XG4gICAgICAgIHZhciBleSA9IHB5ICsgb3kgKiAobnkgLSBwMik7XG4gICAgICAgIHZhciBveTEgPSBveSAqIHA7XG4gICAgICAgIHZhciBveTIgPSBveSAqIHAyO1xuICAgICAgICB2YXIgb3gxID0gb3ggKiBwO1xuICAgICAgICB2YXIgb3gyID0gb3ggKiBwMjtcbiAgICAgICAgdmFyIGkwMCwgaTAxLCBpMTAsIGkxMTtcbiAgICAgICAgZm9yICg7IHB5IDw9IGV5OyBweSArPSBveTIpIHtcbiAgICAgICAgICB2YXIgcHggPSBweTtcbiAgICAgICAgICB2YXIgZXggPSBweSArIG94ICogKG54IC0gcDIpO1xuICAgICAgICAgIGZvciAoOyBweCA8PSBleDsgcHggKz0gb3gyKSB7XG4gICAgICAgICAgICB2YXIgcDAxID0gcHggKyBveDE7XG4gICAgICAgICAgICB2YXIgcDEwID0gcHggKyBveTE7XG4gICAgICAgICAgICB2YXIgcDExID0gcDEwICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNCkge1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE0KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMCA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltwMDEgKyBqXSwgYnVmZmVyMltwMTEgKyBqXSk7XG4gICAgICAgICAgICAgIGkwMSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBpMTEgPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkwMCwgaTAxKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgICAgd2RlYzE2KGkxMCwgaTExKTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChueCAmIHApIHtcbiAgICAgICAgICAgIHZhciBwMTAgPSBweCArIG95MTtcbiAgICAgICAgICAgIGlmICh3MTQpXG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB3ZGVjMTYoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AxMCArIGpdKTtcbiAgICAgICAgICAgIGkwMCA9IHdkZWMxNFJldHVybi5hO1xuICAgICAgICAgICAgYnVmZmVyMltwMTAgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgYnVmZmVyMltweCArIGpdID0gaTAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobnkgJiBwKSB7XG4gICAgICAgICAgdmFyIHB4ID0gcHk7XG4gICAgICAgICAgdmFyIGV4ID0gcHkgKyBveCAqIChueCAtIHAyKTtcbiAgICAgICAgICBmb3IgKDsgcHggPD0gZXg7IHB4ICs9IG94Mikge1xuICAgICAgICAgICAgdmFyIHAwMSA9IHB4ICsgb3gxO1xuICAgICAgICAgICAgaWYgKHcxNClcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMDEgKyBqXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDAxICsgal0pO1xuICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICBidWZmZXIyW3AwMSArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSBpMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAyID0gcDtcbiAgICAgICAgcCA+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBweTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmRGVjb2RlKGVuY29kaW5nVGFibGUsIGRlY29kaW5nVGFibGUsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIHJsYywgbm8sIG91dEJ1ZmZlciwgb3V0T2Zmc2V0KSB7XG4gICAgICB2YXIgYyA9IDA7XG4gICAgICB2YXIgbGMgPSAwO1xuICAgICAgdmFyIG91dEJ1ZmZlckVuZE9mZnNldCA9IG5vO1xuICAgICAgdmFyIGluT2Zmc2V0RW5kID0gTWF0aC50cnVuYyhpbk9mZnNldC52YWx1ZSArIChuaSArIDcpIC8gOCk7XG4gICAgICB3aGlsZSAoaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpO1xuICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgIHdoaWxlIChsYyA+PSBIVUZfREVDQklUUykge1xuICAgICAgICAgIHZhciBpbmRleCA9IGMgPj4gbGMgLSBIVUZfREVDQklUUyAmIEhVRl9ERUNNQVNLO1xuICAgICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbaW5kZXhdO1xuICAgICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICAgIGxjIC09IHBsLmxlbjtcbiAgICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFwbC5wKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcGwubGl0OyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBodWZMZW5ndGgoZW5jb2RpbmdUYWJsZVtwbC5wW2pdXSk7XG4gICAgICAgICAgICAgIHdoaWxlIChsYyA8IGwgJiYgaW5PZmZzZXQudmFsdWUgPCBpbk9mZnNldEVuZCkge1xuICAgICAgICAgICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgICAgICAgICAgYyA9IGdldENoYXJSZXR1cm4uYztcbiAgICAgICAgICAgICAgICBsYyA9IGdldENoYXJSZXR1cm4ubGM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGxjID49IGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaHVmQ29kZShlbmNvZGluZ1RhYmxlW3BsLnBbal1dKSA9PSAoYyA+PiBsYyAtIGwgJiAoMSA8PCBsKSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICBsYyAtPSBsO1xuICAgICAgICAgICAgICAgICAgZ2V0Q29kZShcbiAgICAgICAgICAgICAgICAgICAgcGwucFtqXSxcbiAgICAgICAgICAgICAgICAgICAgcmxjLFxuICAgICAgICAgICAgICAgICAgICBjLFxuICAgICAgICAgICAgICAgICAgICBsYyxcbiAgICAgICAgICAgICAgICAgICAgdUludDhBcnJheTIsXG4gICAgICAgICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvdXRCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIG91dE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyRW5kT2Zmc2V0XG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICAgICAgICAgIGxjID0gZ2V0Q29kZVJldHVybi5sYztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPT0gcGwubGl0KSB7XG4gICAgICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGkgPSA4IC0gbmkgJiA3O1xuICAgICAgYyA+Pj0gaTtcbiAgICAgIGxjIC09IGk7XG4gICAgICB3aGlsZSAobGMgPiAwKSB7XG4gICAgICAgIHZhciBwbCA9IGRlY29kaW5nVGFibGVbYyA8PCBIVUZfREVDQklUUyAtIGxjICYgSFVGX0RFQ01BU0tdO1xuICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgbGMgLT0gcGwubGVuO1xuICAgICAgICAgIGdldENvZGUocGwubGl0LCBybGMsIGMsIGxjLCB1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0LCBvdXRCdWZmZXJFbmRPZmZzZXQpO1xuICAgICAgICAgIGMgPSBnZXRDb2RlUmV0dXJuLmM7XG4gICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IFwiaHVmRGVjb2RlIGlzc3Vlc1wiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmVW5jb21wcmVzcyh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5Db21wcmVzc2VkLCBvdXRCdWZmZXIsIG5SYXcpIHtcbiAgICAgIHZhciBvdXRPZmZzZXQgPSB7IHZhbHVlOiAwIH07XG4gICAgICB2YXIgaW5pdGlhbEluT2Zmc2V0ID0gaW5PZmZzZXQudmFsdWU7XG4gICAgICB2YXIgaW0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICB2YXIgaU0gPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0O1xuICAgICAgdmFyIG5CaXRzID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaW5PZmZzZXQudmFsdWUgKz0gNDtcbiAgICAgIGlmIChpbSA8IDAgfHwgaW0gPj0gSFVGX0VOQ1NJWkUgfHwgaU0gPCAwIHx8IGlNID49IEhVRl9FTkNTSVpFKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggSFVGX0VOQ1NJWkVcIjtcbiAgICAgIH1cbiAgICAgIHZhciBmcmVxID0gbmV3IEFycmF5KEhVRl9FTkNTSVpFKTtcbiAgICAgIHZhciBoZGVjID0gbmV3IEFycmF5KEhVRl9ERUNTSVpFKTtcbiAgICAgIGh1ZkNsZWFyRGVjVGFibGUoaGRlYyk7XG4gICAgICB2YXIgbmkgPSBuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCk7XG4gICAgICBodWZVbnBhY2tFbmNUYWJsZSh1SW50OEFycmF5MiwgaW5EYXRhVmlldywgaW5PZmZzZXQsIG5pLCBpbSwgaU0sIGZyZXEpO1xuICAgICAgaWYgKG5CaXRzID4gOCAqIChuQ29tcHJlc3NlZCAtIChpbk9mZnNldC52YWx1ZSAtIGluaXRpYWxJbk9mZnNldCkpKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5jb21wcmVzc1wiO1xuICAgICAgfVxuICAgICAgaHVmQnVpbGREZWNUYWJsZShmcmVxLCBpbSwgaU0sIGhkZWMpO1xuICAgICAgaHVmRGVjb2RlKGZyZXEsIGhkZWMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkJpdHMsIGlNLCBuUmF3LCBvdXRCdWZmZXIsIG91dE9mZnNldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5THV0KGx1dCwgZGF0YSwgbkRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkRhdGE7ICsraSkge1xuICAgICAgICBkYXRhW2ldID0gbHV0W2RhdGFbaV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVkaWN0b3Ioc291cmNlKSB7XG4gICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IHNvdXJjZS5sZW5ndGg7IHQrKykge1xuICAgICAgICB2YXIgZCA9IHNvdXJjZVt0IC0gMV0gKyBzb3VyY2VbdF0gLSAxMjg7XG4gICAgICAgIHNvdXJjZVt0XSA9IGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVybGVhdmVTY2FsYXIoc291cmNlLCBvdXQpIHtcbiAgICAgIHZhciB0MSA9IDA7XG4gICAgICB2YXIgdDIgPSBNYXRoLmZsb29yKChzb3VyY2UubGVuZ3RoICsgMSkgLyAyKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBzdG9wID0gc291cmNlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QxKytdO1xuICAgICAgICBpZiAocyA+IHN0b3ApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG91dFtzKytdID0gc291cmNlW3QyKytdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVSdW5MZW5ndGgoc291cmNlKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNvdXJjZS5ieXRlTGVuZ3RoO1xuICAgICAgdmFyIG91dCA9IG5ldyBBcnJheSgpO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBEYXRhVmlldyhzb3VyY2UpO1xuICAgICAgd2hpbGUgKHNpemUgPiAwKSB7XG4gICAgICAgIHZhciBsID0gcmVhZGVyLmdldEludDgocCsrKTtcbiAgICAgICAgaWYgKGwgPCAwKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gLWw7XG4gICAgICAgICAgc2l6ZSAtPSBjb3VudCArIDE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXQucHVzaChyZWFkZXIuZ2V0VWludDgocCsrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb3VudCA9IGw7XG4gICAgICAgICAgc2l6ZSAtPSAyO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlYWRlci5nZXRVaW50OChwKyspO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgKyAxOyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvc3N5RGN0RGVjb2RlKGNzY1NldCwgcm93UHRycywgY2hhbm5lbERhdGEsIGFjQnVmZmVyLCBkY0J1ZmZlciwgb3V0QnVmZmVyKSB7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICB2YXIgd2lkdGggPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4WzBdXS5oZWlnaHQ7XG4gICAgICB2YXIgbnVtQ29tcCA9IDM7XG4gICAgICB2YXIgbnVtRnVsbEJsb2Nrc1ggPSBNYXRoLmZsb29yKHdpZHRoIC8gOCk7XG4gICAgICB2YXIgbnVtQmxvY2tzWCA9IE1hdGguY2VpbCh3aWR0aCAvIDgpO1xuICAgICAgdmFyIG51bUJsb2Nrc1kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gOCk7XG4gICAgICB2YXIgbGVmdG92ZXJYID0gd2lkdGggLSAobnVtQmxvY2tzWCAtIDEpICogODtcbiAgICAgIHZhciBsZWZ0b3ZlclkgPSBoZWlnaHQgLSAobnVtQmxvY2tzWSAtIDEpICogODtcbiAgICAgIHZhciBjdXJyQWNDb21wID0geyB2YWx1ZTogMCB9O1xuICAgICAgdmFyIGN1cnJEY0NvbXAgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgZGN0RGF0YSA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciBoYWxmWmlnQmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93QmxvY2sgPSBuZXcgQXJyYXkobnVtQ29tcCk7XG4gICAgICB2YXIgcm93T2Zmc2V0cyA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgIHJvd09mZnNldHNbY29tcDJdID0gcm93UHRyc1tjc2NTZXQuaWR4W2NvbXAyXV07XG4gICAgICAgIGN1cnJEY0NvbXBbY29tcDJdID0gY29tcDIgPCAxID8gMCA6IGN1cnJEY0NvbXBbY29tcDIgLSAxXSArIG51bUJsb2Nrc1ggKiBudW1CbG9ja3NZO1xuICAgICAgICBkY3REYXRhW2NvbXAyXSA9IG5ldyBGbG9hdDMyQXJyYXkoNjQpO1xuICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KDY0KTtcbiAgICAgICAgcm93QmxvY2tbY29tcDJdID0gbmV3IFVpbnQxNkFycmF5KG51bUJsb2Nrc1ggKiA2NCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBibG9ja3kgPSAwOyBibG9ja3kgPCBudW1CbG9ja3NZOyArK2Jsb2NreSkge1xuICAgICAgICB2YXIgbWF4WSA9IDg7XG4gICAgICAgIGlmIChibG9ja3kgPT0gbnVtQmxvY2tzWSAtIDEpXG4gICAgICAgICAgbWF4WSA9IGxlZnRvdmVyWTtcbiAgICAgICAgdmFyIG1heFggPSA4O1xuICAgICAgICBmb3IgKGxldCBibG9ja3ggPSAwOyBibG9ja3ggPCBudW1CbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgIGlmIChibG9ja3ggPT0gbnVtQmxvY2tzWCAtIDEpXG4gICAgICAgICAgICBtYXhYID0gbGVmdG92ZXJYO1xuICAgICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdLmZpbGwoMCk7XG4gICAgICAgICAgICBoYWxmWmlnQmxvY2tbY29tcDJdWzBdID0gZGNCdWZmZXJbY3VyckRjQ29tcFtjb21wMl0rK107XG4gICAgICAgICAgICB1blJsZUFDKGN1cnJBY0NvbXAsIGFjQnVmZmVyLCBoYWxmWmlnQmxvY2tbY29tcDJdKTtcbiAgICAgICAgICAgIHVuWmlnWmFnKGhhbGZaaWdCbG9ja1tjb21wMl0sIGRjdERhdGFbY29tcDJdKTtcbiAgICAgICAgICAgIGRjdEludmVyc2UoZGN0RGF0YVtjb21wMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB7XG4gICAgICAgICAgICBjc2M3MDlJbnZlcnNlKGRjdERhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgICAgY29udmVydFRvSGFsZihkY3REYXRhW2NvbXAyXSwgcm93QmxvY2tbY29tcDJdLCBibG9ja3ggKiA2NCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBvZmZzZXQyID0gMDtcbiAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICBjb25zdCB0eXBlMiA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcDJdXS50eXBlO1xuICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcDJdW3kyXTtcbiAgICAgICAgICAgIGZvciAobGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUZ1bGxCbG9ja3NYOyArK2Jsb2NreCkge1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBibG9ja3ggKiA2NCArICh5MiAmIDcpICogODtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAwICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMF0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDEgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAxXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDJdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAzICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgM10sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDQgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA0XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNSAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA2ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNl0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDcgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA3XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9mZnNldDIgKz0gOCAqIElOVDE2X1NJWkUgKiB0eXBlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bUZ1bGxCbG9ja3NYICE9IG51bUJsb2Nrc1gpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHkyID0gOCAqIGJsb2NreTsgeTIgPCA4ICogYmxvY2t5ICsgbWF4WTsgKyt5Mikge1xuICAgICAgICAgICAgICBjb25zdCBvZmZzZXQzID0gcm93T2Zmc2V0c1tjb21wMl1beTJdICsgOCAqIG51bUZ1bGxCbG9ja3NYICogSU5UMTZfU0laRSAqIHR5cGUyO1xuICAgICAgICAgICAgICBjb25zdCBzcmMgPSBudW1GdWxsQmxvY2tzWCAqIDY0ICsgKHkyICYgNykgKiA4O1xuICAgICAgICAgICAgICBmb3IgKGxldCB4MiA9IDA7IHgyIDwgbWF4WDsgKyt4Mikge1xuICAgICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQzICsgeDIgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyB4Ml0sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaGFsZlJvdyA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCk7XG4gICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgICBmb3IgKHZhciBjb21wID0gMDsgY29tcCA8IG51bUNvbXA7ICsrY29tcCkge1xuICAgICAgICBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS5kZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjaGFubmVsRGF0YVtjc2NTZXQuaWR4W2NvbXBdXS50eXBlO1xuICAgICAgICBpZiAoY2hhbm5lbERhdGFbY29tcF0udHlwZSAhPSAyKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IHJvd09mZnNldHNbY29tcF1beV07XG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICBoYWxmUm93W3hdID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldDIgKyB4ICogSU5UMTZfU0laRSAqIHR5cGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgIGRhdGFWaWV3LnNldEZsb2F0MzIob2Zmc2V0MiArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgZGVjb2RlRmxvYXQxNihoYWxmUm93W3hdKSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuUmxlQUMoY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9jaykge1xuICAgICAgdmFyIGFjVmFsdWU7XG4gICAgICB2YXIgZGN0Q29tcCA9IDE7XG4gICAgICB3aGlsZSAoZGN0Q29tcCA8IDY0KSB7XG4gICAgICAgIGFjVmFsdWUgPSBhY0J1ZmZlcltjdXJyQWNDb21wLnZhbHVlXTtcbiAgICAgICAgaWYgKGFjVmFsdWUgPT0gNjUyODApIHtcbiAgICAgICAgICBkY3RDb21wID0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYWNWYWx1ZSA+PiA4ID09IDI1NSkge1xuICAgICAgICAgIGRjdENvbXAgKz0gYWNWYWx1ZSAmIDI1NTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYWxmWmlnQmxvY2tbZGN0Q29tcF0gPSBhY1ZhbHVlO1xuICAgICAgICAgIGRjdENvbXArKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyQWNDb21wLnZhbHVlKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuWmlnWmFnKHNyYywgZHN0KSB7XG4gICAgICBkc3RbMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1swXSk7XG4gICAgICBkc3RbMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxXSk7XG4gICAgICBkc3RbMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1XSk7XG4gICAgICBkc3RbM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2XSk7XG4gICAgICBkc3RbNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNF0pO1xuICAgICAgZHN0WzVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTVdKTtcbiAgICAgIGRzdFs2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI3XSk7XG4gICAgICBkc3RbN10gPSBkZWNvZGVGbG9hdDE2KHNyY1syOF0pO1xuICAgICAgZHN0WzhdID0gZGVjb2RlRmxvYXQxNihzcmNbMl0pO1xuICAgICAgZHN0WzldID0gZGVjb2RlRmxvYXQxNihzcmNbNF0pO1xuICAgICAgZHN0WzEwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzddKTtcbiAgICAgIGRzdFsxMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxM10pO1xuICAgICAgZHN0WzEyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE2XSk7XG4gICAgICBkc3RbMTNdID0gZGVjb2RlRmxvYXQxNihzcmNbMjZdKTtcbiAgICAgIGRzdFsxNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syOV0pO1xuICAgICAgZHN0WzE1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQyXSk7XG4gICAgICBkc3RbMTZdID0gZGVjb2RlRmxvYXQxNihzcmNbM10pO1xuICAgICAgZHN0WzE3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzhdKTtcbiAgICAgIGRzdFsxOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMl0pO1xuICAgICAgZHN0WzE5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE3XSk7XG4gICAgICBkc3RbMjBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjVdKTtcbiAgICAgIGRzdFsyMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMF0pO1xuICAgICAgZHN0WzIyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQxXSk7XG4gICAgICBkc3RbMjNdID0gZGVjb2RlRmxvYXQxNihzcmNbNDNdKTtcbiAgICAgIGRzdFsyNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s5XSk7XG4gICAgICBkc3RbMjVdID0gZGVjb2RlRmxvYXQxNihzcmNbMTFdKTtcbiAgICAgIGRzdFsyNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxOF0pO1xuICAgICAgZHN0WzI3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI0XSk7XG4gICAgICBkc3RbMjhdID0gZGVjb2RlRmxvYXQxNihzcmNbMzFdKTtcbiAgICAgIGRzdFsyOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0MF0pO1xuICAgICAgZHN0WzMwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ0XSk7XG4gICAgICBkc3RbMzFdID0gZGVjb2RlRmxvYXQxNihzcmNbNTNdKTtcbiAgICAgIGRzdFszMl0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMF0pO1xuICAgICAgZHN0WzMzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzE5XSk7XG4gICAgICBkc3RbMzRdID0gZGVjb2RlRmxvYXQxNihzcmNbMjNdKTtcbiAgICAgIGRzdFszNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMl0pO1xuICAgICAgZHN0WzM2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM5XSk7XG4gICAgICBkc3RbMzddID0gZGVjb2RlRmxvYXQxNihzcmNbNDVdKTtcbiAgICAgIGRzdFszOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Ml0pO1xuICAgICAgZHN0WzM5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU0XSk7XG4gICAgICBkc3RbNDBdID0gZGVjb2RlRmxvYXQxNihzcmNbMjBdKTtcbiAgICAgIGRzdFs0MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMl0pO1xuICAgICAgZHN0WzQyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzMzXSk7XG4gICAgICBkc3RbNDNdID0gZGVjb2RlRmxvYXQxNihzcmNbMzhdKTtcbiAgICAgIGRzdFs0NF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0Nl0pO1xuICAgICAgZHN0WzQ1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzUxXSk7XG4gICAgICBkc3RbNDZdID0gZGVjb2RlRmxvYXQxNihzcmNbNTVdKTtcbiAgICAgIGRzdFs0N10gPSBkZWNvZGVGbG9hdDE2KHNyY1s2MF0pO1xuICAgICAgZHN0WzQ4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzIxXSk7XG4gICAgICBkc3RbNDldID0gZGVjb2RlRmxvYXQxNihzcmNbMzRdKTtcbiAgICAgIGRzdFs1MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1szN10pO1xuICAgICAgZHN0WzUxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ3XSk7XG4gICAgICBkc3RbNTJdID0gZGVjb2RlRmxvYXQxNihzcmNbNTBdKTtcbiAgICAgIGRzdFs1M10gPSBkZWNvZGVGbG9hdDE2KHNyY1s1Nl0pO1xuICAgICAgZHN0WzU0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzU5XSk7XG4gICAgICBkc3RbNTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNjFdKTtcbiAgICAgIGRzdFs1Nl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szNV0pO1xuICAgICAgZHN0WzU3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM2XSk7XG4gICAgICBkc3RbNThdID0gZGVjb2RlRmxvYXQxNihzcmNbNDhdKTtcbiAgICAgIGRzdFs1OV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0OV0pO1xuICAgICAgZHN0WzYwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU3XSk7XG4gICAgICBkc3RbNjFdID0gZGVjb2RlRmxvYXQxNihzcmNbNThdKTtcbiAgICAgIGRzdFs2Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1s2Ml0pO1xuICAgICAgZHN0WzYzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzYzXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRjdEludmVyc2UoZGF0YSkge1xuICAgICAgY29uc3QgYSA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA0KTtcbiAgICAgIGNvbnN0IGIgPSAwLjUgKiBNYXRoLmNvcygzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgYyA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyA4KTtcbiAgICAgIGNvbnN0IGQgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGUgPSAwLjUgKiBNYXRoLmNvcyg1ICogMy4xNDE1OSAvIDE2KTtcbiAgICAgIGNvbnN0IGYgPSAwLjUgKiBNYXRoLmNvcygzICogMy4xNDE1OSAvIDgpO1xuICAgICAgY29uc3QgZyA9IDAuNSAqIE1hdGguY29zKDcgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgdmFyIGFscGhhID0gbmV3IEFycmF5KDQpO1xuICAgICAgdmFyIGJldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgdGhldGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgZ2FtbWEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCA4OyArK3Jvdykge1xuICAgICAgICB2YXIgcm93UHRyID0gcm93ICogODtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMV0gPSBmICogZGF0YVtyb3dQdHIgKyAyXTtcbiAgICAgICAgYWxwaGFbMl0gPSBjICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVtyb3dQdHIgKyA2XTtcbiAgICAgICAgYmV0YVswXSA9IGIgKiBkYXRhW3Jvd1B0ciArIDFdICsgZCAqIGRhdGFbcm93UHRyICsgM10gKyBlICogZGF0YVtyb3dQdHIgKyA1XSArIGcgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzFdID0gZCAqIGRhdGFbcm93UHRyICsgMV0gLSBnICogZGF0YVtyb3dQdHIgKyAzXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDVdIC0gZSAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbMl0gPSBlICogZGF0YVtyb3dQdHIgKyAxXSAtIGIgKiBkYXRhW3Jvd1B0ciArIDNdICsgZyAqIGRhdGFbcm93UHRyICsgNV0gKyBkICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVszXSA9IGcgKiBkYXRhW3Jvd1B0ciArIDFdIC0gZSAqIGRhdGFbcm93UHRyICsgM10gKyBkICogZGF0YVtyb3dQdHIgKyA1XSAtIGIgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICB0aGV0YVswXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSArIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVszXSA9IGEgKiAoZGF0YVtyb3dQdHIgKyAwXSAtIGRhdGFbcm93UHRyICsgNF0pO1xuICAgICAgICB0aGV0YVsxXSA9IGFscGhhWzBdICsgYWxwaGFbM107XG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXTtcbiAgICAgICAgZ2FtbWFbMF0gPSB0aGV0YVswXSArIHRoZXRhWzFdO1xuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzJdID0gdGhldGFbM10gLSB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbM10gPSB0aGV0YVswXSAtIHRoZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDBdID0gZ2FtbWFbMF0gKyBiZXRhWzBdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDFdID0gZ2FtbWFbMV0gKyBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDJdID0gZ2FtbWFbMl0gKyBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDNdID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDRdID0gZ2FtbWFbM10gLSBiZXRhWzNdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDVdID0gZ2FtbWFbMl0gLSBiZXRhWzJdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDZdID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhW3Jvd1B0ciArIDddID0gZ2FtbWFbMF0gLSBiZXRhWzBdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgY29sdW1uID0gMDsgY29sdW1uIDwgODsgKytjb2x1bW4pIHtcbiAgICAgICAgYWxwaGFbMF0gPSBjICogZGF0YVsxNiArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzFdID0gZiAqIGRhdGFbMTYgKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVsyXSA9IGMgKiBkYXRhWzQ4ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbM10gPSBmICogZGF0YVs0OCArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMF0gPSBiICogZGF0YVs4ICsgY29sdW1uXSArIGQgKiBkYXRhWzI0ICsgY29sdW1uXSArIGUgKiBkYXRhWzQwICsgY29sdW1uXSArIGcgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVsxXSA9IGQgKiBkYXRhWzggKyBjb2x1bW5dIC0gZyAqIGRhdGFbMjQgKyBjb2x1bW5dIC0gYiAqIGRhdGFbNDAgKyBjb2x1bW5dIC0gZSAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzJdID0gZSAqIGRhdGFbOCArIGNvbHVtbl0gLSBiICogZGF0YVsyNCArIGNvbHVtbl0gKyBnICogZGF0YVs0MCArIGNvbHVtbl0gKyBkICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbM10gPSBnICogZGF0YVs4ICsgY29sdW1uXSAtIGUgKiBkYXRhWzI0ICsgY29sdW1uXSArIGQgKiBkYXRhWzQwICsgY29sdW1uXSAtIGIgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgdGhldGFbMF0gPSBhICogKGRhdGFbY29sdW1uXSArIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbM10gPSBhICogKGRhdGFbY29sdW1uXSAtIGRhdGFbMzIgKyBjb2x1bW5dKTtcbiAgICAgICAgdGhldGFbMV0gPSBhbHBoYVswXSArIGFscGhhWzNdO1xuICAgICAgICB0aGV0YVsyXSA9IGFscGhhWzFdIC0gYWxwaGFbMl07XG4gICAgICAgIGdhbW1hWzBdID0gdGhldGFbMF0gKyB0aGV0YVsxXTtcbiAgICAgICAgZ2FtbWFbMV0gPSB0aGV0YVszXSArIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVsyXSA9IHRoZXRhWzNdIC0gdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzNdID0gdGhldGFbMF0gLSB0aGV0YVsxXTtcbiAgICAgICAgZGF0YVswICsgY29sdW1uXSA9IGdhbW1hWzBdICsgYmV0YVswXTtcbiAgICAgICAgZGF0YVs4ICsgY29sdW1uXSA9IGdhbW1hWzFdICsgYmV0YVsxXTtcbiAgICAgICAgZGF0YVsxNiArIGNvbHVtbl0gPSBnYW1tYVsyXSArIGJldGFbMl07XG4gICAgICAgIGRhdGFbMjQgKyBjb2x1bW5dID0gZ2FtbWFbM10gKyBiZXRhWzNdO1xuICAgICAgICBkYXRhWzMyICsgY29sdW1uXSA9IGdhbW1hWzNdIC0gYmV0YVszXTtcbiAgICAgICAgZGF0YVs0MCArIGNvbHVtbl0gPSBnYW1tYVsyXSAtIGJldGFbMl07XG4gICAgICAgIGRhdGFbNDggKyBjb2x1bW5dID0gZ2FtbWFbMV0gLSBiZXRhWzFdO1xuICAgICAgICBkYXRhWzU2ICsgY29sdW1uXSA9IGdhbW1hWzBdIC0gYmV0YVswXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3NjNzA5SW52ZXJzZShkYXRhKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgdmFyIHkgPSBkYXRhWzBdW2ldO1xuICAgICAgICB2YXIgY2IgPSBkYXRhWzFdW2ldO1xuICAgICAgICB2YXIgY3IgPSBkYXRhWzJdW2ldO1xuICAgICAgICBkYXRhWzBdW2ldID0geSArIDEuNTc0NyAqIGNyO1xuICAgICAgICBkYXRhWzFdW2ldID0geSAtIDAuMTg3MyAqIGNiIC0gMC40NjgyICogY3I7XG4gICAgICAgIGRhdGFbMl1baV0gPSB5ICsgMS44NTU2ICogY2I7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0hhbGYoc3JjLCBkc3QsIGlkeCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgKytpKSB7XG4gICAgICAgIGRzdFtpZHggKyBpXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdCh0b0xpbmVhcihzcmNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9MaW5lYXIoZmxvYXQpIHtcbiAgICAgIGlmIChmbG9hdCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oZmxvYXQpICogTWF0aC5wb3coTWF0aC5hYnMoZmxvYXQpLCAyLjIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihmbG9hdCkgKiBNYXRoLnBvdyhsb2dCYXNlLCBNYXRoLmFicyhmbG9hdCkgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JBVyhpbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGluZm8uYXJyYXkuYnVmZmVyLCBpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5zaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1JMRShpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8udmlld2VyLmJ1ZmZlci5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRlY29kZVJ1bkxlbmd0aChjb21wcmVzc2VkKSk7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyLmxlbmd0aCk7XG4gICAgICBwcmVkaWN0b3IocmF3QnVmZmVyKTtcbiAgICAgIGludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1pJUChpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHJhd0J1ZmZlci5sZW5ndGgpO1xuICAgICAgcHJlZGljdG9yKHJhd0J1ZmZlcik7XG4gICAgICBpbnRlcmxlYXZlU2NhbGFyKHJhd0J1ZmZlciwgdG1wQnVmZmVyKTtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NQSVooaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlcjtcbiAgICAgIHZhciBpbk9mZnNldCA9IHsgdmFsdWU6IGluZm8ub2Zmc2V0LnZhbHVlIH07XG4gICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGluZm8ud2lkdGggKiBpbmZvLnNjYW5saW5lQmxvY2tTaXplICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUpKTtcbiAgICAgIHZhciBiaXRtYXAgPSBuZXcgVWludDhBcnJheShCSVRNQVBfU0laRSk7XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kID0gMDtcbiAgICAgIHZhciBwaXpDaGFubmVsRGF0YSA9IG5ldyBBcnJheShpbmZvLmNoYW5uZWxzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgaSsrKSB7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldID0ge307XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wic3RhcnRcIl0gPSBvdXRCdWZmZXJFbmQ7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wiZW5kXCJdID0gcGl6Q2hhbm5lbERhdGFbaV1bXCJzdGFydFwiXTtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJueFwiXSA9IGluZm8ud2lkdGg7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wibnlcIl0gPSBpbmZvLmxpbmVzO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcInNpemVcIl0gPSBpbmZvLnR5cGU7XG4gICAgICAgIG91dEJ1ZmZlckVuZCArPSBwaXpDaGFubmVsRGF0YVtpXS5ueCAqIHBpekNoYW5uZWxEYXRhW2ldLm55ICogcGl6Q2hhbm5lbERhdGFbaV0uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5Ob25aZXJvID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgdmFyIG1heE5vblplcm8gPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpZiAobWF4Tm9uWmVybyA+PSBCSVRNQVBfU0laRSkge1xuICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIFBJWl9DT01QUkVTU0lPTiBCSVRNQVBfU0laRVwiO1xuICAgICAgfVxuICAgICAgaWYgKG1pbk5vblplcm8gPD0gbWF4Tm9uWmVybykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE5vblplcm8gLSBtaW5Ob25aZXJvICsgMTsgaSsrKSB7XG4gICAgICAgICAgYml0bWFwW2kgKyBtaW5Ob25aZXJvXSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgbHV0ID0gbmV3IFVpbnQxNkFycmF5KFVTSE9SVF9SQU5HRSk7XG4gICAgICB2YXIgbWF4VmFsdWUgPSByZXZlcnNlTHV0RnJvbUJpdG1hcChiaXRtYXAsIGx1dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFyc2VVaW50MzIoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgaHVmVW5jb21wcmVzcyhpbmZvLmFycmF5LCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbGVuZ3RoLCBvdXRCdWZmZXIsIG91dEJ1ZmZlckVuZCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwaXpDaGFubmVsRGF0YVtpXS5zaXplOyArK2opIHtcbiAgICAgICAgICB3YXYyRGVjb2RlKG91dEJ1ZmZlciwgY2Quc3RhcnQgKyBqLCBjZC5ueCwgY2Quc2l6ZSwgY2QubnksIGNkLm54ICogY2Quc2l6ZSwgbWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHBseUx1dChsdXQsIG91dEJ1ZmZlciwgb3V0QnVmZmVyRW5kKTtcbiAgICAgIHZhciB0bXBPZmZzZXQyID0gMDtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICB2YXIgY2QgPSBwaXpDaGFubmVsRGF0YVtjXTtcbiAgICAgICAgICB2YXIgbiA9IGNkLm54ICogY2Quc2l6ZTtcbiAgICAgICAgICB2YXIgY3AgPSBuZXcgVWludDhBcnJheShvdXRCdWZmZXIuYnVmZmVyLCBjZC5lbmQgKiBJTlQxNl9TSVpFLCBuICogSU5UMTZfU0laRSk7XG4gICAgICAgICAgdG1wQnVmZmVyLnNldChjcCwgdG1wT2Zmc2V0Mik7XG4gICAgICAgICAgdG1wT2Zmc2V0MiArPSBuICogSU5UMTZfU0laRTtcbiAgICAgICAgICBjZC5lbmQgKz0gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1BYUihpbmZvKSB7XG4gICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5mby5vZmZzZXQudmFsdWUsIGluZm8ub2Zmc2V0LnZhbHVlICsgaW5mby5zaXplKTtcbiAgICAgIHZhciByYXdCdWZmZXIgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgY29uc3Qgc3ogPSBpbmZvLmxpbmVzICogaW5mby5jaGFubmVscyAqIGluZm8ud2lkdGg7XG4gICAgICBjb25zdCB0bXBCdWZmZXIgPSBpbmZvLnR5cGUgPT0gMSA/IG5ldyBVaW50MTZBcnJheShzeikgOiBuZXcgVWludDMyQXJyYXkoc3opO1xuICAgICAgbGV0IHRtcEJ1ZmZlckVuZCA9IDA7XG4gICAgICBsZXQgd3JpdGVQdHIgPSAwO1xuICAgICAgY29uc3QgcHRyID0gbmV3IEFycmF5KDQpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpbmZvLmxpbmVzOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpbmZvLmNoYW5uZWxzOyBjKyspIHtcbiAgICAgICAgICBsZXQgcGl4ZWwgPSAwO1xuICAgICAgICAgIHN3aXRjaCAoaW5mby50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHB0clswXSA9IHRtcEJ1ZmZlckVuZDtcbiAgICAgICAgICAgICAgcHRyWzFdID0gcHRyWzBdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgdG1wQnVmZmVyRW5kID0gcHRyWzFdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLndpZHRoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gcmF3QnVmZmVyW3B0clswXSsrXSA8PCA4IHwgcmF3QnVmZmVyW3B0clsxXSsrXTtcbiAgICAgICAgICAgICAgICBwaXhlbCArPSBkaWZmO1xuICAgICAgICAgICAgICAgIHRtcEJ1ZmZlclt3cml0ZVB0cl0gPSBwaXhlbDtcbiAgICAgICAgICAgICAgICB3cml0ZVB0cisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBwdHJbMF0gPSB0bXBCdWZmZXJFbmQ7XG4gICAgICAgICAgICAgIHB0clsxXSA9IHB0clswXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHB0clsyXSA9IHB0clsxXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIHRtcEJ1ZmZlckVuZCA9IHB0clsyXSArIGluZm8ud2lkdGg7XG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5mby53aWR0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IHJhd0J1ZmZlcltwdHJbMF0rK10gPDwgMjQgfCByYXdCdWZmZXJbcHRyWzFdKytdIDw8IDE2IHwgcmF3QnVmZmVyW3B0clsyXSsrXSA8PCA4O1xuICAgICAgICAgICAgICAgIHBpeGVsICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIHdyaXRlUHRyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzRFdBKGluZm8pIHtcbiAgICAgIHZhciBpbkRhdGFWaWV3ID0gaW5mby52aWV3ZXI7XG4gICAgICB2YXIgaW5PZmZzZXQgPSB7IHZhbHVlOiBpbmZvLm9mZnNldC52YWx1ZSB9O1xuICAgICAgdmFyIG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluZm8ud2lkdGggKiBpbmZvLmxpbmVzICogKGluZm8uY2hhbm5lbHMgKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFKSk7XG4gICAgICB2YXIgZHdhSGVhZGVyID0ge1xuICAgICAgICB2ZXJzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgdW5rbm93blVuY29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB1bmtub3duQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgZGNDb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZUNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHJsZVJhd1NpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbEFjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB0b3RhbERjVW5jb21wcmVzc2VkQ291bnQ6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBhY0NvbXByZXNzaW9uOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KVxuICAgICAgfTtcbiAgICAgIGlmIChkd2FIZWFkZXIudmVyc2lvbiA8IDIpIHtcbiAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyLmNvbXByZXNzaW9uICsgXCIgdmVyc2lvbiBcIiArIGR3YUhlYWRlci52ZXJzaW9uICsgXCIgaXMgdW5zdXBwb3J0ZWRcIjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFubmVsUnVsZXMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBydWxlU2l6ZSA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KSAtIElOVDE2X1NJWkU7XG4gICAgICB3aGlsZSAocnVsZVNpemUgPiAwKSB7XG4gICAgICAgIHZhciBuYW1lID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhpbkRhdGFWaWV3LmJ1ZmZlciwgaW5PZmZzZXQpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gdmFsdWUgPj4gMiAmIDM7XG4gICAgICAgIHZhciBjc2MgPSAodmFsdWUgPj4gNCkgLSAxO1xuICAgICAgICB2YXIgaW5kZXggPSBuZXcgSW50OEFycmF5KFtjc2NdKVswXTtcbiAgICAgICAgdmFyIHR5cGUgPSBwYXJzZVVpbnQ4KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgICAgY2hhbm5lbFJ1bGVzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBjb21wcmVzc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgcnVsZVNpemUgLT0gbmFtZS5sZW5ndGggKyAzO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWxzID0gRVhSSGVhZGVyLmNoYW5uZWxzO1xuICAgICAgdmFyIGNoYW5uZWxEYXRhID0gbmV3IEFycmF5KGluZm8uY2hhbm5lbHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyArK2kpIHtcbiAgICAgICAgdmFyIGNkID0gY2hhbm5lbERhdGFbaV0gPSB7fTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBjaGFubmVsc1tpXTtcbiAgICAgICAgY2QubmFtZSA9IGNoYW5uZWwubmFtZTtcbiAgICAgICAgY2QuY29tcHJlc3Npb24gPSBVTktOT1dOO1xuICAgICAgICBjZC5kZWNvZGVkID0gZmFsc2U7XG4gICAgICAgIGNkLnR5cGUgPSBjaGFubmVsLnBpeGVsVHlwZTtcbiAgICAgICAgY2QucExpbmVhciA9IGNoYW5uZWwucExpbmVhcjtcbiAgICAgICAgY2Qud2lkdGggPSBpbmZvLndpZHRoO1xuICAgICAgICBjZC5oZWlnaHQgPSBpbmZvLmxpbmVzO1xuICAgICAgfVxuICAgICAgdmFyIGNzY1NldCA9IHtcbiAgICAgICAgaWR4OiBuZXcgQXJyYXkoMylcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBvZmZzZXQyID0gMDsgb2Zmc2V0MiA8IGluZm8uY2hhbm5lbHM7ICsrb2Zmc2V0Mikge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtvZmZzZXQyXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsUnVsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgcnVsZSA9IGNoYW5uZWxSdWxlc1tpXTtcbiAgICAgICAgICBpZiAoY2QubmFtZSA9PSBydWxlLm5hbWUpIHtcbiAgICAgICAgICAgIGNkLmNvbXByZXNzaW9uID0gcnVsZS5jb21wcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChydWxlLmluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgY3NjU2V0LmlkeFtydWxlLmluZGV4XSA9IG9mZnNldDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZC5vZmZzZXQgPSBvZmZzZXQyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5hY0NvbXByZXNzZWRTaXplID4gMCkge1xuICAgICAgICBzd2l0Y2ggKGR3YUhlYWRlci5hY0NvbXByZXNzaW9uKSB7XG4gICAgICAgICAgY2FzZSBTVEFUSUNfSFVGRk1BTjpcbiAgICAgICAgICAgIHZhciBhY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheShkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50KTtcbiAgICAgICAgICAgIGh1ZlVuY29tcHJlc3MoXG4gICAgICAgICAgICAgIGluZm8uYXJyYXksXG4gICAgICAgICAgICAgIGluRGF0YVZpZXcsXG4gICAgICAgICAgICAgIGluT2Zmc2V0LFxuICAgICAgICAgICAgICBkd2FIZWFkZXIuYWNDb21wcmVzc2VkU2l6ZSxcbiAgICAgICAgICAgICAgYWNCdWZmZXIsXG4gICAgICAgICAgICAgIGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERFRkxBVEU6XG4gICAgICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5PZmZzZXQudmFsdWUsIGluT2Zmc2V0LnZhbHVlICsgZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICAgICAgICB2YXIgYWNCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoZGF0YS5idWZmZXIpO1xuICAgICAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemUgPiAwKSB7XG4gICAgICAgIHZhciB6bGliSW5mbyA9IHtcbiAgICAgICAgICBhcnJheTogaW5mby5hcnJheSxcbiAgICAgICAgICBvZmZzZXQ6IGluT2Zmc2V0LFxuICAgICAgICAgIHNpemU6IGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheSh1bmNvbXByZXNzWklQKHpsaWJJbmZvKS5idWZmZXIpO1xuICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIucmxlUmF3U2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBpbmZvLmFycmF5LnNsaWNlKGluT2Zmc2V0LnZhbHVlLCBpbk9mZnNldC52YWx1ZSArIGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgIHZhciBkYXRhID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgICAgdmFyIHJsZUJ1ZmZlciA9IGRlY29kZVJ1bkxlbmd0aChkYXRhLmJ1ZmZlcik7XG4gICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5ybGVDb21wcmVzc2VkU2l6ZTtcbiAgICAgIH1cbiAgICAgIHZhciBvdXRCdWZmZXJFbmQgPSAwO1xuICAgICAgdmFyIHJvd09mZnNldHMgPSBuZXcgQXJyYXkoY2hhbm5lbERhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93T2Zmc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICByb3dPZmZzZXRzW2ldID0gbmV3IEFycmF5KCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICBmb3IgKHZhciBjaGFuID0gMDsgY2hhbiA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKytjaGFuKSB7XG4gICAgICAgICAgcm93T2Zmc2V0c1tjaGFuXS5wdXNoKG91dEJ1ZmZlckVuZCk7XG4gICAgICAgICAgb3V0QnVmZmVyRW5kICs9IGNoYW5uZWxEYXRhW2NoYW5dLndpZHRoICogaW5mby50eXBlICogSU5UMTZfU0laRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9zc3lEY3REZWNvZGUoY3NjU2V0LCByb3dPZmZzZXRzLCBjaGFubmVsRGF0YSwgYWNCdWZmZXIsIGRjQnVmZmVyLCBvdXRCdWZmZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFubmVsRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtpXTtcbiAgICAgICAgaWYgKGNkLmRlY29kZWQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN3aXRjaCAoY2QuY29tcHJlc3Npb24pIHtcbiAgICAgICAgICBjYXNlIFJMRTpcbiAgICAgICAgICAgIHZhciByb3cgPSAwO1xuICAgICAgICAgICAgdmFyIHJsZU9mZnNldCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7ICsreSkge1xuICAgICAgICAgICAgICB2YXIgcm93T2Zmc2V0Qnl0ZXMgPSByb3dPZmZzZXRzW2ldW3Jvd107XG4gICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2Qud2lkdGg7ICsreCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGJ5dGUgPSAwOyBieXRlIDwgSU5UMTZfU0laRSAqIGNkLnR5cGU7ICsrYnl0ZSkge1xuICAgICAgICAgICAgICAgICAgb3V0QnVmZmVyW3Jvd09mZnNldEJ5dGVzKytdID0gcmxlQnVmZmVyW3JsZU9mZnNldCArIGJ5dGUgKiBjZC53aWR0aCAqIGNkLmhlaWdodF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJsZU9mZnNldCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBMT1NTWV9EQ1Q6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiB1bnN1cHBvcnRlZCBjaGFubmVsIGNvbXByZXNzaW9uXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mikge1xuICAgICAgdmFyIHVpbnRCdWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXIyKTtcbiAgICAgIHZhciBlbmRPZmZzZXQgPSAwO1xuICAgICAgd2hpbGUgKHVpbnRCdWZmZXJbb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldF0gIT0gMCkge1xuICAgICAgICBlbmRPZmZzZXQgKz0gMTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZSh1aW50QnVmZmVyLnNsaWNlKG9mZnNldDIudmFsdWUsIG9mZnNldDIudmFsdWUgKyBlbmRPZmZzZXQpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0ICsgMTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VGaXhlZExlbmd0aFN0cmluZyhidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMikuc2xpY2Uob2Zmc2V0Mi52YWx1ZSwgb2Zmc2V0Mi52YWx1ZSArIHNpemUpKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgc2l6ZTtcbiAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VSYXRpb25hbChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VUaW1lY29kZShkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBJbnQzMiA9IGRhdGFWaWV3LmdldEludDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQzMl9TSVpFO1xuICAgICAgcmV0dXJuIEludDMyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQzMiA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UMzJfU0laRTtcbiAgICAgIHJldHVybiBVaW50MzI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDhBcnJheSh1SW50OEFycmF5Miwgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gdUludDhBcnJheTJbb2Zmc2V0Mi52YWx1ZV07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQ4ID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0Mi52YWx1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDhfU0laRTtcbiAgICAgIHJldHVybiBVaW50ODtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VJbnQ2NCA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICBsZXQgaW50O1xuICAgICAgaWYgKFwiZ2V0QmlnSW50NjRcIiBpbiBEYXRhVmlldy5wcm90b3R5cGUpIHtcbiAgICAgICAgaW50ID0gTnVtYmVyKGRhdGFWaWV3LmdldEJpZ0ludDY0KG9mZnNldDIudmFsdWUsIHRydWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludCA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQyLnZhbHVlICsgNCwgdHJ1ZSkgKyBOdW1iZXIoZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUsIHRydWUpIDw8IDMyKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gVUxPTkdfU0laRTtcbiAgICAgIHJldHVybiBpbnQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBmbG9hdCA9IGRhdGFWaWV3LmdldEZsb2F0MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlICs9IEZMT0FUMzJfU0laRTtcbiAgICAgIHJldHVybiBmbG9hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgcmV0dXJuIERhdGFVdGlscy50b0hhbGZGbG9hdChwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlRmxvYXQxNihiaW5hcnkpIHtcbiAgICAgIHZhciBleHBvbmVudCA9IChiaW5hcnkgJiAzMTc0NCkgPj4gMTAsIGZyYWN0aW9uID0gYmluYXJ5ICYgMTAyMztcbiAgICAgIHJldHVybiAoYmluYXJ5ID4+IDE1ID8gLTEgOiAxKSAqIChleHBvbmVudCA/IGV4cG9uZW50ID09PSAzMSA/IGZyYWN0aW9uID8gTmFOIDogSW5maW5pdHkgOiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1KSAqICgxICsgZnJhY3Rpb24gLyAxMDI0KSA6IDYxMDM1MTU2MjVlLTE0ICogKGZyYWN0aW9uIC8gMTAyNCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQxNihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIFVpbnQxNiA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgKz0gSU5UMTZfU0laRTtcbiAgICAgIHJldHVybiBVaW50MTY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXQxNihidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICByZXR1cm4gZGVjb2RlRmxvYXQxNihwYXJzZVVpbnQxNihidWZmZXIyLCBvZmZzZXQyKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKSB7XG4gICAgICB2YXIgc3RhcnRPZmZzZXQgPSBvZmZzZXQyLnZhbHVlO1xuICAgICAgdmFyIGNoYW5uZWxzID0gW107XG4gICAgICB3aGlsZSAob2Zmc2V0Mi52YWx1ZSA8IHN0YXJ0T2Zmc2V0ICsgc2l6ZSAtIDEpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICB2YXIgcGl4ZWxUeXBlID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIHZhciBwTGluZWFyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gMztcbiAgICAgICAgdmFyIHhTYW1wbGluZyA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgICB2YXIgeVNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIGNoYW5uZWxzLnB1c2goe1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGl4ZWxUeXBlLFxuICAgICAgICAgIHBMaW5lYXIsXG4gICAgICAgICAgeFNhbXBsaW5nLFxuICAgICAgICAgIHlTYW1wbGluZ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG9mZnNldDIudmFsdWUgKz0gMTtcbiAgICAgIHJldHVybiBjaGFubmVscztcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDaHJvbWF0aWNpdGllcyhkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHJlZFggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHJlZFkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGdyZWVuWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgZ3JlZW5ZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBibHVlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgYmx1ZVkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHdoaXRlWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgd2hpdGVZID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZFgsXG4gICAgICAgIHJlZFksXG4gICAgICAgIGdyZWVuWCxcbiAgICAgICAgZ3JlZW5ZLFxuICAgICAgICBibHVlWCxcbiAgICAgICAgYmx1ZVksXG4gICAgICAgIHdoaXRlWCxcbiAgICAgICAgd2hpdGVZXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgY29tcHJlc3Npb25Db2RlcyA9IFtcbiAgICAgICAgXCJOT19DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlJMRV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlpJUFNfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJaSVBfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQSVpfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJQWFIyNF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkI0NEFfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJEV0FBX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiRFdBQl9DT01QUkVTU0lPTlwiXG4gICAgICBdO1xuICAgICAgdmFyIGNvbXByZXNzaW9uID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gY29tcHJlc3Npb25Db2Rlc1tjb21wcmVzc2lvbl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4TWluID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHlNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeE1heCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5TWF4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIHsgeE1pbiwgeU1pbiwgeE1heCwgeU1heCB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGxpbmVPcmRlcnMgPSBbXCJJTkNSRUFTSU5HX1lcIl07XG4gICAgICB2YXIgbGluZU9yZGVyID0gcGFyc2VVaW50OChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gbGluZU9yZGVyc1tsaW5lT3JkZXJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVYyZihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB6ID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBbeCwgeSwgel07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVmFsdWUoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHR5cGUsIHNpemUpIHtcbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGUgPT09IFwic3RyaW5ndmVjdG9yXCIgfHwgdHlwZSA9PT0gXCJpY2NQcm9maWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRml4ZWRMZW5ndGhTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Miwgc2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiY2hsaXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hsaXN0KGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjaHJvbWF0aWNpdGllc1wiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNocm9tYXRpY2l0aWVzKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21wcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUNvbXByZXNzaW9uKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJib3gyaVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUJveDJpKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJsaW5lT3JkZXJcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VMaW5lT3JkZXIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImZsb2F0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidjJmXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2M2ZcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VWM2YoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYXRpb25hbFwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVJhdGlvbmFsKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0aW1lY29kZVwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRpbWVjb2RlKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJwcmV2aWV3XCIpIHtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBzaXplO1xuICAgICAgICByZXR1cm4gXCJza2lwcGVkXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IHNpemU7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICBjb25zdCBFWFJIZWFkZXIyID0ge307XG4gICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDMyKDAsIHRydWUpICE9IDIwMDAwNjMwKSB7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGluIE9wZW5FWFIgZm9ybWF0LlwiO1xuICAgICAgfVxuICAgICAgRVhSSGVhZGVyMi52ZXJzaW9uID0gZGF0YVZpZXcuZ2V0VWludDgoNCk7XG4gICAgICBjb25zdCBzcGVjID0gZGF0YVZpZXcuZ2V0VWludDgoNSk7XG4gICAgICBFWFJIZWFkZXIyLnNwZWMgPSB7XG4gICAgICAgIHNpbmdsZVRpbGU6ICEhKHNwZWMgJiAyKSxcbiAgICAgICAgbG9uZ05hbWU6ICEhKHNwZWMgJiA0KSxcbiAgICAgICAgZGVlcEZvcm1hdDogISEoc3BlYyAmIDgpLFxuICAgICAgICBtdWx0aVBhcnQ6ICEhKHNwZWMgJiAxNilcbiAgICAgIH07XG4gICAgICBvZmZzZXQyLnZhbHVlID0gODtcbiAgICAgIHZhciBrZWVwUmVhZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoa2VlcFJlYWRpbmcpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIpO1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSAwKSB7XG4gICAgICAgICAga2VlcFJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVHlwZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVNpemUgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZVZhbHVlID0gcGFyc2VWYWx1ZShkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0MiwgYXR0cmlidXRlVHlwZSwgYXR0cmlidXRlU2l6ZSk7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZVZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRVhSTG9hZGVyLnBhcnNlOiBza2lwcGVkIHVua25vd24gaGVhZGVyIGF0dHJpYnV0ZSB0eXBlICcke2F0dHJpYnV0ZVR5cGV9Jy5gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgRVhSSGVhZGVyMlthdHRyaWJ1dGVOYW1lXSA9IGF0dHJpYnV0ZVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKChzcGVjICYgfjQpICE9IDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVYUkhlYWRlcjpcIiwgRVhSSGVhZGVyMik7XG4gICAgICAgIHRocm93IFwiVEhSRUUuRVhSTG9hZGVyOiBwcm92aWRlZCBmaWxlIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBFWFJIZWFkZXIyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR1cERlY29kZXIoRVhSSGVhZGVyMiwgZGF0YVZpZXcsIHVJbnQ4QXJyYXkyLCBvZmZzZXQyLCBvdXRwdXRUeXBlKSB7XG4gICAgICBjb25zdCBFWFJEZWNvZGVyMiA9IHtcbiAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgdmlld2VyOiBkYXRhVmlldyxcbiAgICAgICAgYXJyYXk6IHVJbnQ4QXJyYXkyLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldDIsXG4gICAgICAgIHdpZHRoOiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueE1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy54TWluICsgMSxcbiAgICAgICAgaGVpZ2h0OiBFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1heCAtIEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWluICsgMSxcbiAgICAgICAgY2hhbm5lbHM6IEVYUkhlYWRlcjIuY2hhbm5lbHMubGVuZ3RoLFxuICAgICAgICBieXRlc1BlckxpbmU6IG51bGwsXG4gICAgICAgIGxpbmVzOiBudWxsLFxuICAgICAgICBpbnB1dFNpemU6IG51bGwsXG4gICAgICAgIHR5cGU6IEVYUkhlYWRlcjIuY2hhbm5lbHNbMF0ucGl4ZWxUeXBlLFxuICAgICAgICB1bmNvbXByZXNzOiBudWxsLFxuICAgICAgICBnZXR0ZXI6IG51bGwsXG4gICAgICAgIGZvcm1hdDogbnVsbCxcbiAgICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IG51bGxcbiAgICAgIH07XG4gICAgICBzd2l0Y2ggKEVYUkhlYWRlcjIuY29tcHJlc3Npb24pIHtcbiAgICAgICAgY2FzZSBcIk5PX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkFXO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUkxFX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUkxFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWklQU19DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1pJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlpJUF9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NaSVA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQSVpfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDMyO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUElaO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUFhSMjRfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE2O1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzUFhSO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRFdBQV9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMzI7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEV0FCX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAyNTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NEV0E7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IFwiICsgRVhSSGVhZGVyMi5jb21wcmVzc2lvbiArIFwiIGlzIHVuc3VwcG9ydGVkXCI7XG4gICAgICB9XG4gICAgICBFWFJEZWNvZGVyMi5zY2FubGluZUJsb2NrU2l6ZSA9IEVYUkRlY29kZXIyLmxpbmVzO1xuICAgICAgaWYgKEVYUkRlY29kZXIyLnR5cGUgPT0gMSkge1xuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlRmxvYXQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZVVpbnQxNjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IElOVDE2X1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChFWFJEZWNvZGVyMi50eXBlID09IDIpIHtcbiAgICAgICAgc3dpdGNoIChvdXRwdXRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBwYXJzZUZsb2F0MzI7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5nZXR0ZXIgPSBkZWNvZGVGbG9hdDMyO1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gRkxPQVQzMl9TSVpFO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogdW5zdXBwb3J0ZWQgcGl4ZWxUeXBlIFwiICsgRVhSRGVjb2RlcjIudHlwZSArIFwiIGZvciBcIiArIEVYUkhlYWRlcjIuY29tcHJlc3Npb24gKyBcIi5cIjtcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJsb2NrQ291bnQgPSAoRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNYXggKyAxKSAvIEVYUkRlY29kZXIyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBFWFJEZWNvZGVyMi5ibG9ja0NvdW50OyBpKyspXG4gICAgICAgIHBhcnNlSW50NjQoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPSBFWFJEZWNvZGVyMi5jaGFubmVscyA9PSAzID8gNCA6IEVYUkRlY29kZXIyLmNoYW5uZWxzO1xuICAgICAgY29uc3Qgc2l6ZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaGVpZ2h0ICogRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHM7XG4gICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICAgICAgICBpZiAoRVhSRGVjb2RlcjIuY2hhbm5lbHMgPCBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscylcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmJ5dGVBcnJheS5maWxsKDEsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xuICAgICAgICAgIGlmIChFWFJEZWNvZGVyMi5jaGFubmVscyA8IEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5LmZpbGwoMTUzNjAsIDAsIHNpemUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5FWFJMb2FkZXI6IHVuc3VwcG9ydGVkIHR5cGU6IFwiLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLmJ5dGVzUGVyTGluZSA9IEVYUkRlY29kZXIyLndpZHRoICogRVhSRGVjb2RlcjIuaW5wdXRTaXplICogRVhSRGVjb2RlcjIuY2hhbm5lbHM7XG4gICAgICBpZiAoRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMgPT0gNClcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUkdCQUZvcm1hdDtcbiAgICAgIGVsc2VcbiAgICAgICAgRVhSRGVjb2RlcjIuZm9ybWF0ID0gUmVkRm9ybWF0O1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIEVYUkRlY29kZXIyLmNvbG9yU3BhY2UgPSBcInNyZ2ItbGluZWFyXCI7XG4gICAgICBlbHNlXG4gICAgICAgIEVYUkRlY29kZXIyLmVuY29kaW5nID0gM2UzO1xuICAgICAgcmV0dXJuIEVYUkRlY29kZXIyO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXJEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGNvbnN0IHVJbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IG9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBFWFJIZWFkZXIgPSBwYXJzZUhlYWRlcihidWZmZXJEYXRhVmlldywgYnVmZmVyLCBvZmZzZXQpO1xuICAgIGNvbnN0IEVYUkRlY29kZXIgPSBzZXR1cERlY29kZXIoRVhSSGVhZGVyLCBidWZmZXJEYXRhVmlldywgdUludDhBcnJheSwgb2Zmc2V0LCB0aGlzLnR5cGUpO1xuICAgIGNvbnN0IHRtcE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBjaGFubmVsT2Zmc2V0cyA9IHsgUjogMCwgRzogMSwgQjogMiwgQTogMywgWTogMCB9O1xuICAgIGZvciAobGV0IHNjYW5saW5lQmxvY2tJZHggPSAwOyBzY2FubGluZUJsb2NrSWR4IDwgRVhSRGVjb2Rlci5oZWlnaHQgLyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBzY2FubGluZUJsb2NrSWR4KyspIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBwYXJzZVVpbnQzMihidWZmZXJEYXRhVmlldywgb2Zmc2V0KTtcbiAgICAgIEVYUkRlY29kZXIuc2l6ZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgRVhSRGVjb2Rlci5saW5lcyA9IGxpbmUgKyBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplID4gRVhSRGVjb2Rlci5oZWlnaHQgPyBFWFJEZWNvZGVyLmhlaWdodCAtIGxpbmUgOiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgY29uc3QgaXNDb21wcmVzc2VkID0gRVhSRGVjb2Rlci5zaXplIDwgRVhSRGVjb2Rlci5saW5lcyAqIEVYUkRlY29kZXIuYnl0ZXNQZXJMaW5lO1xuICAgICAgY29uc3Qgdmlld2VyID0gaXNDb21wcmVzc2VkID8gRVhSRGVjb2Rlci51bmNvbXByZXNzKEVYUkRlY29kZXIpIDogdW5jb21wcmVzc1JBVyhFWFJEZWNvZGVyKTtcbiAgICAgIG9mZnNldC52YWx1ZSArPSBFWFJEZWNvZGVyLnNpemU7XG4gICAgICBmb3IgKGxldCBsaW5lX3kgPSAwOyBsaW5lX3kgPCBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplOyBsaW5lX3krKykge1xuICAgICAgICBjb25zdCB0cnVlX3kgPSBsaW5lX3kgKyBzY2FubGluZUJsb2NrSWR4ICogRVhSRGVjb2Rlci5zY2FubGluZUJsb2NrU2l6ZTtcbiAgICAgICAgaWYgKHRydWVfeSA+PSBFWFJEZWNvZGVyLmhlaWdodClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZm9yIChsZXQgY2hhbm5lbElEID0gMDsgY2hhbm5lbElEIDwgRVhSRGVjb2Rlci5jaGFubmVsczsgY2hhbm5lbElEKyspIHtcbiAgICAgICAgICBjb25zdCBjT2ZmID0gY2hhbm5lbE9mZnNldHNbRVhSSGVhZGVyLmNoYW5uZWxzW2NoYW5uZWxJRF0ubmFtZV07XG4gICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBFWFJEZWNvZGVyLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgIHRtcE9mZnNldC52YWx1ZSA9IChsaW5lX3kgKiAoRVhSRGVjb2Rlci5jaGFubmVscyAqIEVYUkRlY29kZXIud2lkdGgpICsgY2hhbm5lbElEICogRVhSRGVjb2Rlci53aWR0aCArIHgpICogRVhSRGVjb2Rlci5pbnB1dFNpemU7XG4gICAgICAgICAgICBjb25zdCBvdXRJbmRleCA9IChFWFJEZWNvZGVyLmhlaWdodCAtIDEgLSB0cnVlX3kpICogKEVYUkRlY29kZXIud2lkdGggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzKSArIHggKiBFWFJEZWNvZGVyLm91dHB1dENoYW5uZWxzICsgY09mZjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIuYnl0ZUFycmF5W291dEluZGV4XSA9IEVYUkRlY29kZXIuZ2V0dGVyKHZpZXdlciwgdG1wT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlYWRlcjogRVhSSGVhZGVyLFxuICAgICAgd2lkdGg6IEVYUkRlY29kZXIud2lkdGgsXG4gICAgICBoZWlnaHQ6IEVYUkRlY29kZXIuaGVpZ2h0LFxuICAgICAgZGF0YTogRVhSRGVjb2Rlci5ieXRlQXJyYXksXG4gICAgICBmb3JtYXQ6IEVYUkRlY29kZXIuZm9ybWF0LFxuICAgICAgW2hhc0NvbG9yU3BhY2UgPyBcImNvbG9yU3BhY2VcIiA6IFwiZW5jb2RpbmdcIl06IEVYUkRlY29kZXJbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXSxcbiAgICAgIHR5cGU6IHRoaXMudHlwZVxuICAgIH07XG4gIH1cbiAgc2V0RGF0YVR5cGUodmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2sodGV4dHVyZSwgdGV4RGF0YSkge1xuICAgICAgaWYgKGhhc0NvbG9yU3BhY2UpXG4gICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IHRleERhdGEuY29sb3JTcGFjZTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IHRleERhdGEuZW5jb2Rpbmc7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIGlmIChvbkxvYWQpXG4gICAgICAgIG9uTG9hZCh0ZXh0dXJlLCB0ZXhEYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmxvYWQodXJsLCBvbkxvYWRDYWxsYmFjaywgb25Qcm9ncmVzcywgb25FcnJvcik7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEVYUkxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVYUkxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJEYXRhVGV4dHVyZUxvYWRlciIsIkhhbGZGbG9hdFR5cGUiLCJGbG9hdFR5cGUiLCJSR0JBRm9ybWF0IiwiUmVkRm9ybWF0IiwiTGluZWFyRmlsdGVyIiwiRGF0YVV0aWxzIiwidW56bGliU3luYyIsInZlcnNpb24iLCJoYXNDb2xvclNwYWNlIiwiRVhSTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwidHlwZSIsInBhcnNlIiwiYnVmZmVyIiwiVVNIT1JUX1JBTkdFIiwiQklUTUFQX1NJWkUiLCJIVUZfRU5DQklUUyIsIkhVRl9ERUNCSVRTIiwiSFVGX0VOQ1NJWkUiLCJIVUZfREVDU0laRSIsIkhVRl9ERUNNQVNLIiwiTkJJVFMiLCJBX09GRlNFVCIsIk1PRF9NQVNLIiwiU0hPUlRfWkVST0NPREVfUlVOIiwiTE9OR19aRVJPQ09ERV9SVU4iLCJTSE9SVEVTVF9MT05HX1JVTiIsIlVMT05HX1NJWkUiLCJGTE9BVDMyX1NJWkUiLCJJTlQzMl9TSVpFIiwiSU5UMTZfU0laRSIsIklOVDhfU0laRSIsIlNUQVRJQ19IVUZGTUFOIiwiREVGTEFURSIsIlVOS05PV04iLCJMT1NTWV9EQ1QiLCJSTEUiLCJsb2dCYXNlIiwiTWF0aCIsInBvdyIsInJldmVyc2VMdXRGcm9tQml0bWFwIiwiYml0bWFwIiwibHV0IiwiayIsImkiLCJuIiwiaHVmQ2xlYXJEZWNUYWJsZSIsImhkZWMiLCJsZW4iLCJsaXQiLCJwIiwiZ2V0Qml0c1JldHVybiIsImwiLCJjIiwibGMiLCJnZXRCaXRzIiwibkJpdHMiLCJ1SW50OEFycmF5MiIsImluT2Zmc2V0IiwicGFyc2VVaW50OEFycmF5IiwiaHVmVGFibGVCdWZmZXIiLCJBcnJheSIsImh1ZkNhbm9uaWNhbENvZGVUYWJsZSIsImhjb2RlIiwibmMiLCJodWZVbnBhY2tFbmNUYWJsZSIsImluRGF0YVZpZXciLCJuaSIsImltIiwiaU0iLCJ2YWx1ZSIsInplcnVuIiwiaHVmTGVuZ3RoIiwiY29kZSIsImh1ZkNvZGUiLCJodWZCdWlsZERlY1RhYmxlIiwiaGRlY29kIiwicGwiLCJwbE9mZnNldCIsImdldENoYXJSZXR1cm4iLCJnZXRDaGFyIiwiZ2V0Q29kZVJldHVybiIsImdldENvZGUiLCJwbyIsInJsYyIsIm91dEJ1ZmZlciIsIm91dEJ1ZmZlck9mZnNldCIsIm91dEJ1ZmZlckVuZE9mZnNldCIsImNzIiwiVWludDhBcnJheSIsInMiLCJVSW50MTYiLCJJbnQxNiIsInJlZiIsIndkZWMxNFJldHVybiIsImEiLCJiIiwid2RlYzE0IiwiaCIsImxzIiwiaHMiLCJoaSIsImFpIiwiYXMiLCJicyIsIndkZWMxNiIsIm0iLCJkIiwiYmIiLCJhYSIsIndhdjJEZWNvZGUiLCJidWZmZXIyIiwiaiIsIm54Iiwib3giLCJueSIsIm95IiwibXgiLCJ3MTQiLCJwMiIsInB5IiwiZXkiLCJveTEiLCJveTIiLCJveDEiLCJveDIiLCJpMDAiLCJpMDEiLCJpMTAiLCJpMTEiLCJweCIsImV4IiwicDAxIiwicDEwIiwicDExIiwiaHVmRGVjb2RlIiwiZW5jb2RpbmdUYWJsZSIsImRlY29kaW5nVGFibGUiLCJubyIsIm91dE9mZnNldCIsImluT2Zmc2V0RW5kIiwidHJ1bmMiLCJpbmRleCIsImh1ZlVuY29tcHJlc3MiLCJuQ29tcHJlc3NlZCIsIm5SYXciLCJpbml0aWFsSW5PZmZzZXQiLCJwYXJzZVVpbnQzMiIsImZyZXEiLCJhcHBseUx1dCIsImRhdGEiLCJuRGF0YSIsInByZWRpY3RvciIsInNvdXJjZSIsInQiLCJsZW5ndGgiLCJpbnRlcmxlYXZlU2NhbGFyIiwib3V0IiwidDEiLCJ0MiIsImZsb29yIiwic3RvcCIsImRlY29kZVJ1bkxlbmd0aCIsInNpemUiLCJieXRlTGVuZ3RoIiwicmVhZGVyIiwiRGF0YVZpZXciLCJnZXRJbnQ4IiwiY291bnQiLCJwdXNoIiwiZ2V0VWludDgiLCJsb3NzeURjdERlY29kZSIsImNzY1NldCIsInJvd1B0cnMiLCJjaGFubmVsRGF0YSIsImFjQnVmZmVyIiwiZGNCdWZmZXIiLCJkYXRhVmlldyIsIndpZHRoIiwiaWR4IiwiaGVpZ2h0IiwibnVtQ29tcCIsIm51bUZ1bGxCbG9ja3NYIiwibnVtQmxvY2tzWCIsImNlaWwiLCJudW1CbG9ja3NZIiwibGVmdG92ZXJYIiwibGVmdG92ZXJZIiwiY3VyckFjQ29tcCIsImN1cnJEY0NvbXAiLCJkY3REYXRhIiwiaGFsZlppZ0Jsb2NrIiwicm93QmxvY2siLCJyb3dPZmZzZXRzIiwiY29tcDIiLCJGbG9hdDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImJsb2NreSIsIm1heFkiLCJtYXhYIiwiYmxvY2t4IiwiZmlsbCIsInVuUmxlQUMiLCJ1blppZ1phZyIsImRjdEludmVyc2UiLCJjc2M3MDlJbnZlcnNlIiwiY29udmVydFRvSGFsZiIsIm9mZnNldDIiLCJ0eXBlMiIsInkyIiwic3JjIiwic2V0VWludDE2Iiwib2Zmc2V0MyIsIngyIiwiaGFsZlJvdyIsImNvbXAiLCJkZWNvZGVkIiwieSIsIngiLCJnZXRVaW50MTYiLCJzZXRGbG9hdDMyIiwiZGVjb2RlRmxvYXQxNiIsImFjVmFsdWUiLCJkY3RDb21wIiwiZHN0IiwiY29zIiwiZSIsImYiLCJnIiwiYWxwaGEiLCJiZXRhIiwidGhldGEiLCJnYW1tYSIsInJvdyIsInJvd1B0ciIsImNvbHVtbiIsImNiIiwiY3IiLCJ0b0hhbGZGbG9hdCIsInRvTGluZWFyIiwiZmxvYXQiLCJzaWduIiwiYWJzIiwidW5jb21wcmVzc1JBVyIsImluZm8iLCJhcnJheSIsIm9mZnNldCIsInVuY29tcHJlc3NSTEUiLCJjb21wcmVzc2VkIiwidmlld2VyIiwic2xpY2UiLCJyYXdCdWZmZXIiLCJ0bXBCdWZmZXIiLCJ1bmNvbXByZXNzWklQIiwidW5jb21wcmVzc1BJWiIsInNjYW5saW5lQmxvY2tTaXplIiwiY2hhbm5lbHMiLCJvdXRCdWZmZXJFbmQiLCJwaXpDaGFubmVsRGF0YSIsImxpbmVzIiwibWluTm9uWmVybyIsInBhcnNlVWludDE2IiwibWF4Tm9uWmVybyIsInBhcnNlVWludDgiLCJtYXhWYWx1ZSIsImNkIiwic3RhcnQiLCJ0bXBPZmZzZXQyIiwiY3AiLCJlbmQiLCJzZXQiLCJ1bmNvbXByZXNzUFhSIiwic3oiLCJVaW50MzJBcnJheSIsInRtcEJ1ZmZlckVuZCIsIndyaXRlUHRyIiwicHRyIiwicGl4ZWwiLCJkaWZmIiwidW5jb21wcmVzc0RXQSIsImR3YUhlYWRlciIsInBhcnNlSW50NjQiLCJ1bmtub3duVW5jb21wcmVzc2VkU2l6ZSIsInVua25vd25Db21wcmVzc2VkU2l6ZSIsImFjQ29tcHJlc3NlZFNpemUiLCJkY0NvbXByZXNzZWRTaXplIiwicmxlQ29tcHJlc3NlZFNpemUiLCJybGVVbmNvbXByZXNzZWRTaXplIiwicmxlUmF3U2l6ZSIsInRvdGFsQWNVbmNvbXByZXNzZWRDb3VudCIsInRvdGFsRGNVbmNvbXByZXNzZWRDb3VudCIsImFjQ29tcHJlc3Npb24iLCJFWFJIZWFkZXIiLCJjb21wcmVzc2lvbiIsImNoYW5uZWxSdWxlcyIsInJ1bGVTaXplIiwibmFtZSIsInBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmciLCJjc2MiLCJJbnQ4QXJyYXkiLCJjaGFubmVsIiwicGl4ZWxUeXBlIiwicExpbmVhciIsInJ1bGUiLCJ6bGliSW5mbyIsInJsZUJ1ZmZlciIsImNoYW4iLCJybGVPZmZzZXQiLCJyb3dPZmZzZXRCeXRlcyIsImJ5dGUiLCJ1aW50QnVmZmVyIiwiZW5kT2Zmc2V0Iiwic3RyaW5nVmFsdWUiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInBhcnNlRml4ZWRMZW5ndGhTdHJpbmciLCJwYXJzZVJhdGlvbmFsIiwicGFyc2VJbnQzMiIsInBhcnNlVGltZWNvZGUiLCJJbnQzMiIsImdldEludDMyIiwiVWludDMyIiwiZ2V0VWludDMyIiwiVWludDgiLCJpbnQiLCJwcm90b3R5cGUiLCJOdW1iZXIiLCJnZXRCaWdJbnQ2NCIsInBhcnNlRmxvYXQzMiIsImdldEZsb2F0MzIiLCJkZWNvZGVGbG9hdDMyIiwiYmluYXJ5IiwiZXhwb25lbnQiLCJmcmFjdGlvbiIsIk5hTiIsIkluZmluaXR5IiwiVWludDE2IiwicGFyc2VGbG9hdDE2IiwicGFyc2VDaGxpc3QiLCJzdGFydE9mZnNldCIsInhTYW1wbGluZyIsInlTYW1wbGluZyIsInBhcnNlQ2hyb21hdGljaXRpZXMiLCJyZWRYIiwicmVkWSIsImdyZWVuWCIsImdyZWVuWSIsImJsdWVYIiwiYmx1ZVkiLCJ3aGl0ZVgiLCJ3aGl0ZVkiLCJwYXJzZUNvbXByZXNzaW9uIiwiY29tcHJlc3Npb25Db2RlcyIsInBhcnNlQm94MmkiLCJ4TWluIiwieU1pbiIsInhNYXgiLCJ5TWF4IiwicGFyc2VMaW5lT3JkZXIiLCJsaW5lT3JkZXJzIiwibGluZU9yZGVyIiwicGFyc2VWMmYiLCJwYXJzZVYzZiIsInoiLCJwYXJzZVZhbHVlIiwicGFyc2VIZWFkZXIiLCJFWFJIZWFkZXIyIiwic3BlYyIsInNpbmdsZVRpbGUiLCJsb25nTmFtZSIsImRlZXBGb3JtYXQiLCJtdWx0aVBhcnQiLCJrZWVwUmVhZGluZyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVUeXBlIiwiYXR0cmlidXRlU2l6ZSIsImF0dHJpYnV0ZVZhbHVlIiwiY29uc29sZSIsIndhcm4iLCJlcnJvciIsInNldHVwRGVjb2RlciIsIm91dHB1dFR5cGUiLCJFWFJEZWNvZGVyMiIsImRhdGFXaW5kb3ciLCJieXRlc1BlckxpbmUiLCJpbnB1dFNpemUiLCJ1bmNvbXByZXNzIiwiZ2V0dGVyIiwiZm9ybWF0IiwiYmxvY2tDb3VudCIsIm91dHB1dENoYW5uZWxzIiwiYnl0ZUFycmF5IiwiY29sb3JTcGFjZSIsImVuY29kaW5nIiwiYnVmZmVyRGF0YVZpZXciLCJ1SW50OEFycmF5IiwiRVhSRGVjb2RlciIsInRtcE9mZnNldCIsImNoYW5uZWxPZmZzZXRzIiwiUiIsIkciLCJCIiwiQSIsIlkiLCJzY2FubGluZUJsb2NrSWR4IiwibGluZSIsImlzQ29tcHJlc3NlZCIsImxpbmVfeSIsInRydWVfeSIsImNoYW5uZWxJRCIsImNPZmYiLCJvdXRJbmRleCIsImhlYWRlciIsInNldERhdGFUeXBlIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwib25Mb2FkQ2FsbGJhY2siLCJ0ZXh0dXJlIiwidGV4RGF0YSIsIm1pbkZpbHRlciIsIm1hZ0ZpbHRlciIsImdlbmVyYXRlTWlwbWFwcyIsImZsaXBZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/GLTFLoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GLTFLoader: () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferGeometryUtils.js */ \"(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n/* harmony import */ var _polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/LoaderUtils.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/LoaderUtils.js\");\n\n\n\n\nconst SRGBColorSpace = \"srgb\";\nconst LinearSRGBColorSpace = \"srgb-linear\";\nconst sRGBEncoding = 3001;\nconst LinearEncoding = 3e3;\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(manager){\n        super(manager);\n        this.dracoLoader = null;\n        this.ktx2Loader = null;\n        this.meshoptDecoder = null;\n        this.pluginCallbacks = [];\n        this.register(function(parser) {\n            return new GLTFMaterialsClearcoatExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsDispersionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureBasisUExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureWebPExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFTextureAVIFExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSheenExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsTransmissionExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsVolumeExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIorExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsEmissiveStrengthExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsSpecularExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsIridescenceExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsAnisotropyExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMaterialsBumpExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFLightsExtension(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshoptCompression(parser);\n        });\n        this.register(function(parser) {\n            return new GLTFMeshGpuInstancing(parser);\n        });\n    }\n    load(url, onLoad, onProgress, onError) {\n        const scope = this;\n        let resourcePath;\n        if (this.resourcePath !== \"\") {\n            resourcePath = this.resourcePath;\n        } else if (this.path !== \"\") {\n            const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path);\n        } else {\n            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n        }\n        this.manager.itemStart(url);\n        const _onError = function(e) {\n            if (onError) {\n                onError(e);\n            } else {\n                console.error(e);\n            }\n            scope.manager.itemError(url);\n            scope.manager.itemEnd(url);\n        };\n        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n        loader.setPath(this.path);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setWithCredentials(this.withCredentials);\n        loader.load(url, function(data) {\n            try {\n                scope.parse(data, resourcePath, function(gltf) {\n                    onLoad(gltf);\n                    scope.manager.itemEnd(url);\n                }, _onError);\n            } catch (e) {\n                _onError(e);\n            }\n        }, onProgress, _onError);\n    }\n    setDRACOLoader(dracoLoader) {\n        this.dracoLoader = dracoLoader;\n        return this;\n    }\n    setDDSLoader() {\n        throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n    }\n    setKTX2Loader(ktx2Loader) {\n        this.ktx2Loader = ktx2Loader;\n        return this;\n    }\n    setMeshoptDecoder(meshoptDecoder) {\n        this.meshoptDecoder = meshoptDecoder;\n        return this;\n    }\n    register(callback) {\n        if (this.pluginCallbacks.indexOf(callback) === -1) {\n            this.pluginCallbacks.push(callback);\n        }\n        return this;\n    }\n    unregister(callback) {\n        if (this.pluginCallbacks.indexOf(callback) !== -1) {\n            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n        }\n        return this;\n    }\n    parse(data, path, onLoad, onError) {\n        let json;\n        const extensions = {};\n        const plugins = {};\n        if (typeof data === \"string\") {\n            json = JSON.parse(data);\n        } else if (data instanceof ArrayBuffer) {\n            const magic = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4)));\n            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n                try {\n                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n                } catch (error) {\n                    if (onError) onError(error);\n                    return;\n                }\n                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);\n            } else {\n                json = JSON.parse((0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data)));\n            }\n        } else {\n            json = data;\n        }\n        if (json.asset === void 0 || json.asset.version[0] < 2) {\n            if (onError) onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n            return;\n        }\n        const parser = new GLTFParser(json, {\n            path: path || this.resourcePath || \"\",\n            crossOrigin: this.crossOrigin,\n            requestHeader: this.requestHeader,\n            manager: this.manager,\n            ktx2Loader: this.ktx2Loader,\n            meshoptDecoder: this.meshoptDecoder\n        });\n        parser.fileLoader.setRequestHeader(this.requestHeader);\n        for(let i = 0; i < this.pluginCallbacks.length; i++){\n            const plugin = this.pluginCallbacks[i](parser);\n            if (!plugin.name) console.error(\"THREE.GLTFLoader: Invalid plugin found: missing name\");\n            plugins[plugin.name] = plugin;\n            extensions[plugin.name] = true;\n        }\n        if (json.extensionsUsed) {\n            for(let i = 0; i < json.extensionsUsed.length; ++i){\n                const extensionName = json.extensionsUsed[i];\n                const extensionsRequired = json.extensionsRequired || [];\n                switch(extensionName){\n                    case EXTENSIONS.KHR_MATERIALS_UNLIT:\n                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n                        break;\n                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n                        break;\n                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n                        extensions[extensionName] = new GLTFTextureTransformExtension();\n                        break;\n                    case EXTENSIONS.KHR_MESH_QUANTIZATION:\n                        extensions[extensionName] = new GLTFMeshQuantizationExtension();\n                        break;\n                    default:\n                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n                            console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n                        }\n                }\n            }\n        }\n        parser.setExtensions(extensions);\n        parser.setPlugins(plugins);\n        parser.parse(onLoad, onError);\n    }\n    parseAsync(data, path) {\n        const scope = this;\n        return new Promise(function(resolve, reject) {\n            scope.parse(data, path, resolve, reject);\n        });\n    }\n}\nfunction GLTFRegistry() {\n    let objects = {};\n    return {\n        get: function(key) {\n            return objects[key];\n        },\n        add: function(key, object) {\n            objects[key] = object;\n        },\n        remove: function(key) {\n            delete objects[key];\n        },\n        removeAll: function() {\n            objects = {};\n        }\n    };\n}\nconst EXTENSIONS = {\n    KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n    KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n    KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n    KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n    KHR_MATERIALS_DISPERSION: \"KHR_materials_dispersion\",\n    KHR_MATERIALS_IOR: \"KHR_materials_ior\",\n    KHR_MATERIALS_SHEEN: \"KHR_materials_sheen\",\n    KHR_MATERIALS_SPECULAR: \"KHR_materials_specular\",\n    KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n    KHR_MATERIALS_IRIDESCENCE: \"KHR_materials_iridescence\",\n    KHR_MATERIALS_ANISOTROPY: \"KHR_materials_anisotropy\",\n    KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n    KHR_MATERIALS_VOLUME: \"KHR_materials_volume\",\n    KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n    KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n    KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n    KHR_MATERIALS_EMISSIVE_STRENGTH: \"KHR_materials_emissive_strength\",\n    EXT_MATERIALS_BUMP: \"EXT_materials_bump\",\n    EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n    EXT_TEXTURE_AVIF: \"EXT_texture_avif\",\n    EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\n    EXT_MESH_GPU_INSTANCING: \"EXT_mesh_gpu_instancing\"\n};\nclass GLTFLightsExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n        this.cache = {\n            refs: {},\n            uses: {}\n        };\n    }\n    _markDefs() {\n        const parser = this.parser;\n        const nodeDefs = this.parser.json.nodes || [];\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n            }\n        }\n    }\n    _loadLight(lightIndex) {\n        const parser = this.parser;\n        const cacheKey = \"light:\" + lightIndex;\n        let dependency = parser.cache.get(cacheKey);\n        if (dependency) return dependency;\n        const json = parser.json;\n        const extensions = json.extensions && json.extensions[this.name] || {};\n        const lightDefs = extensions.lights || [];\n        const lightDef = lightDefs[lightIndex];\n        let lightNode;\n        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n        if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);\n        const range = lightDef.range !== void 0 ? lightDef.range : 0;\n        switch(lightDef.type){\n            case \"directional\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            case \"point\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n                lightNode.distance = range;\n                break;\n            case \"spot\":\n                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n                lightNode.distance = range;\n                lightDef.spot = lightDef.spot || {};\n                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n                lightNode.angle = lightDef.spot.outerConeAngle;\n                lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n                lightNode.target.position.set(0, 0, -1);\n                lightNode.add(lightNode.target);\n                break;\n            default:\n                throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n        }\n        lightNode.position.set(0, 0, 0);\n        lightNode.decay = 2;\n        assignExtrasToUserData(lightNode, lightDef);\n        if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;\n        lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n        dependency = Promise.resolve(lightNode);\n        parser.cache.add(cacheKey, dependency);\n        return dependency;\n    }\n    getDependency(type, index) {\n        if (type !== \"light\") return;\n        return this._loadLight(index);\n    }\n    createNodeAttachment(nodeIndex) {\n        const self2 = this;\n        const parser = this.parser;\n        const json = parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n        const lightIndex = lightDef.light;\n        if (lightIndex === void 0) return null;\n        return this._loadLight(lightIndex).then(function(light) {\n            return parser._getNodeRef(self2.cache, lightIndex, light);\n        });\n    }\n}\nclass GLTFMaterialsUnlitExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n    }\n    extendParams(materialParams, materialDef, parser) {\n        const pending = [];\n        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n        materialParams.opacity = 1;\n        const metallicRoughness = materialDef.pbrMetallicRoughness;\n        if (metallicRoughness) {\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsEmissiveStrengthExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;\n        if (emissiveStrength !== void 0) {\n            materialParams.emissiveIntensity = emissiveStrength;\n        }\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsClearcoatExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.clearcoatFactor !== void 0) {\n            materialParams.clearcoat = extension.clearcoatFactor;\n        }\n        if (extension.clearcoatTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n        }\n        if (extension.clearcoatRoughnessFactor !== void 0) {\n            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n        }\n        if (extension.clearcoatRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n        }\n        if (extension.clearcoatNormalTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n            if (extension.clearcoatNormalTexture.scale !== void 0) {\n                const scale = extension.clearcoatNormalTexture.scale;\n                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale);\n            }\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsDispersionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsIridescenceExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.iridescenceFactor !== void 0) {\n            materialParams.iridescence = extension.iridescenceFactor;\n        }\n        if (extension.iridescenceTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceMap\", extension.iridescenceTexture));\n        }\n        if (extension.iridescenceIor !== void 0) {\n            materialParams.iridescenceIOR = extension.iridescenceIor;\n        }\n        if (materialParams.iridescenceThicknessRange === void 0) {\n            materialParams.iridescenceThicknessRange = [\n                100,\n                400\n            ];\n        }\n        if (extension.iridescenceThicknessMinimum !== void 0) {\n            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;\n        }\n        if (extension.iridescenceThicknessMaximum !== void 0) {\n            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;\n        }\n        if (extension.iridescenceThicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"iridescenceThicknessMap\", extension.iridescenceThicknessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsSheenExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n        materialParams.sheenRoughness = 0;\n        materialParams.sheen = 1;\n        const extension = materialDef.extensions[this.name];\n        if (extension.sheenColorFactor !== void 0) {\n            const colorFactor = extension.sheenColorFactor;\n            materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);\n        }\n        if (extension.sheenRoughnessFactor !== void 0) {\n            materialParams.sheenRoughness = extension.sheenRoughnessFactor;\n        }\n        if (extension.sheenColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenColorMap\", extension.sheenColorTexture, SRGBColorSpace));\n        }\n        if (extension.sheenRoughnessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"sheenRoughnessMap\", extension.sheenRoughnessTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsTransmissionExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.transmissionFactor !== void 0) {\n            materialParams.transmission = extension.transmissionFactor;\n        }\n        if (extension.transmissionTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsVolumeExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;\n        if (extension.thicknessTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"thicknessMap\", extension.thicknessTexture));\n        }\n        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n        const colorArray = extension.attenuationColor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsIorExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_IOR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const extension = materialDef.extensions[this.name];\n        materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;\n        return Promise.resolve();\n    }\n}\nclass GLTFMaterialsSpecularExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;\n        if (extension.specularTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularIntensityMap\", extension.specularTexture));\n        }\n        const colorArray = extension.specularColorFactor || [\n            1,\n            1,\n            1\n        ];\n        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);\n        if (extension.specularColorTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"specularColorMap\", extension.specularColorTexture, SRGBColorSpace));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsBumpExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;\n        if (extension.bumpTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"bumpMap\", extension.bumpTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFMaterialsAnisotropyExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n    }\n    getMaterialType(materialIndex) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n    }\n    extendMaterialParams(materialIndex, materialParams) {\n        const parser = this.parser;\n        const materialDef = parser.json.materials[materialIndex];\n        if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n            return Promise.resolve();\n        }\n        const pending = [];\n        const extension = materialDef.extensions[this.name];\n        if (extension.anisotropyStrength !== void 0) {\n            materialParams.anisotropy = extension.anisotropyStrength;\n        }\n        if (extension.anisotropyRotation !== void 0) {\n            materialParams.anisotropyRotation = extension.anisotropyRotation;\n        }\n        if (extension.anisotropyTexture !== void 0) {\n            pending.push(parser.assignTexture(materialParams, \"anisotropyMap\", extension.anisotropyTexture));\n        }\n        return Promise.all(pending);\n    }\n}\nclass GLTFTextureBasisUExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n    }\n    loadTexture(textureIndex) {\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[this.name];\n        const loader = parser.options.ktx2Loader;\n        if (!loader) {\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n            } else {\n                return null;\n            }\n        }\n        return parser.loadTextureImage(textureIndex, extension.source, loader);\n    }\n}\nclass GLTFTextureWebPExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFTextureAVIFExtension {\n    constructor(parser){\n        this.parser = parser;\n        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n        this.isSupported = null;\n    }\n    loadTexture(textureIndex) {\n        const name = this.name;\n        const parser = this.parser;\n        const json = parser.json;\n        const textureDef = json.textures[textureIndex];\n        if (!textureDef.extensions || !textureDef.extensions[name]) {\n            return null;\n        }\n        const extension = textureDef.extensions[name];\n        const source = json.images[extension.source];\n        let loader = parser.textureLoader;\n        if (source.uri) {\n            const handler = parser.options.manager.getHandler(source.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.detectSupport().then(function(isSupported) {\n            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);\n            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n                throw new Error(\"THREE.GLTFLoader: AVIF required by asset but unsupported.\");\n            }\n            return parser.loadTexture(textureIndex);\n        });\n    }\n    detectSupport() {\n        if (!this.isSupported) {\n            this.isSupported = new Promise(function(resolve) {\n                const image = new Image();\n                image.src = \"data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=\";\n                image.onload = image.onerror = function() {\n                    resolve(image.height === 1);\n                };\n            });\n        }\n        return this.isSupported;\n    }\n}\nclass GLTFMeshoptCompression {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n        this.parser = parser;\n    }\n    loadBufferView(index) {\n        const json = this.parser.json;\n        const bufferView = json.bufferViews[index];\n        if (bufferView.extensions && bufferView.extensions[this.name]) {\n            const extensionDef = bufferView.extensions[this.name];\n            const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n            const decoder = this.parser.options.meshoptDecoder;\n            if (!decoder || !decoder.supported) {\n                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n                    throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n                } else {\n                    return null;\n                }\n            }\n            return buffer.then(function(res) {\n                const byteOffset = extensionDef.byteOffset || 0;\n                const byteLength = extensionDef.byteLength || 0;\n                const count = extensionDef.count;\n                const stride = extensionDef.byteStride;\n                const source = new Uint8Array(res, byteOffset, byteLength);\n                if (decoder.decodeGltfBufferAsync) {\n                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {\n                        return res2.buffer;\n                    });\n                } else {\n                    return decoder.ready.then(function() {\n                        const result = new ArrayBuffer(count * stride);\n                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n                        return result;\n                    });\n                }\n            });\n        } else {\n            return null;\n        }\n    }\n}\nclass GLTFMeshGpuInstancing {\n    constructor(parser){\n        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n        this.parser = parser;\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.parser.json;\n        const nodeDef = json.nodes[nodeIndex];\n        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {\n            return null;\n        }\n        const meshDef = json.meshes[nodeDef.mesh];\n        for (const primitive of meshDef.primitives){\n            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {\n                return null;\n            }\n        }\n        const extensionDef = nodeDef.extensions[this.name];\n        const attributesDef = extensionDef.attributes;\n        const pending = [];\n        const attributes = {};\n        for(const key in attributesDef){\n            pending.push(this.parser.getDependency(\"accessor\", attributesDef[key]).then((accessor)=>{\n                attributes[key] = accessor;\n                return attributes[key];\n            }));\n        }\n        if (pending.length < 1) {\n            return null;\n        }\n        pending.push(this.parser.createNodeMesh(nodeIndex));\n        return Promise.all(pending).then((results)=>{\n            const nodeObject = results.pop();\n            const meshes = nodeObject.isGroup ? nodeObject.children : [\n                nodeObject\n            ];\n            const count = results[0].count;\n            const instancedMeshes = [];\n            for (const mesh of meshes){\n                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);\n                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);\n                for(let i = 0; i < count; i++){\n                    if (attributes.TRANSLATION) {\n                        p.fromBufferAttribute(attributes.TRANSLATION, i);\n                    }\n                    if (attributes.ROTATION) {\n                        q.fromBufferAttribute(attributes.ROTATION, i);\n                    }\n                    if (attributes.SCALE) {\n                        s.fromBufferAttribute(attributes.SCALE, i);\n                    }\n                    instancedMesh.setMatrixAt(i, m.compose(p, q, s));\n                }\n                for(const attributeName in attributes){\n                    if (attributeName === \"_COLOR_0\") {\n                        const attr = attributes[attributeName];\n                        instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);\n                    } else if (attributeName !== \"TRANSLATION\" && attributeName !== \"ROTATION\" && attributeName !== \"SCALE\") {\n                        mesh.geometry.setAttribute(attributeName, attributes[attributeName]);\n                    }\n                }\n                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);\n                this.parser.assignFinalMaterial(instancedMesh);\n                instancedMeshes.push(instancedMesh);\n            }\n            if (nodeObject.isGroup) {\n                nodeObject.clear();\n                nodeObject.add(...instancedMeshes);\n                return nodeObject;\n            }\n            return instancedMeshes[0];\n        });\n    }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 1313821514,\n    BIN: 5130562\n};\nclass GLTFBinaryExtension {\n    constructor(data){\n        this.name = EXTENSIONS.KHR_BINARY_GLTF;\n        this.content = null;\n        this.body = null;\n        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n        this.header = {\n            magic: (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(new Uint8Array(data.slice(0, 4))),\n            version: headerView.getUint32(4, true),\n            length: headerView.getUint32(8, true)\n        };\n        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n            throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n        } else if (this.header.version < 2) {\n            throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n        }\n        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n        let chunkIndex = 0;\n        while(chunkIndex < chunkContentsLength){\n            const chunkLength = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            const chunkType = chunkView.getUint32(chunkIndex, true);\n            chunkIndex += 4;\n            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n                this.content = (0,_polyfill_LoaderUtils_js__WEBPACK_IMPORTED_MODULE_1__.decodeText)(contentArray);\n            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n                this.body = data.slice(byteOffset, byteOffset + chunkLength);\n            }\n            chunkIndex += chunkLength;\n        }\n        if (this.content === null) {\n            throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n        }\n    }\n}\nclass GLTFDracoMeshCompressionExtension {\n    constructor(json, dracoLoader){\n        if (!dracoLoader) {\n            throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n        }\n        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n        this.json = json;\n        this.dracoLoader = dracoLoader;\n        this.dracoLoader.preload();\n    }\n    decodePrimitive(primitive, parser) {\n        const json = this.json;\n        const dracoLoader = this.dracoLoader;\n        const bufferViewIndex = primitive.extensions[this.name].bufferView;\n        const gltfAttributeMap = primitive.extensions[this.name].attributes;\n        const threeAttributeMap = {};\n        const attributeNormalizedMap = {};\n        const attributeTypeMap = {};\n        for(const attributeName in gltfAttributeMap){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n        }\n        for(const attributeName in primitive.attributes){\n            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n            if (gltfAttributeMap[attributeName] !== void 0) {\n                const accessorDef = json.accessors[primitive.attributes[attributeName]];\n                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n                attributeTypeMap[threeAttributeName] = componentType.name;\n                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n            }\n        }\n        return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n            return new Promise(function(resolve, reject) {\n                dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n                    for(const attributeName in geometry.attributes){\n                        const attribute = geometry.attributes[attributeName];\n                        const normalized = attributeNormalizedMap[attributeName];\n                        if (normalized !== void 0) attribute.normalized = normalized;\n                    }\n                    resolve(geometry);\n                }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);\n            });\n        });\n    }\n}\nclass GLTFTextureTransformExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n    }\n    extendTexture(texture, transform) {\n        if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {\n            return texture;\n        }\n        texture = texture.clone();\n        if (transform.texCoord !== void 0) {\n            texture.channel = transform.texCoord;\n        }\n        if (transform.offset !== void 0) {\n            texture.offset.fromArray(transform.offset);\n        }\n        if (transform.rotation !== void 0) {\n            texture.rotation = transform.rotation;\n        }\n        if (transform.scale !== void 0) {\n            texture.repeat.fromArray(transform.scale);\n        }\n        texture.needsUpdate = true;\n        return texture;\n    }\n}\nclass GLTFMeshQuantizationExtension {\n    constructor(){\n        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n    }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer){\n        super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    }\n    copySampleValue_(index) {\n        const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n        for(let i = 0; i !== valueSize; i++){\n            result[i] = values[offset + i];\n        }\n        return result;\n    }\n    interpolate_(i1, t0, t, t1) {\n        const result = this.resultBuffer;\n        const values = this.sampleValues;\n        const stride = this.valueSize;\n        const stride2 = stride * 2;\n        const stride3 = stride * 3;\n        const td = t1 - t0;\n        const p = (t - t0) / td;\n        const pp = p * p;\n        const ppp = pp * p;\n        const offset1 = i1 * stride3;\n        const offset0 = offset1 - stride3;\n        const s2 = -2 * ppp + 3 * pp;\n        const s3 = ppp - pp;\n        const s0 = 1 - s2;\n        const s1 = s3 - pp + p;\n        for(let i = 0; i !== stride; i++){\n            const p0 = values[offset0 + i + stride];\n            const m0 = values[offset0 + i + stride2] * td;\n            const p1 = values[offset1 + i + stride];\n            const m1 = values[offset1 + i] * td;\n            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n        }\n        return result;\n    }\n}\nconst _q = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n    interpolate_(i1, t0, t, t1) {\n        const result = super.interpolate_(i1, t0, t, t1);\n        _q.fromArray(result).normalize().toArray(result);\n        return result;\n    }\n}\nconst WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16\n};\nconst ATTRIBUTES = {\n    POSITION: \"position\",\n    NORMAL: \"normal\",\n    TANGENT: \"tangent\",\n    // uv => uv1, 4 uv channels\n    // https://github.com/mrdoob/three.js/pull/25943\n    // https://github.com/mrdoob/three.js/pull/25788\n    ..._polyfill_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 152 ? {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv1\",\n        TEXCOORD_2: \"uv2\",\n        TEXCOORD_3: \"uv3\"\n    } : {\n        TEXCOORD_0: \"uv\",\n        TEXCOORD_1: \"uv2\"\n    },\n    COLOR_0: \"color\",\n    WEIGHTS_0: \"skinWeight\",\n    JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n    scale: \"scale\",\n    translation: \"position\",\n    rotation: \"quaternion\",\n    weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n    CUBICSPLINE: void 0,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n    OPAQUE: \"OPAQUE\",\n    MASK: \"MASK\",\n    BLEND: \"BLEND\"\n};\nfunction createDefaultMaterial(cache) {\n    if (cache[\"DefaultMaterial\"] === void 0) {\n        cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n            color: 16777215,\n            emissive: 0,\n            metalness: 1,\n            roughness: 1,\n            transparent: false,\n            depthTest: true,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n        });\n    }\n    return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    for(const name in objectDef.extensions){\n        if (knownExtensions[name] === void 0) {\n            object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n            object.userData.gltfExtensions[name] = objectDef.extensions[name];\n        }\n    }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== void 0) {\n        if (typeof gltfDef.extras === \"object\") {\n            Object.assign(object.userData, gltfDef.extras);\n        } else {\n            console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n        }\n    }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n    let hasMorphPosition = false;\n    let hasMorphNormal = false;\n    let hasMorphColor = false;\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (target.POSITION !== void 0) hasMorphPosition = true;\n        if (target.NORMAL !== void 0) hasMorphNormal = true;\n        if (target.COLOR_0 !== void 0) hasMorphColor = true;\n        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;\n    }\n    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);\n    const pendingPositionAccessors = [];\n    const pendingNormalAccessors = [];\n    const pendingColorAccessors = [];\n    for(let i = 0, il = targets.length; i < il; i++){\n        const target = targets[i];\n        if (hasMorphPosition) {\n            const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n            pendingPositionAccessors.push(pendingAccessor);\n        }\n        if (hasMorphNormal) {\n            const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n            pendingNormalAccessors.push(pendingAccessor);\n        }\n        if (hasMorphColor) {\n            const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency(\"accessor\", target.COLOR_0) : geometry.attributes.color;\n            pendingColorAccessors.push(pendingAccessor);\n        }\n    }\n    return Promise.all([\n        Promise.all(pendingPositionAccessors),\n        Promise.all(pendingNormalAccessors),\n        Promise.all(pendingColorAccessors)\n    ]).then(function(accessors) {\n        const morphPositions = accessors[0];\n        const morphNormals = accessors[1];\n        const morphColors = accessors[2];\n        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n        if (hasMorphColor) geometry.morphAttributes.color = morphColors;\n        geometry.morphTargetsRelative = true;\n        return geometry;\n    });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n    if (meshDef.weights !== void 0) {\n        for(let i = 0, il = meshDef.weights.length; i < il; i++){\n            mesh.morphTargetInfluences[i] = meshDef.weights[i];\n        }\n    }\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n        const targetNames = meshDef.extras.targetNames;\n        if (mesh.morphTargetInfluences.length === targetNames.length) {\n            mesh.morphTargetDictionary = {};\n            for(let i = 0, il = targetNames.length; i < il; i++){\n                mesh.morphTargetDictionary[targetNames[i]] = i;\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n        }\n    }\n}\nfunction createPrimitiveKey(primitiveDef) {\n    let geometryKey;\n    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    if (dracoExtension) {\n        geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n    } else {\n        geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n    }\n    if (primitiveDef.targets !== void 0) {\n        for(let i = 0, il = primitiveDef.targets.length; i < il; i++){\n            geometryKey += \":\" + createAttributesKey(primitiveDef.targets[i]);\n        }\n    }\n    return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n    let attributesKey = \"\";\n    const keys = Object.keys(attributes).sort();\n    for(let i = 0, il = keys.length; i < il; i++){\n        attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n    }\n    return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n    switch(constructor){\n        case Int8Array:\n            return 1 / 127;\n        case Uint8Array:\n            return 1 / 255;\n        case Int16Array:\n            return 1 / 32767;\n        case Uint16Array:\n            return 1 / 65535;\n        default:\n            throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n    }\n}\nfunction getImageURIMimeType(uri) {\n    if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return \"image/jpeg\";\n    if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return \"image/webp\";\n    return \"image/png\";\n}\nconst _identityMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nclass GLTFParser {\n    constructor(json = {}, options = {}){\n        this.json = json;\n        this.extensions = {};\n        this.plugins = {};\n        this.options = options;\n        this.cache = new GLTFRegistry();\n        this.associations = /* @__PURE__ */ new Map();\n        this.primitiveCache = {};\n        this.nodeCache = {};\n        this.meshCache = {\n            refs: {},\n            uses: {}\n        };\n        this.cameraCache = {\n            refs: {},\n            uses: {}\n        };\n        this.lightCache = {\n            refs: {},\n            uses: {}\n        };\n        this.sourceCache = {};\n        this.textureCache = {};\n        this.nodeNamesUsed = {};\n        let isSafari = false;\n        let isFirefox = false;\n        let firefoxVersion = -1;\n        if (typeof navigator !== \"undefined\" && typeof navigator.userAgent !== \"undefined\") {\n            isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;\n            isFirefox = navigator.userAgent.indexOf(\"Firefox\") > -1;\n            firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1;\n        }\n        if (typeof createImageBitmap === \"undefined\" || isSafari || isFirefox && firefoxVersion < 98) {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n        } else {\n            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n        }\n        this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n        this.textureLoader.setRequestHeader(this.options.requestHeader);\n        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n        this.fileLoader.setResponseType(\"arraybuffer\");\n        if (this.options.crossOrigin === \"use-credentials\") {\n            this.fileLoader.setWithCredentials(true);\n        }\n    }\n    setExtensions(extensions) {\n        this.extensions = extensions;\n    }\n    setPlugins(plugins) {\n        this.plugins = plugins;\n    }\n    parse(onLoad, onError) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        this.cache.removeAll();\n        this.nodeCache = {};\n        this._invokeAll(function(ext) {\n            return ext._markDefs && ext._markDefs();\n        });\n        Promise.all(this._invokeAll(function(ext) {\n            return ext.beforeRoot && ext.beforeRoot();\n        })).then(function() {\n            return Promise.all([\n                parser.getDependencies(\"scene\"),\n                parser.getDependencies(\"animation\"),\n                parser.getDependencies(\"camera\")\n            ]);\n        }).then(function(dependencies) {\n            const result = {\n                scene: dependencies[0][json.scene || 0],\n                scenes: dependencies[0],\n                animations: dependencies[1],\n                cameras: dependencies[2],\n                asset: json.asset,\n                parser,\n                userData: {}\n            };\n            addUnknownExtensionsToUserData(extensions, result, json);\n            assignExtrasToUserData(result, json);\n            return Promise.all(parser._invokeAll(function(ext) {\n                return ext.afterRoot && ext.afterRoot(result);\n            })).then(function() {\n                for (const scene of result.scenes){\n                    scene.updateMatrixWorld();\n                }\n                onLoad(result);\n            });\n        }).catch(onError);\n    }\n    /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */ _markDefs() {\n        const nodeDefs = this.json.nodes || [];\n        const skinDefs = this.json.skins || [];\n        const meshDefs = this.json.meshes || [];\n        for(let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++){\n            const joints = skinDefs[skinIndex].joints;\n            for(let i = 0, il = joints.length; i < il; i++){\n                nodeDefs[joints[i]].isBone = true;\n            }\n        }\n        for(let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++){\n            const nodeDef = nodeDefs[nodeIndex];\n            if (nodeDef.mesh !== void 0) {\n                this._addNodeRef(this.meshCache, nodeDef.mesh);\n                if (nodeDef.skin !== void 0) {\n                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n                }\n            }\n            if (nodeDef.camera !== void 0) {\n                this._addNodeRef(this.cameraCache, nodeDef.camera);\n            }\n        }\n    }\n    /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */ _addNodeRef(cache, index) {\n        if (index === void 0) return;\n        if (cache.refs[index] === void 0) {\n            cache.refs[index] = cache.uses[index] = 0;\n        }\n        cache.refs[index]++;\n    }\n    /** Returns a reference to a shared resource, cloning it if necessary. */ _getNodeRef(cache, index, object) {\n        if (cache.refs[index] <= 1) return object;\n        const ref = object.clone();\n        const updateMappings = (original, clone)=>{\n            const mappings = this.associations.get(original);\n            if (mappings != null) {\n                this.associations.set(clone, mappings);\n            }\n            for (const [i, child] of original.children.entries()){\n                updateMappings(child, clone.children[i]);\n            }\n        };\n        updateMappings(object, ref);\n        ref.name += \"_instance_\" + cache.uses[index]++;\n        return ref;\n    }\n    _invokeOne(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.push(this);\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) return result;\n        }\n        return null;\n    }\n    _invokeAll(func) {\n        const extensions = Object.values(this.plugins);\n        extensions.unshift(this);\n        const pending = [];\n        for(let i = 0; i < extensions.length; i++){\n            const result = func(extensions[i]);\n            if (result) pending.push(result);\n        }\n        return pending;\n    }\n    /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */ getDependency(type, index) {\n        const cacheKey = type + \":\" + index;\n        let dependency = this.cache.get(cacheKey);\n        if (!dependency) {\n            switch(type){\n                case \"scene\":\n                    dependency = this.loadScene(index);\n                    break;\n                case \"node\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadNode && ext.loadNode(index);\n                    });\n                    break;\n                case \"mesh\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMesh && ext.loadMesh(index);\n                    });\n                    break;\n                case \"accessor\":\n                    dependency = this.loadAccessor(index);\n                    break;\n                case \"bufferView\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadBufferView && ext.loadBufferView(index);\n                    });\n                    break;\n                case \"buffer\":\n                    dependency = this.loadBuffer(index);\n                    break;\n                case \"material\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadMaterial && ext.loadMaterial(index);\n                    });\n                    break;\n                case \"texture\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadTexture && ext.loadTexture(index);\n                    });\n                    break;\n                case \"skin\":\n                    dependency = this.loadSkin(index);\n                    break;\n                case \"animation\":\n                    dependency = this._invokeOne(function(ext) {\n                        return ext.loadAnimation && ext.loadAnimation(index);\n                    });\n                    break;\n                case \"camera\":\n                    dependency = this.loadCamera(index);\n                    break;\n                default:\n                    dependency = this._invokeOne(function(ext) {\n                        return ext != this && ext.getDependency && ext.getDependency(type, index);\n                    });\n                    if (!dependency) {\n                        throw new Error(\"Unknown type: \" + type);\n                    }\n                    break;\n            }\n            this.cache.add(cacheKey, dependency);\n        }\n        return dependency;\n    }\n    /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */ getDependencies(type) {\n        let dependencies = this.cache.get(type);\n        if (!dependencies) {\n            const parser = this;\n            const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n            dependencies = Promise.all(defs.map(function(def, index) {\n                return parser.getDependency(type, index);\n            }));\n            this.cache.add(type, dependencies);\n        }\n        return dependencies;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBuffer(bufferIndex) {\n        const bufferDef = this.json.buffers[bufferIndex];\n        const loader = this.fileLoader;\n        if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n            throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n        }\n        if (bufferDef.uri === void 0 && bufferIndex === 0) {\n            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n        }\n        const options = this.options;\n        return new Promise(function(resolve, reject) {\n            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n                reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n            });\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */ loadBufferView(bufferViewIndex) {\n        const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n        return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n            const byteLength = bufferViewDef.byteLength || 0;\n            const byteOffset = bufferViewDef.byteOffset || 0;\n            return buffer.slice(byteOffset, byteOffset + byteLength);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */ loadAccessor(accessorIndex) {\n        const parser = this;\n        const json = this.json;\n        const accessorDef = this.json.accessors[accessorIndex];\n        if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const normalized = accessorDef.normalized === true;\n            const array = new TypedArray(accessorDef.count * itemSize);\n            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized));\n        }\n        const pendingBufferViews = [];\n        if (accessorDef.bufferView !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n        } else {\n            pendingBufferViews.push(null);\n        }\n        if (accessorDef.sparse !== void 0) {\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n            pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n        }\n        return Promise.all(pendingBufferViews).then(function(bufferViews) {\n            const bufferView = bufferViews[0];\n            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n            const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n            const itemBytes = elementBytes * itemSize;\n            const byteOffset = accessorDef.byteOffset || 0;\n            const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n            const normalized = accessorDef.normalized === true;\n            let array, bufferAttribute;\n            if (byteStride && byteStride !== itemBytes) {\n                const ibSlice = Math.floor(byteOffset / byteStride);\n                const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n                let ib = parser.cache.get(ibCacheKey);\n                if (!ib) {\n                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n                    parser.cache.add(ibCacheKey, ib);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n            } else {\n                if (bufferView === null) {\n                    array = new TypedArray(accessorDef.count * itemSize);\n                } else {\n                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n                }\n                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n            }\n            if (accessorDef.sparse !== void 0) {\n                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n                if (bufferView !== null) {\n                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n                }\n                for(let i = 0, il = sparseIndices.length; i < il; i++){\n                    const index = sparseIndices[i];\n                    bufferAttribute.setX(index, sparseValues[i * itemSize]);\n                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n                    if (itemSize >= 5) throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n                }\n            }\n            return bufferAttribute;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */ loadTexture(textureIndex) {\n        const json = this.json;\n        const options = this.options;\n        const textureDef = json.textures[textureIndex];\n        const sourceIndex = textureDef.source;\n        const sourceDef = json.images[sourceIndex];\n        let loader = this.textureLoader;\n        if (sourceDef.uri) {\n            const handler = options.manager.getHandler(sourceDef.uri);\n            if (handler !== null) loader = handler;\n        }\n        return this.loadTextureImage(textureIndex, sourceIndex, loader);\n    }\n    loadTextureImage(textureIndex, sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const textureDef = json.textures[textureIndex];\n        const sourceDef = json.images[sourceIndex];\n        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + \":\" + textureDef.sampler;\n        if (this.textureCache[cacheKey]) {\n            return this.textureCache[cacheKey];\n        }\n        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {\n            texture.flipY = false;\n            texture.name = textureDef.name || sourceDef.name || \"\";\n            if (texture.name === \"\" && typeof sourceDef.uri === \"string\" && sourceDef.uri.startsWith(\"data:image/\") === false) {\n                texture.name = sourceDef.uri;\n            }\n            const samplers = json.samplers || {};\n            const sampler = samplers[textureDef.sampler] || {};\n            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n            parser.associations.set(texture, {\n                textures: textureIndex\n            });\n            return texture;\n        }).catch(function() {\n            return null;\n        });\n        this.textureCache[cacheKey] = promise;\n        return promise;\n    }\n    loadImageSource(sourceIndex, loader) {\n        const parser = this;\n        const json = this.json;\n        const options = this.options;\n        if (this.sourceCache[sourceIndex] !== void 0) {\n            return this.sourceCache[sourceIndex].then((texture)=>texture.clone());\n        }\n        const sourceDef = json.images[sourceIndex];\n        const URL = self.URL || self.webkitURL;\n        let sourceURI = sourceDef.uri || \"\";\n        let isObjectURL = false;\n        if (sourceDef.bufferView !== void 0) {\n            sourceURI = parser.getDependency(\"bufferView\", sourceDef.bufferView).then(function(bufferView) {\n                isObjectURL = true;\n                const blob = new Blob([\n                    bufferView\n                ], {\n                    type: sourceDef.mimeType\n                });\n                sourceURI = URL.createObjectURL(blob);\n                return sourceURI;\n            });\n        } else if (sourceDef.uri === void 0) {\n            throw new Error(\"THREE.GLTFLoader: Image \" + sourceIndex + \" is missing URI and bufferView\");\n        }\n        const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {\n            return new Promise(function(resolve, reject) {\n                let onLoad = resolve;\n                if (loader.isImageBitmapLoader === true) {\n                    onLoad = function(imageBitmap) {\n                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);\n                        texture.needsUpdate = true;\n                        resolve(texture);\n                    };\n                }\n                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n            });\n        }).then(function(texture) {\n            if (isObjectURL === true) {\n                URL.revokeObjectURL(sourceURI);\n            }\n            assignExtrasToUserData(texture, sourceDef);\n            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);\n            return texture;\n        }).catch(function(error) {\n            console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\n            throw error;\n        });\n        this.sourceCache[sourceIndex] = promise;\n        return promise;\n    }\n    /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */ assignTexture(materialParams, mapName, mapDef, colorSpace) {\n        const parser = this;\n        return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n            if (!texture) return null;\n            if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {\n                texture = texture.clone();\n                texture.channel = mapDef.texCoord;\n            }\n            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n                const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n                if (transform) {\n                    const gltfReference = parser.associations.get(texture);\n                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n                    parser.associations.set(texture, gltfReference);\n                }\n            }\n            if (colorSpace !== void 0) {\n                if (typeof colorSpace === \"number\") colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n                if (\"colorSpace\" in texture) texture.colorSpace = colorSpace;\n                else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;\n            }\n            materialParams[mapName] = texture;\n            return texture;\n        });\n    }\n    /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */ assignFinalMaterial(mesh) {\n        const geometry = mesh.geometry;\n        let material = mesh.material;\n        const useDerivativeTangents = geometry.attributes.tangent === void 0;\n        const useVertexColors = geometry.attributes.color !== void 0;\n        const useFlatShading = geometry.attributes.normal === void 0;\n        if (mesh.isPoints) {\n            const cacheKey = \"PointsMaterial:\" + material.uuid;\n            let pointsMaterial = this.cache.get(cacheKey);\n            if (!pointsMaterial) {\n                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n                pointsMaterial.color.copy(material.color);\n                pointsMaterial.map = material.map;\n                pointsMaterial.sizeAttenuation = false;\n                this.cache.add(cacheKey, pointsMaterial);\n            }\n            material = pointsMaterial;\n        } else if (mesh.isLine) {\n            const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n            let lineMaterial = this.cache.get(cacheKey);\n            if (!lineMaterial) {\n                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n                lineMaterial.color.copy(material.color);\n                lineMaterial.map = material.map;\n                this.cache.add(cacheKey, lineMaterial);\n            }\n            material = lineMaterial;\n        }\n        if (useDerivativeTangents || useVertexColors || useFlatShading) {\n            let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n            if (useDerivativeTangents) cacheKey += \"derivative-tangents:\";\n            if (useVertexColors) cacheKey += \"vertex-colors:\";\n            if (useFlatShading) cacheKey += \"flat-shading:\";\n            let cachedMaterial = this.cache.get(cacheKey);\n            if (!cachedMaterial) {\n                cachedMaterial = material.clone();\n                if (useVertexColors) cachedMaterial.vertexColors = true;\n                if (useFlatShading) cachedMaterial.flatShading = true;\n                if (useDerivativeTangents) {\n                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\n                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;\n                }\n                this.cache.add(cacheKey, cachedMaterial);\n                this.associations.set(cachedMaterial, this.associations.get(material));\n            }\n            material = cachedMaterial;\n        }\n        mesh.material = material;\n    }\n    getMaterialType() {\n        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */ loadMaterial(materialIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const materialDef = json.materials[materialIndex];\n        let materialType;\n        const materialParams = {};\n        const materialExtensions = materialDef.extensions || {};\n        const pending = [];\n        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n            materialType = kmuExtension.getMaterialType();\n            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n        } else {\n            const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n            materialParams.opacity = 1;\n            if (Array.isArray(metallicRoughness.baseColorFactor)) {\n                const array = metallicRoughness.baseColorFactor;\n                materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);\n                materialParams.opacity = array[3];\n            }\n            if (metallicRoughness.baseColorTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture, SRGBColorSpace));\n            }\n            materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n            materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n            if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n                pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n                pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n            }\n            materialType = this._invokeOne(function(ext) {\n                return ext.getMaterialType && ext.getMaterialType(materialIndex);\n            });\n            pending.push(Promise.all(this._invokeAll(function(ext) {\n                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n            })));\n        }\n        if (materialDef.doubleSided === true) {\n            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n        }\n        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n        if (alphaMode === ALPHA_MODES.BLEND) {\n            materialParams.transparent = true;\n            materialParams.depthWrite = false;\n        } else {\n            materialParams.transparent = false;\n            if (alphaMode === ALPHA_MODES.MASK) {\n                materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n            }\n        }\n        if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);\n            if (materialDef.normalTexture.scale !== void 0) {\n                const scale = materialDef.normalTexture.scale;\n                materialParams.normalScale.set(scale, scale);\n            }\n        }\n        if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n            if (materialDef.occlusionTexture.strength !== void 0) {\n                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n            }\n        }\n        if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            const emissiveFactor = materialDef.emissiveFactor;\n            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);\n        }\n        if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n            pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture, SRGBColorSpace));\n        }\n        return Promise.all(pending).then(function() {\n            const material = new materialType(materialParams);\n            if (materialDef.name) material.name = materialDef.name;\n            assignExtrasToUserData(material, materialDef);\n            parser.associations.set(material, {\n                materials: materialIndex\n            });\n            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n            return material;\n        });\n    }\n    /** When Object3D instances are targeted by animation, they need unique names. */ createUniqueName(originalName) {\n        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n        if (sanitizedName in this.nodeNamesUsed) {\n            return sanitizedName + \"_\" + ++this.nodeNamesUsed[sanitizedName];\n        } else {\n            this.nodeNamesUsed[sanitizedName] = 0;\n            return sanitizedName;\n        }\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */ loadGeometries(primitives) {\n        const parser = this;\n        const extensions = this.extensions;\n        const cache = this.primitiveCache;\n        function createDracoPrimitive(primitive) {\n            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n                return addPrimitiveAttributes(geometry, primitive, parser);\n            });\n        }\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const primitive = primitives[i];\n            const cacheKey = createPrimitiveKey(primitive);\n            const cached = cache[cacheKey];\n            if (cached) {\n                pending.push(cached.promise);\n            } else {\n                let geometryPromise;\n                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n                    geometryPromise = createDracoPrimitive(primitive);\n                } else {\n                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n                }\n                cache[cacheKey] = {\n                    primitive,\n                    promise: geometryPromise\n                };\n                pending.push(geometryPromise);\n            }\n        }\n        return Promise.all(pending);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */ loadMesh(meshIndex) {\n        const parser = this;\n        const json = this.json;\n        const extensions = this.extensions;\n        const meshDef = json.meshes[meshIndex];\n        const primitives = meshDef.primitives;\n        const pending = [];\n        for(let i = 0, il = primitives.length; i < il; i++){\n            const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n            pending.push(material);\n        }\n        pending.push(parser.loadGeometries(primitives));\n        return Promise.all(pending).then(function(results) {\n            const materials = results.slice(0, results.length - 1);\n            const geometries = results[results.length - 1];\n            const meshes = [];\n            for(let i = 0, il = geometries.length; i < il; i++){\n                const geometry = geometries[i];\n                const primitive = primitives[i];\n                let mesh;\n                const material = materials[i];\n                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n                    mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n                    if (mesh.isSkinnedMesh === true) {\n                        mesh.normalizeSkinWeights();\n                    }\n                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n                        mesh.geometry = (0,_utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_3__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n                    }\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n                } else {\n                    throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n                }\n                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n                    updateMorphTargets(mesh, meshDef);\n                }\n                mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n                assignExtrasToUserData(mesh, meshDef);\n                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);\n                parser.assignFinalMaterial(mesh);\n                meshes.push(mesh);\n            }\n            for(let i = 0, il = meshes.length; i < il; i++){\n                parser.associations.set(meshes[i], {\n                    meshes: meshIndex,\n                    primitives: i\n                });\n            }\n            if (meshes.length === 1) {\n                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);\n                return meshes[0];\n            }\n            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);\n            parser.associations.set(group, {\n                meshes: meshIndex\n            });\n            for(let i = 0, il = meshes.length; i < il; i++){\n                group.add(meshes[i]);\n            }\n            return group;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */ loadCamera(cameraIndex) {\n        let camera;\n        const cameraDef = this.json.cameras[cameraIndex];\n        const params = cameraDef[cameraDef.type];\n        if (!params) {\n            console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n            return;\n        }\n        if (cameraDef.type === \"perspective\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n        } else if (cameraDef.type === \"orthographic\") {\n            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n        }\n        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\n        assignExtrasToUserData(camera, cameraDef);\n        return Promise.resolve(camera);\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */ loadSkin(skinIndex) {\n        const skinDef = this.json.skins[skinIndex];\n        const pending = [];\n        for(let i = 0, il = skinDef.joints.length; i < il; i++){\n            pending.push(this._loadNodeShallow(skinDef.joints[i]));\n        }\n        if (skinDef.inverseBindMatrices !== void 0) {\n            pending.push(this.getDependency(\"accessor\", skinDef.inverseBindMatrices));\n        } else {\n            pending.push(null);\n        }\n        return Promise.all(pending).then(function(results) {\n            const inverseBindMatrices = results.pop();\n            const jointNodes = results;\n            const bones = [];\n            const boneInverses = [];\n            for(let i = 0, il = jointNodes.length; i < il; i++){\n                const jointNode = jointNodes[i];\n                if (jointNode) {\n                    bones.push(jointNode);\n                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                    if (inverseBindMatrices !== null) {\n                        mat.fromArray(inverseBindMatrices.array, i * 16);\n                    }\n                    boneInverses.push(mat);\n                } else {\n                    console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i]);\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses);\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */ loadAnimation(animationIndex) {\n        const json = this.json;\n        const parser = this;\n        const animationDef = json.animations[animationIndex];\n        const animationName = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n        const pendingNodes = [];\n        const pendingInputAccessors = [];\n        const pendingOutputAccessors = [];\n        const pendingSamplers = [];\n        const pendingTargets = [];\n        for(let i = 0, il = animationDef.channels.length; i < il; i++){\n            const channel = animationDef.channels[i];\n            const sampler = animationDef.samplers[channel.sampler];\n            const target = channel.target;\n            const name = target.node;\n            const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n            const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n            if (target.node === void 0) continue;\n            pendingNodes.push(this.getDependency(\"node\", name));\n            pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n            pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n            pendingSamplers.push(sampler);\n            pendingTargets.push(target);\n        }\n        return Promise.all([\n            Promise.all(pendingNodes),\n            Promise.all(pendingInputAccessors),\n            Promise.all(pendingOutputAccessors),\n            Promise.all(pendingSamplers),\n            Promise.all(pendingTargets)\n        ]).then(function(dependencies) {\n            const nodes = dependencies[0];\n            const inputAccessors = dependencies[1];\n            const outputAccessors = dependencies[2];\n            const samplers = dependencies[3];\n            const targets = dependencies[4];\n            const tracks = [];\n            for(let i = 0, il = nodes.length; i < il; i++){\n                const node = nodes[i];\n                const inputAccessor = inputAccessors[i];\n                const outputAccessor = outputAccessors[i];\n                const sampler = samplers[i];\n                const target = targets[i];\n                if (node === void 0) continue;\n                if (node.updateMatrix) {\n                    node.updateMatrix();\n                }\n                const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);\n                if (createdTracks) {\n                    for(let k = 0; k < createdTracks.length; k++){\n                        tracks.push(createdTracks[k]);\n                    }\n                }\n            }\n            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, void 0, tracks);\n        });\n    }\n    createNodeMesh(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        if (nodeDef.mesh === void 0) return null;\n        return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n            if (nodeDef.weights !== void 0) {\n                node.traverse(function(o) {\n                    if (!o.isMesh) return;\n                    for(let i = 0, il = nodeDef.weights.length; i < il; i++){\n                        o.morphTargetInfluences[i] = nodeDef.weights[i];\n                    }\n                });\n            }\n            return node;\n        });\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */ loadNode(nodeIndex) {\n        const json = this.json;\n        const parser = this;\n        const nodeDef = json.nodes[nodeIndex];\n        const nodePending = parser._loadNodeShallow(nodeIndex);\n        const childPending = [];\n        const childrenDef = nodeDef.children || [];\n        for(let i = 0, il = childrenDef.length; i < il; i++){\n            childPending.push(parser.getDependency(\"node\", childrenDef[i]));\n        }\n        const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency(\"skin\", nodeDef.skin);\n        return Promise.all([\n            nodePending,\n            Promise.all(childPending),\n            skeletonPending\n        ]).then(function(results) {\n            const node = results[0];\n            const children = results[1];\n            const skeleton = results[2];\n            if (skeleton !== null) {\n                node.traverse(function(mesh) {\n                    if (!mesh.isSkinnedMesh) return;\n                    mesh.bind(skeleton, _identityMatrix);\n                });\n            }\n            for(let i = 0, il = children.length; i < il; i++){\n                node.add(children[i]);\n            }\n            return node;\n        });\n    }\n    // ._loadNodeShallow() parses a single node.\n    // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n    _loadNodeShallow(nodeIndex) {\n        const json = this.json;\n        const extensions = this.extensions;\n        const parser = this;\n        if (this.nodeCache[nodeIndex] !== void 0) {\n            return this.nodeCache[nodeIndex];\n        }\n        const nodeDef = json.nodes[nodeIndex];\n        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n        const pending = [];\n        const meshPromise = parser._invokeOne(function(ext) {\n            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n        });\n        if (meshPromise) {\n            pending.push(meshPromise);\n        }\n        if (nodeDef.camera !== void 0) {\n            pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n            }));\n        }\n        parser._invokeAll(function(ext) {\n            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n        }).forEach(function(promise) {\n            pending.push(promise);\n        });\n        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {\n            let node;\n            if (nodeDef.isBone === true) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n            } else if (objects.length > 1) {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n            } else if (objects.length === 1) {\n                node = objects[0];\n            } else {\n                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n            }\n            if (node !== objects[0]) {\n                for(let i = 0, il = objects.length; i < il; i++){\n                    node.add(objects[i]);\n                }\n            }\n            if (nodeDef.name) {\n                node.userData.name = nodeDef.name;\n                node.name = nodeName;\n            }\n            assignExtrasToUserData(node, nodeDef);\n            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n            if (nodeDef.matrix !== void 0) {\n                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n                matrix.fromArray(nodeDef.matrix);\n                node.applyMatrix4(matrix);\n            } else {\n                if (nodeDef.translation !== void 0) {\n                    node.position.fromArray(nodeDef.translation);\n                }\n                if (nodeDef.rotation !== void 0) {\n                    node.quaternion.fromArray(nodeDef.rotation);\n                }\n                if (nodeDef.scale !== void 0) {\n                    node.scale.fromArray(nodeDef.scale);\n                }\n            }\n            if (!parser.associations.has(node)) {\n                parser.associations.set(node, {});\n            }\n            parser.associations.get(node).nodes = nodeIndex;\n            return node;\n        });\n        return this.nodeCache[nodeIndex];\n    }\n    /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */ loadScene(sceneIndex) {\n        const extensions = this.extensions;\n        const sceneDef = this.json.scenes[sceneIndex];\n        const parser = this;\n        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\n        assignExtrasToUserData(scene, sceneDef);\n        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n        const nodeIds = sceneDef.nodes || [];\n        const pending = [];\n        for(let i = 0, il = nodeIds.length; i < il; i++){\n            pending.push(parser.getDependency(\"node\", nodeIds[i]));\n        }\n        return Promise.all(pending).then(function(nodes) {\n            for(let i = 0, il = nodes.length; i < il; i++){\n                scene.add(nodes[i]);\n            }\n            const reduceAssociations = (node)=>{\n                const reducedAssociations = /* @__PURE__ */ new Map();\n                for (const [key, value] of parser.associations){\n                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {\n                        reducedAssociations.set(key, value);\n                    }\n                }\n                node.traverse((node2)=>{\n                    const mappings = parser.associations.get(node2);\n                    if (mappings != null) {\n                        reducedAssociations.set(node2, mappings);\n                    }\n                });\n                return reducedAssociations;\n            };\n            parser.associations = reduceAssociations(scene);\n            return scene;\n        });\n    }\n    _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n        const tracks = [];\n        const targetName = node.name ? node.name : node.uuid;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n            node.traverse(function(object) {\n                if (object.morphTargetInfluences) {\n                    targetNames.push(object.name ? object.name : object.uuid);\n                }\n            });\n        } else {\n            targetNames.push(targetName);\n        }\n        let TypedKeyframeTrack;\n        switch(PATH_PROPERTIES[target.path]){\n            case PATH_PROPERTIES.weights:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.rotation:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n                break;\n            case PATH_PROPERTIES.position:\n            case PATH_PROPERTIES.scale:\n                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                break;\n            default:\n                switch(outputAccessor.itemSize){\n                    case 1:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n                        break;\n                    case 2:\n                    case 3:\n                    default:\n                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n                        break;\n                }\n                break;\n        }\n        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n        const outputArray = this._getArrayFromAccessor(outputAccessor);\n        for(let j = 0, jl = targetNames.length; j < jl; j++){\n            const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n            if (sampler.interpolation === \"CUBICSPLINE\") {\n                this._createCubicSplineTrackInterpolant(track);\n            }\n            tracks.push(track);\n        }\n        return tracks;\n    }\n    _getArrayFromAccessor(accessor) {\n        let outputArray = accessor.array;\n        if (accessor.normalized) {\n            const scale = getNormalizedComponentScale(outputArray.constructor);\n            const scaled = new Float32Array(outputArray.length);\n            for(let j = 0, jl = outputArray.length; j < jl; j++){\n                scaled[j] = outputArray[j] * scale;\n            }\n            outputArray = scaled;\n        }\n        return outputArray;\n    }\n    _createCubicSplineTrackInterpolant(track) {\n        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n            const interpolantType = this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);\n        };\n        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n    }\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n    if (attributes.POSITION !== void 0) {\n        const accessor = parser.json.accessors[attributes.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n            if (accessor.normalized) {\n                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                box.min.multiplyScalar(boxScale);\n                box.max.multiplyScalar(boxScale);\n            }\n        } else {\n            console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n            return;\n        }\n    } else {\n        return;\n    }\n    const targets = primitiveDef.targets;\n    if (targets !== void 0) {\n        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        for(let i = 0, il = targets.length; i < il; i++){\n            const target = targets[i];\n            if (target.POSITION !== void 0) {\n                const accessor = parser.json.accessors[target.POSITION];\n                const min = accessor.min;\n                const max = accessor.max;\n                if (min !== void 0 && max !== void 0) {\n                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n                    if (accessor.normalized) {\n                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n                        vector.multiplyScalar(boxScale);\n                    }\n                    maxDisplacement.max(vector);\n                } else {\n                    console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n                }\n            }\n        }\n        box.expandByVector(maxDisplacement);\n    }\n    geometry.boundingBox = box;\n    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    const attributes = primitiveDef.attributes;\n    const pending = [];\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n        return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n            geometry.setAttribute(attributeName, accessor);\n        });\n    }\n    for(const gltfAttributeName in attributes){\n        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n        if (threeAttributeName in geometry.attributes) continue;\n        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n    if (primitiveDef.indices !== void 0 && !geometry.index) {\n        const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n            geometry.setIndex(accessor2);\n        });\n        pending.push(accessor);\n    }\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function() {\n        return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n}\n //# sourceMappingURL=GLTFLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvR0xURkxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEwOUI7QUFDcDVCO0FBQ2xCO0FBQ0s7QUFDekQsTUFBTWlFLGlCQUFpQjtBQUN2QixNQUFNQyx1QkFBdUI7QUFDN0IsTUFBTUMsZUFBZTtBQUNyQixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsbUJBQW1CckUseUNBQU1BO0lBQzdCc0UsWUFBWUMsT0FBTyxDQUFFO1FBQ25CLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNDLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLGVBQWUsR0FBRyxFQUFFO1FBQ3pCLElBQUksQ0FBQ0MsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJQyxnQ0FBZ0NEO1FBQzdDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlFLGlDQUFpQ0Y7UUFDOUM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSUcsMkJBQTJCSDtRQUN4QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJSSx5QkFBeUJKO1FBQ3RDO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixPQUFPLElBQUlLLHlCQUF5Qkw7UUFDdEM7UUFDQSxJQUFJLENBQUNELFFBQVEsQ0FBQyxTQUFTQyxNQUFNO1lBQzNCLE9BQU8sSUFBSU0sNEJBQTRCTjtRQUN6QztRQUNBLElBQUksQ0FBQ0QsUUFBUSxDQUFDLFNBQVNDLE1BQU07WUFDM0IsT0FBTyxJQUFJTyxtQ0FBbUNQO1FBQ2hEO1FBQ0EsSUFBSSxDQUFDRCxRQUFRLENBQUMsU0FBU0MsTUFBTTtZQUMzQixP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VztRQUN6RixJQUFJRixzQkFBc0J4QyxTQUFTYixVQUFVLEVBQzNDO1FBQ0Z2SCxRQUFRbkgsSUFBSSxDQUFDd3JCLHdCQUF3QjljLFVBQVUsQ0FBQytjLGtCQUFrQixFQUFFMVo7SUFDdEU7SUFDQSxJQUFJMkksYUFBYUcsT0FBTyxLQUFLLEtBQUssS0FBSyxDQUFDdEwsU0FBUzdJLEtBQUssRUFBRTtRQUN0RCxNQUFNaUksV0FBV2hTLE9BQU84SixhQUFhLENBQUMsWUFBWWlVLGFBQWFHLE9BQU8sRUFBRWhVLElBQUksQ0FBQyxTQUFTNmtCLFNBQVM7WUFDN0ZuYyxTQUFTb2MsUUFBUSxDQUFDRDtRQUNwQjtRQUNBdmtCLFFBQVFuSCxJQUFJLENBQUMyTztJQUNmO0lBQ0FySSx1QkFBdUJpSixVQUFVbUw7SUFDakM2UCxjQUFjaGIsVUFBVW1MLGNBQWMvZDtJQUN0QyxPQUFPNEYsUUFBUXNGLEdBQUcsQ0FBQ1YsU0FBU04sSUFBSSxDQUFDO1FBQy9CLE9BQU82VCxhQUFhcEIsT0FBTyxLQUFLLEtBQUssSUFBSUQsZ0JBQWdCOUosVUFBVW1MLGFBQWFwQixPQUFPLEVBQUUzYyxVQUFVNFM7SUFDckc7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9HTFRGTG9hZGVyLmpzP2JmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9hZGVyLCBMb2FkZXJVdGlscywgRmlsZUxvYWRlciwgQ29sb3IsIFNwb3RMaWdodCwgUG9pbnRMaWdodCwgRGlyZWN0aW9uYWxMaWdodCwgTWVzaEJhc2ljTWF0ZXJpYWwsIE1lc2hQaHlzaWNhbE1hdGVyaWFsLCBWZWN0b3IyLCBNYXRyaXg0LCBWZWN0b3IzLCBRdWF0ZXJuaW9uLCBJbnN0YW5jZWRNZXNoLCBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsIE9iamVjdDNELCBUZXh0dXJlTG9hZGVyLCBJbWFnZUJpdG1hcExvYWRlciwgQnVmZmVyQXR0cmlidXRlLCBJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIExpbmVhckZpbHRlciwgTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyLCBSZXBlYXRXcmFwcGluZywgUG9pbnRzTWF0ZXJpYWwsIE1hdGVyaWFsLCBMaW5lQmFzaWNNYXRlcmlhbCwgTWVzaFN0YW5kYXJkTWF0ZXJpYWwsIERvdWJsZVNpZGUsIFByb3BlcnR5QmluZGluZywgQnVmZmVyR2VvbWV0cnksIFNraW5uZWRNZXNoLCBNZXNoLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFRyaWFuZ2xlRmFuRHJhd01vZGUsIExpbmVTZWdtZW50cywgTGluZSwgTGluZUxvb3AsIFBvaW50cywgR3JvdXAsIFBlcnNwZWN0aXZlQ2FtZXJhLCBNYXRoVXRpbHMsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgU2tlbGV0b24sIEFuaW1hdGlvbkNsaXAsIEJvbmUsIEludGVycG9sYXRlTGluZWFyLCBOZWFyZXN0RmlsdGVyLCBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlciwgTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlciwgTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTWlycm9yZWRSZXBlYXRXcmFwcGluZywgSW50ZXJwb2xhdGVEaXNjcmV0ZSwgRnJvbnRTaWRlLCBUZXh0dXJlLCBWZWN0b3JLZXlmcmFtZVRyYWNrLCBOdW1iZXJLZXlmcmFtZVRyYWNrLCBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgQm94MywgU3BoZXJlLCBJbnRlcnBvbGFudCB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgdG9UcmlhbmdsZXNEcmF3TW9kZSB9IGZyb20gXCIuLi91dGlscy9CdWZmZXJHZW9tZXRyeVV0aWxzLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL19wb2x5ZmlsbC9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IGRlY29kZVRleHQgfSBmcm9tIFwiLi4vX3BvbHlmaWxsL0xvYWRlclV0aWxzLmpzXCI7XG5jb25zdCBTUkdCQ29sb3JTcGFjZSA9IFwic3JnYlwiO1xuY29uc3QgTGluZWFyU1JHQkNvbG9yU3BhY2UgPSBcInNyZ2ItbGluZWFyXCI7XG5jb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuY29uc3QgTGluZWFyRW5jb2RpbmcgPSAzZTM7XG5jbGFzcyBHTFRGTG9hZGVyIGV4dGVuZHMgTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIgPSBudWxsO1xuICAgIHRoaXMua3R4MkxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5tZXNob3B0RGVjb2RlciA9IG51bGw7XG4gICAgdGhpcy5wbHVnaW5DYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0Rpc3BlcnNpb25FeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWF0ZXJpYWxzQnVtcEV4dGVuc2lvbihwYXJzZXIpO1xuICAgIH0pO1xuICAgIHRoaXMucmVnaXN0ZXIoZnVuY3Rpb24ocGFyc2VyKSB7XG4gICAgICByZXR1cm4gbmV3IEdMVEZMaWdodHNFeHRlbnNpb24ocGFyc2VyKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlZ2lzdGVyKGZ1bmN0aW9uKHBhcnNlcikge1xuICAgICAgcmV0dXJuIG5ldyBHTFRGTWVzaG9wdENvbXByZXNzaW9uKHBhcnNlcik7XG4gICAgfSk7XG4gICAgdGhpcy5yZWdpc3RlcihmdW5jdGlvbihwYXJzZXIpIHtcbiAgICAgIHJldHVybiBuZXcgR0xURk1lc2hHcHVJbnN0YW5jaW5nKHBhcnNlcik7XG4gICAgfSk7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBsZXQgcmVzb3VyY2VQYXRoO1xuICAgIGlmICh0aGlzLnJlc291cmNlUGF0aCAhPT0gXCJcIikge1xuICAgICAgcmVzb3VyY2VQYXRoID0gdGhpcy5yZXNvdXJjZVBhdGg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhdGggIT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlVXJsID0gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UodXJsKTtcbiAgICAgIHJlc291cmNlUGF0aCA9IExvYWRlclV0aWxzLnJlc29sdmVVUkwocmVsYXRpdmVVcmwsIHRoaXMucGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc291cmNlUGF0aCA9IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKHVybCk7XG4gICAgfVxuICAgIHRoaXMubWFuYWdlci5pdGVtU3RhcnQodXJsKTtcbiAgICBjb25zdCBfb25FcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRXJyb3IodXJsKTtcbiAgICAgIHNjb3BlLm1hbmFnZXIuaXRlbUVuZCh1cmwpO1xuICAgIH07XG4gICAgY29uc3QgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5tYW5hZ2VyKTtcbiAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoXCJhcnJheWJ1ZmZlclwiKTtcbiAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgIGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgIGxvYWRlci5sb2FkKFxuICAgICAgdXJsLFxuICAgICAgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNjb3BlLnBhcnNlKFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHJlc291cmNlUGF0aCxcbiAgICAgICAgICAgIGZ1bmN0aW9uKGdsdGYpIHtcbiAgICAgICAgICAgICAgb25Mb2FkKGdsdGYpO1xuICAgICAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQodXJsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBfb25FcnJvclxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBfb25FcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBfb25FcnJvclxuICAgICk7XG4gIH1cbiAgc2V0RFJBQ09Mb2FkZXIoZHJhY29Mb2FkZXIpIHtcbiAgICB0aGlzLmRyYWNvTG9hZGVyID0gZHJhY29Mb2FkZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0RERTTG9hZGVyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogXCJNU0ZUX3RleHR1cmVfZGRzXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gUGxlYXNlIHVwZGF0ZSB0byBcIktIUl90ZXh0dXJlX2Jhc2lzdVwiLicpO1xuICB9XG4gIHNldEtUWDJMb2FkZXIoa3R4MkxvYWRlcikge1xuICAgIHRoaXMua3R4MkxvYWRlciA9IGt0eDJMb2FkZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TWVzaG9wdERlY29kZXIobWVzaG9wdERlY29kZXIpIHtcbiAgICB0aGlzLm1lc2hvcHREZWNvZGVyID0gbWVzaG9wdERlY29kZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVnaXN0ZXIoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wbHVnaW5DYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjaykgPT09IC0xKSB7XG4gICAgICB0aGlzLnBsdWdpbkNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdW5yZWdpc3RlcihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSAhPT0gLTEpIHtcbiAgICAgIHRoaXMucGx1Z2luQ2FsbGJhY2tzLnNwbGljZSh0aGlzLnBsdWdpbkNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKSwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBhcnNlKGRhdGEsIHBhdGgsIG9uTG9hZCwgb25FcnJvcikge1xuICAgIGxldCBqc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcbiAgICBjb25zdCBwbHVnaW5zID0ge307XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgY29uc3QgbWFnaWMgPSBkZWNvZGVUZXh0KG5ldyBVaW50OEFycmF5KGRhdGEuc2xpY2UoMCwgNCkpKTtcbiAgICAgIGlmIChtYWdpYyA9PT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGXSA9IG5ldyBHTFRGQmluYXJ5RXh0ZW5zaW9uKGRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChvbkVycm9yKVxuICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGpzb24gPSBKU09OLnBhcnNlKGV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdLmNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNvbiA9IEpTT04ucGFyc2UoZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBqc29uID0gZGF0YTtcbiAgICB9XG4gICAgaWYgKGpzb24uYXNzZXQgPT09IHZvaWQgMCB8fCBqc29uLmFzc2V0LnZlcnNpb25bMF0gPCAyKSB7XG4gICAgICBpZiAob25FcnJvcilcbiAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBhc3NldC4gZ2xURiB2ZXJzaW9ucyA+PTIuMCBhcmUgc3VwcG9ydGVkLlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBHTFRGUGFyc2VyKGpzb24sIHtcbiAgICAgIHBhdGg6IHBhdGggfHwgdGhpcy5yZXNvdXJjZVBhdGggfHwgXCJcIixcbiAgICAgIGNyb3NzT3JpZ2luOiB0aGlzLmNyb3NzT3JpZ2luLFxuICAgICAgcmVxdWVzdEhlYWRlcjogdGhpcy5yZXF1ZXN0SGVhZGVyLFxuICAgICAgbWFuYWdlcjogdGhpcy5tYW5hZ2VyLFxuICAgICAga3R4MkxvYWRlcjogdGhpcy5rdHgyTG9hZGVyLFxuICAgICAgbWVzaG9wdERlY29kZXI6IHRoaXMubWVzaG9wdERlY29kZXJcbiAgICB9KTtcbiAgICBwYXJzZXIuZmlsZUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpbkNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGx1Z2luID0gdGhpcy5wbHVnaW5DYWxsYmFja3NbaV0ocGFyc2VyKTtcbiAgICAgIGlmICghcGx1Z2luLm5hbWUpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBJbnZhbGlkIHBsdWdpbiBmb3VuZDogbWlzc2luZyBuYW1lXCIpO1xuICAgICAgcGx1Z2luc1twbHVnaW4ubmFtZV0gPSBwbHVnaW47XG4gICAgICBleHRlbnNpb25zW3BsdWdpbi5uYW1lXSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChqc29uLmV4dGVuc2lvbnNVc2VkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGpzb24uZXh0ZW5zaW9uc1VzZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uTmFtZSA9IGpzb24uZXh0ZW5zaW9uc1VzZWRbaV07XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnNSZXF1aXJlZCA9IGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkIHx8IFtdO1xuICAgICAgICBzd2l0Y2ggKGV4dGVuc2lvbk5hbWUpIHtcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVDpcbiAgICAgICAgICAgIGV4dGVuc2lvbnNbZXh0ZW5zaW9uTmFtZV0gPSBuZXcgR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX0RSQUNPX01FU0hfQ09NUFJFU1NJT046XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbihqc29uLCB0aGlzLmRyYWNvTG9hZGVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk06XG4gICAgICAgICAgICBleHRlbnNpb25zW2V4dGVuc2lvbk5hbWVdID0gbmV3IEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEVYVEVOU0lPTlMuS0hSX01FU0hfUVVBTlRJWkFUSU9OOlxuICAgICAgICAgICAgZXh0ZW5zaW9uc1tleHRlbnNpb25OYW1lXSA9IG5ldyBHTFRGTWVzaFF1YW50aXphdGlvbkV4dGVuc2lvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChleHRlbnNpb25zUmVxdWlyZWQuaW5kZXhPZihleHRlbnNpb25OYW1lKSA+PSAwICYmIHBsdWdpbnNbZXh0ZW5zaW9uTmFtZV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IFVua25vd24gZXh0ZW5zaW9uIFwiJyArIGV4dGVuc2lvbk5hbWUgKyAnXCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGFyc2VyLnNldEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgcGFyc2VyLnNldFBsdWdpbnMocGx1Z2lucyk7XG4gICAgcGFyc2VyLnBhcnNlKG9uTG9hZCwgb25FcnJvcik7XG4gIH1cbiAgcGFyc2VBc3luYyhkYXRhLCBwYXRoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHNjb3BlLnBhcnNlKGRhdGEsIHBhdGgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEdMVEZSZWdpc3RyeSgpIHtcbiAgbGV0IG9iamVjdHMgPSB7fTtcbiAgcmV0dXJuIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdHNba2V5XTtcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24oa2V5LCBvYmplY3QpIHtcbiAgICAgIG9iamVjdHNba2V5XSA9IG9iamVjdDtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICBkZWxldGUgb2JqZWN0c1trZXldO1xuICAgIH0sXG4gICAgcmVtb3ZlQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIG9iamVjdHMgPSB7fTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBFWFRFTlNJT05TID0ge1xuICBLSFJfQklOQVJZX0dMVEY6IFwiS0hSX2JpbmFyeV9nbFRGXCIsXG4gIEtIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OOiBcIktIUl9kcmFjb19tZXNoX2NvbXByZXNzaW9uXCIsXG4gIEtIUl9MSUdIVFNfUFVOQ1RVQUw6IFwiS0hSX2xpZ2h0c19wdW5jdHVhbFwiLFxuICBLSFJfTUFURVJJQUxTX0NMRUFSQ09BVDogXCJLSFJfbWF0ZXJpYWxzX2NsZWFyY29hdFwiLFxuICBLSFJfTUFURVJJQUxTX0RJU1BFUlNJT046IFwiS0hSX21hdGVyaWFsc19kaXNwZXJzaW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfSU9SOiBcIktIUl9tYXRlcmlhbHNfaW9yXCIsXG4gIEtIUl9NQVRFUklBTFNfU0hFRU46IFwiS0hSX21hdGVyaWFsc19zaGVlblwiLFxuICBLSFJfTUFURVJJQUxTX1NQRUNVTEFSOiBcIktIUl9tYXRlcmlhbHNfc3BlY3VsYXJcIixcbiAgS0hSX01BVEVSSUFMU19UUkFOU01JU1NJT046IFwiS0hSX21hdGVyaWFsc190cmFuc21pc3Npb25cIixcbiAgS0hSX01BVEVSSUFMU19JUklERVNDRU5DRTogXCJLSFJfbWF0ZXJpYWxzX2lyaWRlc2NlbmNlXCIsXG4gIEtIUl9NQVRFUklBTFNfQU5JU09UUk9QWTogXCJLSFJfbWF0ZXJpYWxzX2FuaXNvdHJvcHlcIixcbiAgS0hSX01BVEVSSUFMU19VTkxJVDogXCJLSFJfbWF0ZXJpYWxzX3VubGl0XCIsXG4gIEtIUl9NQVRFUklBTFNfVk9MVU1FOiBcIktIUl9tYXRlcmlhbHNfdm9sdW1lXCIsXG4gIEtIUl9URVhUVVJFX0JBU0lTVTogXCJLSFJfdGV4dHVyZV9iYXNpc3VcIixcbiAgS0hSX1RFWFRVUkVfVFJBTlNGT1JNOiBcIktIUl90ZXh0dXJlX3RyYW5zZm9ybVwiLFxuICBLSFJfTUVTSF9RVUFOVElaQVRJT046IFwiS0hSX21lc2hfcXVhbnRpemF0aW9uXCIsXG4gIEtIUl9NQVRFUklBTFNfRU1JU1NJVkVfU1RSRU5HVEg6IFwiS0hSX21hdGVyaWFsc19lbWlzc2l2ZV9zdHJlbmd0aFwiLFxuICBFWFRfTUFURVJJQUxTX0JVTVA6IFwiRVhUX21hdGVyaWFsc19idW1wXCIsXG4gIEVYVF9URVhUVVJFX1dFQlA6IFwiRVhUX3RleHR1cmVfd2VicFwiLFxuICBFWFRfVEVYVFVSRV9BVklGOiBcIkVYVF90ZXh0dXJlX2F2aWZcIixcbiAgRVhUX01FU0hPUFRfQ09NUFJFU1NJT046IFwiRVhUX21lc2hvcHRfY29tcHJlc3Npb25cIixcbiAgRVhUX01FU0hfR1BVX0lOU1RBTkNJTkc6IFwiRVhUX21lc2hfZ3B1X2luc3RhbmNpbmdcIlxufTtcbmNsYXNzIEdMVEZMaWdodHNFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9MSUdIVFNfUFVOQ1RVQUw7XG4gICAgdGhpcy5jYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gIH1cbiAgX21hcmtEZWZzKCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG5vZGVEZWZzID0gdGhpcy5wYXJzZXIuanNvbi5ub2RlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBub2RlSW5kZXggPSAwLCBub2RlTGVuZ3RoID0gbm9kZURlZnMubGVuZ3RoOyBub2RlSW5kZXggPCBub2RlTGVuZ3RoOyBub2RlSW5kZXgrKykge1xuICAgICAgY29uc3Qgbm9kZURlZiA9IG5vZGVEZWZzW25vZGVJbmRleF07XG4gICAgICBpZiAobm9kZURlZi5leHRlbnNpb25zICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdICYmIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmxpZ2h0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGFyc2VyLl9hZGROb2RlUmVmKHRoaXMuY2FjaGUsIG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdLmxpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2xvYWRMaWdodChsaWdodEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBcImxpZ2h0OlwiICsgbGlnaHRJbmRleDtcbiAgICBsZXQgZGVwZW5kZW5jeSA9IHBhcnNlci5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgIGlmIChkZXBlbmRlbmN5KVxuICAgICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnMgJiYganNvbi5leHRlbnNpb25zW3RoaXMubmFtZV0gfHwge307XG4gICAgY29uc3QgbGlnaHREZWZzID0gZXh0ZW5zaW9ucy5saWdodHMgfHwgW107XG4gICAgY29uc3QgbGlnaHREZWYgPSBsaWdodERlZnNbbGlnaHRJbmRleF07XG4gICAgbGV0IGxpZ2h0Tm9kZTtcbiAgICBjb25zdCBjb2xvciA9IG5ldyBDb2xvcigxNjc3NzIxNSk7XG4gICAgaWYgKGxpZ2h0RGVmLmNvbG9yICE9PSB2b2lkIDApXG4gICAgICBjb2xvci5zZXRSR0IobGlnaHREZWYuY29sb3JbMF0sIGxpZ2h0RGVmLmNvbG9yWzFdLCBsaWdodERlZi5jb2xvclsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgIGNvbnN0IHJhbmdlID0gbGlnaHREZWYucmFuZ2UgIT09IHZvaWQgMCA/IGxpZ2h0RGVmLnJhbmdlIDogMDtcbiAgICBzd2l0Y2ggKGxpZ2h0RGVmLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJkaXJlY3Rpb25hbFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgRGlyZWN0aW9uYWxMaWdodChjb2xvcik7XG4gICAgICAgIGxpZ2h0Tm9kZS50YXJnZXQucG9zaXRpb24uc2V0KDAsIDAsIC0xKTtcbiAgICAgICAgbGlnaHROb2RlLmFkZChsaWdodE5vZGUudGFyZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9pbnRcIjpcbiAgICAgICAgbGlnaHROb2RlID0gbmV3IFBvaW50TGlnaHQoY29sb3IpO1xuICAgICAgICBsaWdodE5vZGUuZGlzdGFuY2UgPSByYW5nZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3BvdFwiOlxuICAgICAgICBsaWdodE5vZGUgPSBuZXcgU3BvdExpZ2h0KGNvbG9yKTtcbiAgICAgICAgbGlnaHROb2RlLmRpc3RhbmNlID0gcmFuZ2U7XG4gICAgICAgIGxpZ2h0RGVmLnNwb3QgPSBsaWdodERlZi5zcG90IHx8IHt9O1xuICAgICAgICBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlID0gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSAhPT0gdm9pZCAwID8gbGlnaHREZWYuc3BvdC5pbm5lckNvbmVBbmdsZSA6IDA7XG4gICAgICAgIGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGUgPSBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlICE9PSB2b2lkIDAgPyBsaWdodERlZi5zcG90Lm91dGVyQ29uZUFuZ2xlIDogTWF0aC5QSSAvIDQ7XG4gICAgICAgIGxpZ2h0Tm9kZS5hbmdsZSA9IGxpZ2h0RGVmLnNwb3Qub3V0ZXJDb25lQW5nbGU7XG4gICAgICAgIGxpZ2h0Tm9kZS5wZW51bWJyYSA9IDEgLSBsaWdodERlZi5zcG90LmlubmVyQ29uZUFuZ2xlIC8gbGlnaHREZWYuc3BvdC5vdXRlckNvbmVBbmdsZTtcbiAgICAgICAgbGlnaHROb2RlLnRhcmdldC5wb3NpdGlvbi5zZXQoMCwgMCwgLTEpO1xuICAgICAgICBsaWdodE5vZGUuYWRkKGxpZ2h0Tm9kZS50YXJnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuZXhwZWN0ZWQgbGlnaHQgdHlwZTogXCIgKyBsaWdodERlZi50eXBlKTtcbiAgICB9XG4gICAgbGlnaHROb2RlLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICBsaWdodE5vZGUuZGVjYXkgPSAyO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEobGlnaHROb2RlLCBsaWdodERlZik7XG4gICAgaWYgKGxpZ2h0RGVmLmludGVuc2l0eSAhPT0gdm9pZCAwKVxuICAgICAgbGlnaHROb2RlLmludGVuc2l0eSA9IGxpZ2h0RGVmLmludGVuc2l0eTtcbiAgICBsaWdodE5vZGUubmFtZSA9IHBhcnNlci5jcmVhdGVVbmlxdWVOYW1lKGxpZ2h0RGVmLm5hbWUgfHwgXCJsaWdodF9cIiArIGxpZ2h0SW5kZXgpO1xuICAgIGRlcGVuZGVuY3kgPSBQcm9taXNlLnJlc29sdmUobGlnaHROb2RlKTtcbiAgICBwYXJzZXIuY2FjaGUuYWRkKGNhY2hlS2V5LCBkZXBlbmRlbmN5KTtcbiAgICByZXR1cm4gZGVwZW5kZW5jeTtcbiAgfVxuICBnZXREZXBlbmRlbmN5KHR5cGUsIGluZGV4KSB7XG4gICAgaWYgKHR5cGUgIT09IFwibGlnaHRcIilcbiAgICAgIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy5fbG9hZExpZ2h0KGluZGV4KTtcbiAgfVxuICBjcmVhdGVOb2RlQXR0YWNobWVudChub2RlSW5kZXgpIHtcbiAgICBjb25zdCBzZWxmMiA9IHRoaXM7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgY29uc3QgbGlnaHREZWYgPSBub2RlRGVmLmV4dGVuc2lvbnMgJiYgbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gfHwge307XG4gICAgY29uc3QgbGlnaHRJbmRleCA9IGxpZ2h0RGVmLmxpZ2h0O1xuICAgIGlmIChsaWdodEluZGV4ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fbG9hZExpZ2h0KGxpZ2h0SW5kZXgpLnRoZW4oZnVuY3Rpb24obGlnaHQpIHtcbiAgICAgIHJldHVybiBwYXJzZXIuX2dldE5vZGVSZWYoc2VsZjIuY2FjaGUsIGxpZ2h0SW5kZXgsIGxpZ2h0KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc1VubGl0RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1VOTElUO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZSgpIHtcbiAgICByZXR1cm4gTWVzaEJhc2ljTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kUGFyYW1zKG1hdGVyaWFsUGFyYW1zLCBtYXRlcmlhbERlZiwgcGFyc2VyKSB7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yID0gbmV3IENvbG9yKDEsIDEsIDEpO1xuICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSAxO1xuICAgIGNvbnN0IG1ldGFsbGljUm91Z2huZXNzID0gbWF0ZXJpYWxEZWYucGJyTWV0YWxsaWNSb3VnaG5lc3M7XG4gICAgaWYgKG1ldGFsbGljUm91Z2huZXNzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3IpKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yRmFjdG9yO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5jb2xvci5zZXRSR0IoYXJyYXlbMF0sIGFycmF5WzFdLCBhcnJheVsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gYXJyYXlbM107XG4gICAgICB9XG4gICAgICBpZiAobWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJtYXBcIiwgbWV0YWxsaWNSb3VnaG5lc3MuYmFzZUNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzRW1pc3NpdmVTdHJlbmd0aEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IGVtaXNzaXZlU3RyZW5ndGggPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0uZW1pc3NpdmVTdHJlbmd0aDtcbiAgICBpZiAoZW1pc3NpdmVTdHJlbmd0aCAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5lbWlzc2l2ZUludGVuc2l0eSA9IGVtaXNzaXZlU3RyZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuY2xhc3MgR0xURk1hdGVyaWFsc0NsZWFyY29hdEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19DTEVBUkNPQVQ7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0ID0gZXh0ZW5zaW9uLmNsZWFyY29hdEZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXRNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdFRleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NGYWN0b3IgIT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY2xlYXJjb2F0Um91Z2huZXNzID0gZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc0ZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXRSb3VnaG5lc3NUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXRSb3VnaG5lc3NNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdFJvdWdobmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5jbGVhcmNvYXROb3JtYWxUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJjbGVhcmNvYXROb3JtYWxNYXBcIiwgZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUpKTtcbiAgICAgIGlmIChleHRlbnNpb24uY2xlYXJjb2F0Tm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gZXh0ZW5zaW9uLmNsZWFyY29hdE5vcm1hbFRleHR1cmUuc2NhbGU7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNsZWFyY29hdE5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoc2NhbGUsIHNjYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzRGlzcGVyc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19ESVNQRVJTSU9OO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuZGlzcGVyc2lvbiA9IGV4dGVuc2lvbi5kaXNwZXJzaW9uICE9PSB2b2lkIDAgPyBleHRlbnNpb24uZGlzcGVyc2lvbiA6IDA7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzSXJpZGVzY2VuY2VFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfSVJJREVTQ0VOQ0U7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZUZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZSA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZUZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImlyaWRlc2NlbmNlTWFwXCIsIGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRleHR1cmUpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZUlvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZUlPUiA9IGV4dGVuc2lvbi5pcmlkZXNjZW5jZUlvcjtcbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2UgPT09IHZvaWQgMCkge1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSA9IFsxMDAsIDQwMF07XG4gICAgfVxuICAgIGlmIChleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmlyaWRlc2NlbmNlVGhpY2tuZXNzUmFuZ2VbMF0gPSBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NNaW5pbXVtO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5pcmlkZXNjZW5jZVRoaWNrbmVzc1JhbmdlWzFdID0gZXh0ZW5zaW9uLmlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5pcmlkZXNjZW5jZVRoaWNrbmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKFxuICAgICAgICBwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJpcmlkZXNjZW5jZVRoaWNrbmVzc01hcFwiLCBleHRlbnNpb24uaXJpZGVzY2VuY2VUaGlja25lc3NUZXh0dXJlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzU2hlZW5FeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfU0hFRU47XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbkNvbG9yID0gbmV3IENvbG9yKDAsIDAsIDApO1xuICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gMDtcbiAgICBtYXRlcmlhbFBhcmFtcy5zaGVlbiA9IDE7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uc2hlZW5Db2xvckZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBjb2xvckZhY3RvciA9IGV4dGVuc2lvbi5zaGVlbkNvbG9yRmFjdG9yO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuc2hlZW5Db2xvci5zZXRSR0IoY29sb3JGYWN0b3JbMF0sIGNvbG9yRmFjdG9yWzFdLCBjb2xvckZhY3RvclsyXSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNoZWVuUm91Z2huZXNzID0gZXh0ZW5zaW9uLnNoZWVuUm91Z2huZXNzRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnNoZWVuQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJzaGVlbkNvbG9yTWFwXCIsIGV4dGVuc2lvbi5zaGVlbkNvbG9yVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNoZWVuUm91Z2huZXNzTWFwXCIsIGV4dGVuc2lvbi5zaGVlblJvdWdobmVzc1RleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzVHJhbnNtaXNzaW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX1RSQU5TTUlTU0lPTjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXTtcbiAgICBpZiAoZXh0ZW5zaW9uLnRyYW5zbWlzc2lvbkZhY3RvciAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc21pc3Npb24gPSBleHRlbnNpb24udHJhbnNtaXNzaW9uRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLnRyYW5zbWlzc2lvblRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInRyYW5zbWlzc2lvbk1hcFwiLCBleHRlbnNpb24udHJhbnNtaXNzaW9uVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZNYXRlcmlhbHNWb2x1bWVFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVk9MVU1FO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLnRoaWNrbmVzcyA9IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi50aGlja25lc3NGYWN0b3IgOiAwO1xuICAgIGlmIChleHRlbnNpb24udGhpY2tuZXNzVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwidGhpY2tuZXNzTWFwXCIsIGV4dGVuc2lvbi50aGlja25lc3NUZXh0dXJlKSk7XG4gICAgfVxuICAgIG1hdGVyaWFsUGFyYW1zLmF0dGVudWF0aW9uRGlzdGFuY2UgPSBleHRlbnNpb24uYXR0ZW51YXRpb25EaXN0YW5jZSB8fCBJbmZpbml0eTtcbiAgICBjb25zdCBjb2xvckFycmF5ID0gZXh0ZW5zaW9uLmF0dGVudWF0aW9uQ29sb3IgfHwgWzEsIDEsIDFdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmF0dGVudWF0aW9uQ29sb3IgPSBuZXcgQ29sb3IoKS5zZXRSR0IoXG4gICAgICBjb2xvckFycmF5WzBdLFxuICAgICAgY29sb3JBcnJheVsxXSxcbiAgICAgIGNvbG9yQXJyYXlbMl0sXG4gICAgICBMaW5lYXJTUkdCQ29sb3JTcGFjZVxuICAgICk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzSW9yRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUFURVJJQUxTX0lPUjtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUobWF0ZXJpYWxJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xuICB9XG4gIGV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmlvciA9IGV4dGVuc2lvbi5pb3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5pb3IgOiAxLjU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzU3BlY3VsYXJFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfU1BFQ1VMQVI7XG4gIH1cbiAgZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcbiAgfVxuICBleHRlbmRNYXRlcmlhbFBhcmFtcyhtYXRlcmlhbEluZGV4LCBtYXRlcmlhbFBhcmFtcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXMucGFyc2VyO1xuICAgIGNvbnN0IG1hdGVyaWFsRGVmID0gcGFyc2VyLmpzb24ubWF0ZXJpYWxzW21hdGVyaWFsSW5kZXhdO1xuICAgIGlmICghbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCAhbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgbWF0ZXJpYWxQYXJhbXMuc3BlY3VsYXJJbnRlbnNpdHkgPSBleHRlbnNpb24uc3BlY3VsYXJGYWN0b3IgIT09IHZvaWQgMCA/IGV4dGVuc2lvbi5zcGVjdWxhckZhY3RvciA6IDE7XG4gICAgaWYgKGV4dGVuc2lvbi5zcGVjdWxhclRleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcInNwZWN1bGFySW50ZW5zaXR5TWFwXCIsIGV4dGVuc2lvbi5zcGVjdWxhclRleHR1cmUpKTtcbiAgICB9XG4gICAgY29uc3QgY29sb3JBcnJheSA9IGV4dGVuc2lvbi5zcGVjdWxhckNvbG9yRmFjdG9yIHx8IFsxLCAxLCAxXTtcbiAgICBtYXRlcmlhbFBhcmFtcy5zcGVjdWxhckNvbG9yID0gbmV3IENvbG9yKCkuc2V0UkdCKGNvbG9yQXJyYXlbMF0sIGNvbG9yQXJyYXlbMV0sIGNvbG9yQXJyYXlbMl0sIExpbmVhclNSR0JDb2xvclNwYWNlKTtcbiAgICBpZiAoZXh0ZW5zaW9uLnNwZWN1bGFyQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwic3BlY3VsYXJDb2xvck1hcFwiLCBleHRlbnNpb24uc3BlY3VsYXJDb2xvclRleHR1cmUsIFNSR0JDb2xvclNwYWNlKVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQnVtcEV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01BVEVSSUFMU19CVU1QO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIG1hdGVyaWFsUGFyYW1zLmJ1bXBTY2FsZSA9IGV4dGVuc2lvbi5idW1wRmFjdG9yICE9PSB2b2lkIDAgPyBleHRlbnNpb24uYnVtcEZhY3RvciA6IDE7XG4gICAgaWYgKGV4dGVuc2lvbi5idW1wVGV4dHVyZSAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwiYnVtcE1hcFwiLCBleHRlbnNpb24uYnVtcFRleHR1cmUpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpO1xuICB9XG59XG5jbGFzcyBHTFRGTWF0ZXJpYWxzQW5pc290cm9weUV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19BTklTT1RST1BZO1xuICB9XG4gIGdldE1hdGVyaWFsVHlwZShtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBwYXJzZXIuanNvbi5tYXRlcmlhbHNbbWF0ZXJpYWxJbmRleF07XG4gICAgaWYgKCFtYXRlcmlhbERlZi5leHRlbnNpb25zIHx8ICFtYXRlcmlhbERlZi5leHRlbnNpb25zW3RoaXMubmFtZV0pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gIH1cbiAgZXh0ZW5kTWF0ZXJpYWxQYXJhbXMobWF0ZXJpYWxJbmRleCwgbWF0ZXJpYWxQYXJhbXMpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBtYXRlcmlhbERlZiA9IHBhcnNlci5qc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBpZiAoIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnMgfHwgIW1hdGVyaWFsRGVmLmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGlmIChleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLmFuaXNvdHJvcHkgPSBleHRlbnNpb24uYW5pc290cm9weVN0cmVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlSb3RhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5hbmlzb3Ryb3B5Um90YXRpb24gPSBleHRlbnNpb24uYW5pc290cm9weVJvdGF0aW9uO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9uLmFuaXNvdHJvcHlUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChwYXJzZXIuYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgXCJhbmlzb3Ryb3B5TWFwXCIsIGV4dGVuc2lvbi5hbmlzb3Ryb3B5VGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZyk7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlQmFzaXNVRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IocGFyc2VyKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9CQVNJU1U7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXI7XG4gICAgY29uc3QganNvbiA9IHBhcnNlci5qc29uO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgaWYgKCF0ZXh0dXJlRGVmLmV4dGVuc2lvbnMgfHwgIXRleHR1cmVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgY29uc3QgbG9hZGVyID0gcGFyc2VyLm9wdGlvbnMua3R4MkxvYWRlcjtcbiAgICBpZiAoIWxvYWRlcikge1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YodGhpcy5uYW1lKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IHNldEtUWDJMb2FkZXIgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgS1RYMiB0ZXh0dXJlc1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZVdlYlBFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX1dFQlA7XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIGNvbnN0IHNvdXJjZSA9IGpzb24uaW1hZ2VzW2V4dGVuc2lvbi5zb3VyY2VdO1xuICAgIGxldCBsb2FkZXIgPSBwYXJzZXIudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2UudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbihmdW5jdGlvbihpc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBXZWJQIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZGV0ZWN0U3VwcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmlJQUFBQlhSVUpRVmxBNElCWUFBQUF3QVFDZEFTb0JBQUVBRHNEK0phUUFBM0FBQUFBQVwiO1xuICAgICAgICBpbWFnZS5vbmxvYWQgPSBpbWFnZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZS5oZWlnaHQgPT09IDEpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlzU3VwcG9ydGVkO1xuICB9XG59XG5jbGFzcyBHTFRGVGV4dHVyZUFWSUZFeHRlbnNpb24ge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLkVYVF9URVhUVVJFX0FWSUY7XG4gICAgdGhpcy5pc1N1cHBvcnRlZCA9IG51bGw7XG4gIH1cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzLnBhcnNlcjtcbiAgICBjb25zdCBqc29uID0gcGFyc2VyLmpzb247XG4gICAgY29uc3QgdGV4dHVyZURlZiA9IGpzb24udGV4dHVyZXNbdGV4dHVyZUluZGV4XTtcbiAgICBpZiAoIXRleHR1cmVEZWYuZXh0ZW5zaW9ucyB8fCAhdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gdGV4dHVyZURlZi5leHRlbnNpb25zW25hbWVdO1xuICAgIGNvbnN0IHNvdXJjZSA9IGpzb24uaW1hZ2VzW2V4dGVuc2lvbi5zb3VyY2VdO1xuICAgIGxldCBsb2FkZXIgPSBwYXJzZXIudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHBhcnNlci5vcHRpb25zLm1hbmFnZXIuZ2V0SGFuZGxlcihzb3VyY2UudXJpKTtcbiAgICAgIGlmIChoYW5kbGVyICE9PSBudWxsKVxuICAgICAgICBsb2FkZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kZXRlY3RTdXBwb3J0KCkudGhlbihmdW5jdGlvbihpc1N1cHBvcnRlZCkge1xuICAgICAgaWYgKGlzU3VwcG9ydGVkKVxuICAgICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBleHRlbnNpb24uc291cmNlLCBsb2FkZXIpO1xuICAgICAgaWYgKGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkICYmIGpzb24uZXh0ZW5zaW9uc1JlcXVpcmVkLmluZGV4T2YobmFtZSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBBVklGIHJlcXVpcmVkIGJ5IGFzc2V0IGJ1dCB1bnN1cHBvcnRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VyLmxvYWRUZXh0dXJlKHRleHR1cmVJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgZGV0ZWN0U3VwcG9ydCgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuaXNTdXBwb3J0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS9hdmlmO2Jhc2U2NCxBQUFBSUdaMGVYQmhkbWxtQUFBQUFHRjJhV1p0YVdZeGJXbGhaazFCTVVJQUFBRHliV1YwWVFBQUFBQUFBQUFvYUdSc2NnQUFBQUFBQUFBQWNHbGpkQUFBQUFBQUFBQUFBQUFBQUd4cFltRjJhV1lBQUFBQURuQnBkRzBBQUFBQUFBRUFBQUFlYVd4dll3QUFBQUJFQUFBQkFBRUFBQUFCQUFBQkdnQUFBQmNBQUFBb2FXbHVaZ0FBQUFBQUFRQUFBQnBwYm1abEFnQUFBQUFCQUFCaGRqQXhRMjlzYjNJQUFBQUFhbWx3Y25BQUFBQkxhWEJqYndBQUFCUnBjM0JsQUFBQUFBQUFBQUVBQUFBQkFBQUFFSEJwZUdrQUFBQUFBd2dJQ0FBQUFBeGhkakZEZ1FBTUFBQUFBQk5qYjJ4eWJtTnNlQUFDQUFJQUJvQUFBQUFYYVhCdFlRQUFBQUFBQUFBQkFBRUVBUUtEQkFBQUFCOXRaR0YwRWdBS0NCZ0FCb2dRRURRZ01na1FBQUFBQjhkU0xmST1cIjtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UuaGVpZ2h0ID09PSAxKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc1N1cHBvcnRlZDtcbiAgfVxufVxuY2xhc3MgR0xURk1lc2hvcHRDb21wcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hPUFRfQ09NUFJFU1NJT047XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgbG9hZEJ1ZmZlclZpZXcoaW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5wYXJzZXIuanNvbjtcbiAgICBjb25zdCBidWZmZXJWaWV3ID0ganNvbi5idWZmZXJWaWV3c1tpbmRleF07XG4gICAgaWYgKGJ1ZmZlclZpZXcuZXh0ZW5zaW9ucyAmJiBidWZmZXJWaWV3LmV4dGVuc2lvbnNbdGhpcy5uYW1lXSkge1xuICAgICAgY29uc3QgZXh0ZW5zaW9uRGVmID0gYnVmZmVyVmlldy5leHRlbnNpb25zW3RoaXMubmFtZV07XG4gICAgICBjb25zdCBidWZmZXIgPSB0aGlzLnBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyXCIsIGV4dGVuc2lvbkRlZi5idWZmZXIpO1xuICAgICAgY29uc3QgZGVjb2RlciA9IHRoaXMucGFyc2VyLm9wdGlvbnMubWVzaG9wdERlY29kZXI7XG4gICAgICBpZiAoIWRlY29kZXIgfHwgIWRlY29kZXIuc3VwcG9ydGVkKSB7XG4gICAgICAgIGlmIChqc29uLmV4dGVuc2lvbnNSZXF1aXJlZCAmJiBqc29uLmV4dGVuc2lvbnNSZXF1aXJlZC5pbmRleE9mKHRoaXMubmFtZSkgPj0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IHNldE1lc2hvcHREZWNvZGVyIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIGNvbXByZXNzZWQgZmlsZXNcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXIudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGV4dGVuc2lvbkRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBleHRlbnNpb25EZWYuYnl0ZUxlbmd0aCB8fCAwO1xuICAgICAgICBjb25zdCBjb3VudCA9IGV4dGVuc2lvbkRlZi5jb3VudDtcbiAgICAgICAgY29uc3Qgc3RyaWRlID0gZXh0ZW5zaW9uRGVmLmJ5dGVTdHJpZGU7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBVaW50OEFycmF5KHJlcywgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIGlmIChkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXJBc3luYykge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZUdsdGZCdWZmZXJBc3luYyhjb3VudCwgc3RyaWRlLCBzb3VyY2UsIGV4dGVuc2lvbkRlZi5tb2RlLCBleHRlbnNpb25EZWYuZmlsdGVyKS50aGVuKGZ1bmN0aW9uKHJlczIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMyLmJ1ZmZlcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2Rlci5yZWFkeS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5QnVmZmVyKGNvdW50ICogc3RyaWRlKTtcbiAgICAgICAgICAgIGRlY29kZXIuZGVjb2RlR2x0ZkJ1ZmZlcihcbiAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KSxcbiAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgIHN0cmlkZSxcbiAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICBleHRlbnNpb25EZWYubW9kZSxcbiAgICAgICAgICAgICAgZXh0ZW5zaW9uRGVmLmZpbHRlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNoR3B1SW5zdGFuY2luZyB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuRVhUX01FU0hfR1BVX0lOU1RBTkNJTkc7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMucGFyc2VyLmpzb247XG4gICAgY29uc3Qgbm9kZURlZiA9IGpzb24ubm9kZXNbbm9kZUluZGV4XTtcbiAgICBpZiAoIW5vZGVEZWYuZXh0ZW5zaW9ucyB8fCAhbm9kZURlZi5leHRlbnNpb25zW3RoaXMubmFtZV0gfHwgbm9kZURlZi5tZXNoID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtZXNoRGVmID0ganNvbi5tZXNoZXNbbm9kZURlZi5tZXNoXTtcbiAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBtZXNoRGVmLnByaW1pdGl2ZXMpIHtcbiAgICAgIGlmIChwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFUyAmJiBwcmltaXRpdmUubW9kZSAhPT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQICYmIHByaW1pdGl2ZS5tb2RlICE9PSBXRUJHTF9DT05TVEFOVFMuVFJJQU5HTEVfRkFOICYmIHByaW1pdGl2ZS5tb2RlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbkRlZiA9IG5vZGVEZWYuZXh0ZW5zaW9uc1t0aGlzLm5hbWVdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXNEZWYgPSBleHRlbnNpb25EZWYuYXR0cmlidXRlcztcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXNEZWYpIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGF0dHJpYnV0ZXNEZWZba2V5XSkudGhlbigoYWNjZXNzb3IpID0+IHtcbiAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSBhY2Nlc3NvcjtcbiAgICAgICAgICByZXR1cm4gYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoIDwgMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlbmRpbmcucHVzaCh0aGlzLnBhcnNlci5jcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocGVuZGluZykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgY29uc3Qgbm9kZU9iamVjdCA9IHJlc3VsdHMucG9wKCk7XG4gICAgICBjb25zdCBtZXNoZXMgPSBub2RlT2JqZWN0LmlzR3JvdXAgPyBub2RlT2JqZWN0LmNoaWxkcmVuIDogW25vZGVPYmplY3RdO1xuICAgICAgY29uc3QgY291bnQgPSByZXN1bHRzWzBdLmNvdW50O1xuICAgICAgY29uc3QgaW5zdGFuY2VkTWVzaGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG1lc2ggb2YgbWVzaGVzKSB7XG4gICAgICAgIGNvbnN0IG0gPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICBjb25zdCBwID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgY29uc3QgcSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICAgIGNvbnN0IHMgPSBuZXcgVmVjdG9yMygxLCAxLCAxKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2VkTWVzaCA9IG5ldyBJbnN0YW5jZWRNZXNoKG1lc2guZ2VvbWV0cnksIG1lc2gubWF0ZXJpYWwsIGNvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuVFJBTlNMQVRJT04pIHtcbiAgICAgICAgICAgIHAuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlRSQU5TTEFUSU9OLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuUk9UQVRJT04pIHtcbiAgICAgICAgICAgIHEuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlJPVEFUSU9OLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZXMuU0NBTEUpIHtcbiAgICAgICAgICAgIHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhdHRyaWJ1dGVzLlNDQUxFLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2VkTWVzaC5zZXRNYXRyaXhBdChpLCBtLmNvbXBvc2UocCwgcSwgcykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwiX0NPTE9SXzBcIikge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICBpbnN0YW5jZWRNZXNoLmluc3RhbmNlQ29sb3IgPSBuZXcgSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKGF0dHIuYXJyYXksIGF0dHIuaXRlbVNpemUsIGF0dHIubm9ybWFsaXplZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lICE9PSBcIlRSQU5TTEFUSU9OXCIgJiYgYXR0cmlidXRlTmFtZSAhPT0gXCJST1RBVElPTlwiICYmIGF0dHJpYnV0ZU5hbWUgIT09IFwiU0NBTEVcIikge1xuICAgICAgICAgICAgbWVzaC5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoaW5zdGFuY2VkTWVzaCwgbWVzaCk7XG4gICAgICAgIHRoaXMucGFyc2VyLmFzc2lnbkZpbmFsTWF0ZXJpYWwoaW5zdGFuY2VkTWVzaCk7XG4gICAgICAgIGluc3RhbmNlZE1lc2hlcy5wdXNoKGluc3RhbmNlZE1lc2gpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVPYmplY3QuaXNHcm91cCkge1xuICAgICAgICBub2RlT2JqZWN0LmNsZWFyKCk7XG4gICAgICAgIG5vZGVPYmplY3QuYWRkKC4uLmluc3RhbmNlZE1lc2hlcyk7XG4gICAgICAgIHJldHVybiBub2RlT2JqZWN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlZE1lc2hlc1swXTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMgPSBcImdsVEZcIjtcbmNvbnN0IEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCA9IDEyO1xuY29uc3QgQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyA9IHsgSlNPTjogMTMxMzgyMTUxNCwgQklOOiA1MTMwNTYyIH07XG5jbGFzcyBHTFRGQmluYXJ5RXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMubmFtZSA9IEVYVEVOU0lPTlMuS0hSX0JJTkFSWV9HTFRGO1xuICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICBjb25zdCBoZWFkZXJWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEsIDAsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCk7XG4gICAgdGhpcy5oZWFkZXIgPSB7XG4gICAgICBtYWdpYzogZGVjb2RlVGV4dChuZXcgVWludDhBcnJheShkYXRhLnNsaWNlKDAsIDQpKSksXG4gICAgICB2ZXJzaW9uOiBoZWFkZXJWaWV3LmdldFVpbnQzMig0LCB0cnVlKSxcbiAgICAgIGxlbmd0aDogaGVhZGVyVmlldy5nZXRVaW50MzIoOCwgdHJ1ZSlcbiAgICB9O1xuICAgIGlmICh0aGlzLmhlYWRlci5tYWdpYyAhPT0gQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFVuc3VwcG9ydGVkIGdsVEYtQmluYXJ5IGhlYWRlci5cIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhlYWRlci52ZXJzaW9uIDwgMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogTGVnYWN5IGJpbmFyeSBmaWxlIGRldGVjdGVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtDb250ZW50c0xlbmd0aCA9IHRoaXMuaGVhZGVyLmxlbmd0aCAtIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSDtcbiAgICBjb25zdCBjaHVua1ZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YSwgQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIKTtcbiAgICBsZXQgY2h1bmtJbmRleCA9IDA7XG4gICAgd2hpbGUgKGNodW5rSW5kZXggPCBjaHVua0NvbnRlbnRzTGVuZ3RoKSB7XG4gICAgICBjb25zdCBjaHVua0xlbmd0aCA9IGNodW5rVmlldy5nZXRVaW50MzIoY2h1bmtJbmRleCwgdHJ1ZSk7XG4gICAgICBjaHVua0luZGV4ICs9IDQ7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVua1ZpZXcuZ2V0VWludDMyKGNodW5rSW5kZXgsIHRydWUpO1xuICAgICAgY2h1bmtJbmRleCArPSA0O1xuICAgICAgaWYgKGNodW5rVHlwZSA9PT0gQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUy5KU09OKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEsIEJJTkFSWV9FWFRFTlNJT05fSEVBREVSX0xFTkdUSCArIGNodW5rSW5kZXgsIGNodW5rTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gZGVjb2RlVGV4dChjb250ZW50QXJyYXkpO1xuICAgICAgfSBlbHNlIGlmIChjaHVua1R5cGUgPT09IEJJTkFSWV9FWFRFTlNJT05fQ0hVTktfVFlQRVMuQklOKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBCSU5BUllfRVhURU5TSU9OX0hFQURFUl9MRU5HVEggKyBjaHVua0luZGV4O1xuICAgICAgICB0aGlzLmJvZHkgPSBkYXRhLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBjaHVua0xlbmd0aCk7XG4gICAgICB9XG4gICAgICBjaHVua0luZGV4ICs9IGNodW5rTGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250ZW50ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBKU09OIGNvbnRlbnQgbm90IGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiB7XG4gIGNvbnN0cnVjdG9yKGpzb24sIGRyYWNvTG9hZGVyKSB7XG4gICAgaWYgKCFkcmFjb0xvYWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogTm8gRFJBQ09Mb2FkZXIgaW5zdGFuY2UgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OO1xuICAgIHRoaXMuanNvbiA9IGpzb247XG4gICAgdGhpcy5kcmFjb0xvYWRlciA9IGRyYWNvTG9hZGVyO1xuICAgIHRoaXMuZHJhY29Mb2FkZXIucHJlbG9hZCgpO1xuICB9XG4gIGRlY29kZVByaW1pdGl2ZShwcmltaXRpdmUsIHBhcnNlcikge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZHJhY29Mb2FkZXIgPSB0aGlzLmRyYWNvTG9hZGVyO1xuICAgIGNvbnN0IGJ1ZmZlclZpZXdJbmRleCA9IHByaW1pdGl2ZS5leHRlbnNpb25zW3RoaXMubmFtZV0uYnVmZmVyVmlldztcbiAgICBjb25zdCBnbHRmQXR0cmlidXRlTWFwID0gcHJpbWl0aXZlLmV4dGVuc2lvbnNbdGhpcy5uYW1lXS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHRocmVlQXR0cmlidXRlTWFwID0ge307XG4gICAgY29uc3QgYXR0cmlidXRlTm9ybWFsaXplZE1hcCA9IHt9O1xuICAgIGNvbnN0IGF0dHJpYnV0ZVR5cGVNYXAgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZU5hbWUgaW4gZ2x0ZkF0dHJpYnV0ZU1hcCkge1xuICAgICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1thdHRyaWJ1dGVOYW1lXSB8fCBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aHJlZUF0dHJpYnV0ZU1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gZ2x0ZkF0dHJpYnV0ZU1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIHByaW1pdGl2ZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBjb25zdCB0aHJlZUF0dHJpYnV0ZU5hbWUgPSBBVFRSSUJVVEVTW2F0dHJpYnV0ZU5hbWVdIHx8IGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChnbHRmQXR0cmlidXRlTWFwW2F0dHJpYnV0ZU5hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgYWNjZXNzb3JEZWYgPSBqc29uLmFjY2Vzc29yc1twcmltaXRpdmUuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXV07XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudFR5cGUgPSBXRUJHTF9DT01QT05FTlRfVFlQRVNbYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZV07XG4gICAgICAgIGF0dHJpYnV0ZVR5cGVNYXBbdGhyZWVBdHRyaWJ1dGVOYW1lXSA9IGNvbXBvbmVudFR5cGUubmFtZTtcbiAgICAgICAgYXR0cmlidXRlTm9ybWFsaXplZE1hcFt0aHJlZUF0dHJpYnV0ZU5hbWVdID0gYWNjZXNzb3JEZWYubm9ybWFsaXplZCA9PT0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBidWZmZXJWaWV3SW5kZXgpLnRoZW4oZnVuY3Rpb24oYnVmZmVyVmlldykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBkcmFjb0xvYWRlci5kZWNvZGVEcmFjb0ZpbGUoXG4gICAgICAgICAgYnVmZmVyVmlldyxcbiAgICAgICAgICBmdW5jdGlvbihnZW9tZXRyeSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgIGlmIChub3JtYWxpemVkICE9PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShnZW9tZXRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJlZUF0dHJpYnV0ZU1hcCxcbiAgICAgICAgICBhdHRyaWJ1dGVUeXBlTWFwLFxuICAgICAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlLFxuICAgICAgICAgIHJlamVjdFxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk07XG4gIH1cbiAgZXh0ZW5kVGV4dHVyZSh0ZXh0dXJlLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAoKHRyYW5zZm9ybS50ZXhDb29yZCA9PT0gdm9pZCAwIHx8IHRyYW5zZm9ybS50ZXhDb29yZCA9PT0gdGV4dHVyZS5jaGFubmVsKSAmJiB0cmFuc2Zvcm0ub2Zmc2V0ID09PSB2b2lkIDAgJiYgdHJhbnNmb3JtLnJvdGF0aW9uID09PSB2b2lkIDAgJiYgdHJhbnNmb3JtLnNjYWxlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cbiAgICB0ZXh0dXJlID0gdGV4dHVyZS5jbG9uZSgpO1xuICAgIGlmICh0cmFuc2Zvcm0udGV4Q29vcmQgIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5jaGFubmVsID0gdHJhbnNmb3JtLnRleENvb3JkO1xuICAgIH1cbiAgICBpZiAodHJhbnNmb3JtLm9mZnNldCAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkodHJhbnNmb3JtLm9mZnNldCk7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ucm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgdGV4dHVyZS5yb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkodHJhbnNmb3JtLnNjYWxlKTtcbiAgICB9XG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbn1cbmNsYXNzIEdMVEZNZXNoUXVhbnRpemF0aW9uRXh0ZW5zaW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5uYW1lID0gRVhURU5TSU9OUy5LSFJfTUVTSF9RVUFOVElaQVRJT047XG4gIH1cbn1cbmNsYXNzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IGV4dGVuZHMgSW50ZXJwb2xhbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyKSB7XG4gICAgc3VwZXIocGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlcik7XG4gIH1cbiAgY29weVNhbXBsZVZhbHVlXyhpbmRleCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLCB2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcywgdmFsdWVTaXplID0gdGhpcy52YWx1ZVNpemUsIG9mZnNldCA9IGluZGV4ICogdmFsdWVTaXplICogMyArIHZhbHVlU2l6ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gdmFsdWVTaXplOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IHZhbHVlc1tvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyO1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzO1xuICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuICAgIGNvbnN0IHN0cmlkZTIgPSBzdHJpZGUgKiAyO1xuICAgIGNvbnN0IHN0cmlkZTMgPSBzdHJpZGUgKiAzO1xuICAgIGNvbnN0IHRkID0gdDEgLSB0MDtcbiAgICBjb25zdCBwID0gKHQgLSB0MCkgLyB0ZDtcbiAgICBjb25zdCBwcCA9IHAgKiBwO1xuICAgIGNvbnN0IHBwcCA9IHBwICogcDtcbiAgICBjb25zdCBvZmZzZXQxID0gaTEgKiBzdHJpZGUzO1xuICAgIGNvbnN0IG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlMztcbiAgICBjb25zdCBzMiA9IC0yICogcHBwICsgMyAqIHBwO1xuICAgIGNvbnN0IHMzID0gcHBwIC0gcHA7XG4gICAgY29uc3QgczAgPSAxIC0gczI7XG4gICAgY29uc3QgczEgPSBzMyAtIHBwICsgcDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAhPT0gc3RyaWRlOyBpKyspIHtcbiAgICAgIGNvbnN0IHAwID0gdmFsdWVzW29mZnNldDAgKyBpICsgc3RyaWRlXTtcbiAgICAgIGNvbnN0IG0wID0gdmFsdWVzW29mZnNldDAgKyBpICsgc3RyaWRlMl0gKiB0ZDtcbiAgICAgIGNvbnN0IHAxID0gdmFsdWVzW29mZnNldDEgKyBpICsgc3RyaWRlXTtcbiAgICAgIGNvbnN0IG0xID0gdmFsdWVzW29mZnNldDEgKyBpXSAqIHRkO1xuICAgICAgcmVzdWx0W2ldID0gczAgKiBwMCArIHMxICogbTAgKyBzMiAqIHAxICsgczMgKiBtMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY29uc3QgX3EgPSAvKiBAX19QVVJFX18gKi8gbmV3IFF1YXRlcm5pb24oKTtcbmNsYXNzIEdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCBleHRlbmRzIEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50IHtcbiAgaW50ZXJwb2xhdGVfKGkxLCB0MCwgdCwgdDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5pbnRlcnBvbGF0ZV8oaTEsIHQwLCB0LCB0MSk7XG4gICAgX3EuZnJvbUFycmF5KHJlc3VsdCkubm9ybWFsaXplKCkudG9BcnJheShyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNvbnN0IFdFQkdMX0NPTlNUQU5UUyA9IHtcbiAgRkxPQVQ6IDUxMjYsXG4gIC8vRkxPQVRfTUFUMjogMzU2NzQsXG4gIEZMT0FUX01BVDM6IDM1Njc1LFxuICBGTE9BVF9NQVQ0OiAzNTY3NixcbiAgRkxPQVRfVkVDMjogMzU2NjQsXG4gIEZMT0FUX1ZFQzM6IDM1NjY1LFxuICBGTE9BVF9WRUM0OiAzNTY2NixcbiAgTElORUFSOiA5NzI5LFxuICBSRVBFQVQ6IDEwNDk3LFxuICBTQU1QTEVSXzJEOiAzNTY3OCxcbiAgUE9JTlRTOiAwLFxuICBMSU5FUzogMSxcbiAgTElORV9MT09QOiAyLFxuICBMSU5FX1NUUklQOiAzLFxuICBUUklBTkdMRVM6IDQsXG4gIFRSSUFOR0xFX1NUUklQOiA1LFxuICBUUklBTkdMRV9GQU46IDYsXG4gIFVOU0lHTkVEX0JZVEU6IDUxMjEsXG4gIFVOU0lHTkVEX1NIT1JUOiA1MTIzXG59O1xuY29uc3QgV0VCR0xfQ09NUE9ORU5UX1RZUEVTID0ge1xuICA1MTIwOiBJbnQ4QXJyYXksXG4gIDUxMjE6IFVpbnQ4QXJyYXksXG4gIDUxMjI6IEludDE2QXJyYXksXG4gIDUxMjM6IFVpbnQxNkFycmF5LFxuICA1MTI1OiBVaW50MzJBcnJheSxcbiAgNTEyNjogRmxvYXQzMkFycmF5XG59O1xuY29uc3QgV0VCR0xfRklMVEVSUyA9IHtcbiAgOTcyODogTmVhcmVzdEZpbHRlcixcbiAgOTcyOTogTGluZWFyRmlsdGVyLFxuICA5OTg0OiBOZWFyZXN0TWlwbWFwTmVhcmVzdEZpbHRlcixcbiAgOTk4NTogTGluZWFyTWlwbWFwTmVhcmVzdEZpbHRlcixcbiAgOTk4NjogTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlcixcbiAgOTk4NzogTGluZWFyTWlwbWFwTGluZWFyRmlsdGVyXG59O1xuY29uc3QgV0VCR0xfV1JBUFBJTkdTID0ge1xuICAzMzA3MTogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcbiAgMzM2NDg6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcsXG4gIDEwNDk3OiBSZXBlYXRXcmFwcGluZ1xufTtcbmNvbnN0IFdFQkdMX1RZUEVfU0laRVMgPSB7XG4gIFNDQUxBUjogMSxcbiAgVkVDMjogMixcbiAgVkVDMzogMyxcbiAgVkVDNDogNCxcbiAgTUFUMjogNCxcbiAgTUFUMzogOSxcbiAgTUFUNDogMTZcbn07XG5jb25zdCBBVFRSSUJVVEVTID0ge1xuICBQT1NJVElPTjogXCJwb3NpdGlvblwiLFxuICBOT1JNQUw6IFwibm9ybWFsXCIsXG4gIFRBTkdFTlQ6IFwidGFuZ2VudFwiLFxuICAvLyB1diA9PiB1djEsIDQgdXYgY2hhbm5lbHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzI1OTQzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yNTc4OFxuICAuLi52ZXJzaW9uID49IDE1MiA/IHtcbiAgICBURVhDT09SRF8wOiBcInV2XCIsXG4gICAgVEVYQ09PUkRfMTogXCJ1djFcIixcbiAgICBURVhDT09SRF8yOiBcInV2MlwiLFxuICAgIFRFWENPT1JEXzM6IFwidXYzXCJcbiAgfSA6IHtcbiAgICBURVhDT09SRF8wOiBcInV2XCIsXG4gICAgVEVYQ09PUkRfMTogXCJ1djJcIlxuICB9LFxuICBDT0xPUl8wOiBcImNvbG9yXCIsXG4gIFdFSUdIVFNfMDogXCJza2luV2VpZ2h0XCIsXG4gIEpPSU5UU18wOiBcInNraW5JbmRleFwiXG59O1xuY29uc3QgUEFUSF9QUk9QRVJUSUVTID0ge1xuICBzY2FsZTogXCJzY2FsZVwiLFxuICB0cmFuc2xhdGlvbjogXCJwb3NpdGlvblwiLFxuICByb3RhdGlvbjogXCJxdWF0ZXJuaW9uXCIsXG4gIHdlaWdodHM6IFwibW9ycGhUYXJnZXRJbmZsdWVuY2VzXCJcbn07XG5jb25zdCBJTlRFUlBPTEFUSU9OID0ge1xuICBDVUJJQ1NQTElORTogdm9pZCAwLFxuICAvLyBXZSB1c2UgYSBjdXN0b20gaW50ZXJwb2xhbnQgKEdMVEZDdWJpY1NwbGluZUludGVycG9sYXRpb24pIGZvciBDVUJJQ1NQTElORSB0cmFja3MuIEVhY2hcbiAgLy8ga2V5ZnJhbWUgdHJhY2sgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGEgZGVmYXVsdCBpbnRlcnBvbGF0aW9uIHR5cGUsIHRoZW4gbW9kaWZpZWQuXG4gIExJTkVBUjogSW50ZXJwb2xhdGVMaW5lYXIsXG4gIFNURVA6IEludGVycG9sYXRlRGlzY3JldGVcbn07XG5jb25zdCBBTFBIQV9NT0RFUyA9IHtcbiAgT1BBUVVFOiBcIk9QQVFVRVwiLFxuICBNQVNLOiBcIk1BU0tcIixcbiAgQkxFTkQ6IFwiQkxFTkRcIlxufTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRNYXRlcmlhbChjYWNoZSkge1xuICBpZiAoY2FjaGVbXCJEZWZhdWx0TWF0ZXJpYWxcIl0gPT09IHZvaWQgMCkge1xuICAgIGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdID0gbmV3IE1lc2hTdGFuZGFyZE1hdGVyaWFsKHtcbiAgICAgIGNvbG9yOiAxNjc3NzIxNSxcbiAgICAgIGVtaXNzaXZlOiAwLFxuICAgICAgbWV0YWxuZXNzOiAxLFxuICAgICAgcm91Z2huZXNzOiAxLFxuICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgZGVwdGhUZXN0OiB0cnVlLFxuICAgICAgc2lkZTogRnJvbnRTaWRlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlW1wiRGVmYXVsdE1hdGVyaWFsXCJdO1xufVxuZnVuY3Rpb24gYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGtub3duRXh0ZW5zaW9ucywgb2JqZWN0LCBvYmplY3REZWYpIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIG9iamVjdERlZi5leHRlbnNpb25zKSB7XG4gICAgaWYgKGtub3duRXh0ZW5zaW9uc1tuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgPSBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnMgfHwge307XG4gICAgICBvYmplY3QudXNlckRhdGEuZ2x0ZkV4dGVuc2lvbnNbbmFtZV0gPSBvYmplY3REZWYuZXh0ZW5zaW9uc1tuYW1lXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEob2JqZWN0LCBnbHRmRGVmKSB7XG4gIGlmIChnbHRmRGVmLmV4dHJhcyAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHR5cGVvZiBnbHRmRGVmLmV4dHJhcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgT2JqZWN0LmFzc2lnbihvYmplY3QudXNlckRhdGEsIGdsdGZEZWYuZXh0cmFzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogSWdub3JpbmcgcHJpbWl0aXZlIHR5cGUgLmV4dHJhcywgXCIgKyBnbHRmRGVmLmV4dHJhcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRNb3JwaFRhcmdldHMoZ2VvbWV0cnksIHRhcmdldHMsIHBhcnNlcikge1xuICBsZXQgaGFzTW9ycGhQb3NpdGlvbiA9IGZhbHNlO1xuICBsZXQgaGFzTW9ycGhOb3JtYWwgPSBmYWxzZTtcbiAgbGV0IGhhc01vcnBoQ29sb3IgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsID0gdGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICBpZiAodGFyZ2V0LlBPU0lUSU9OICE9PSB2b2lkIDApXG4gICAgICBoYXNNb3JwaFBvc2l0aW9uID0gdHJ1ZTtcbiAgICBpZiAodGFyZ2V0Lk5PUk1BTCAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhOb3JtYWwgPSB0cnVlO1xuICAgIGlmICh0YXJnZXQuQ09MT1JfMCAhPT0gdm9pZCAwKVxuICAgICAgaGFzTW9ycGhDb2xvciA9IHRydWU7XG4gICAgaWYgKGhhc01vcnBoUG9zaXRpb24gJiYgaGFzTW9ycGhOb3JtYWwgJiYgaGFzTW9ycGhDb2xvcilcbiAgICAgIGJyZWFrO1xuICB9XG4gIGlmICghaGFzTW9ycGhQb3NpdGlvbiAmJiAhaGFzTW9ycGhOb3JtYWwgJiYgIWhhc01vcnBoQ29sb3IpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZW9tZXRyeSk7XG4gIGNvbnN0IHBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyA9IFtdO1xuICBjb25zdCBwZW5kaW5nTm9ybWFsQWNjZXNzb3JzID0gW107XG4gIGNvbnN0IHBlbmRpbmdDb2xvckFjY2Vzc29ycyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRzW2ldO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwZW5kaW5nQWNjZXNzb3IgPSB0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMCA/IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgdGFyZ2V0LlBPU0lUSU9OKSA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICBwZW5kaW5nUG9zaXRpb25BY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoaGFzTW9ycGhOb3JtYWwpIHtcbiAgICAgIGNvbnN0IHBlbmRpbmdBY2Nlc3NvciA9IHRhcmdldC5OT1JNQUwgIT09IHZvaWQgMCA/IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgdGFyZ2V0Lk5PUk1BTCkgOiBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcbiAgICAgIHBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMucHVzaChwZW5kaW5nQWNjZXNzb3IpO1xuICAgIH1cbiAgICBpZiAoaGFzTW9ycGhDb2xvcikge1xuICAgICAgY29uc3QgcGVuZGluZ0FjY2Vzc29yID0gdGFyZ2V0LkNPTE9SXzAgIT09IHZvaWQgMCA/IHBhcnNlci5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgdGFyZ2V0LkNPTE9SXzApIDogZ2VvbWV0cnkuYXR0cmlidXRlcy5jb2xvcjtcbiAgICAgIHBlbmRpbmdDb2xvckFjY2Vzc29ycy5wdXNoKHBlbmRpbmdBY2Nlc3Nvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgUHJvbWlzZS5hbGwocGVuZGluZ1Bvc2l0aW9uQWNjZXNzb3JzKSxcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nTm9ybWFsQWNjZXNzb3JzKSxcbiAgICBQcm9taXNlLmFsbChwZW5kaW5nQ29sb3JBY2Nlc3NvcnMpXG4gIF0pLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3JzKSB7XG4gICAgY29uc3QgbW9ycGhQb3NpdGlvbnMgPSBhY2Nlc3NvcnNbMF07XG4gICAgY29uc3QgbW9ycGhOb3JtYWxzID0gYWNjZXNzb3JzWzFdO1xuICAgIGNvbnN0IG1vcnBoQ29sb3JzID0gYWNjZXNzb3JzWzJdO1xuICAgIGlmIChoYXNNb3JwaFBvc2l0aW9uKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uID0gbW9ycGhQb3NpdGlvbnM7XG4gICAgaWYgKGhhc01vcnBoTm9ybWFsKVxuICAgICAgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLm5vcm1hbCA9IG1vcnBoTm9ybWFscztcbiAgICBpZiAoaGFzTW9ycGhDb2xvcilcbiAgICAgIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5jb2xvciA9IG1vcnBoQ29sb3JzO1xuICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdHJ1ZTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlTW9ycGhUYXJnZXRzKG1lc2gsIG1lc2hEZWYpIHtcbiAgbWVzaC51cGRhdGVNb3JwaFRhcmdldHMoKTtcbiAgaWYgKG1lc2hEZWYud2VpZ2h0cyAhPT0gdm9pZCAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbWVzaERlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIG1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gbWVzaERlZi53ZWlnaHRzW2ldO1xuICAgIH1cbiAgfVxuICBpZiAobWVzaERlZi5leHRyYXMgJiYgQXJyYXkuaXNBcnJheShtZXNoRGVmLmV4dHJhcy50YXJnZXROYW1lcykpIHtcbiAgICBjb25zdCB0YXJnZXROYW1lcyA9IG1lc2hEZWYuZXh0cmFzLnRhcmdldE5hbWVzO1xuICAgIGlmIChtZXNoLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGggPT09IHRhcmdldE5hbWVzLmxlbmd0aCkge1xuICAgICAgbWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldE5hbWVzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgbWVzaC5tb3JwaFRhcmdldERpY3Rpb25hcnlbdGFyZ2V0TmFtZXNbaV1dID0gaTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogSW52YWxpZCBleHRyYXMudGFyZ2V0TmFtZXMgbGVuZ3RoLiBJZ25vcmluZyBuYW1lcy5cIik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVLZXkocHJpbWl0aXZlRGVmKSB7XG4gIGxldCBnZW9tZXRyeUtleTtcbiAgY29uc3QgZHJhY29FeHRlbnNpb24gPSBwcmltaXRpdmVEZWYuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmVEZWYuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXTtcbiAgaWYgKGRyYWNvRXh0ZW5zaW9uKSB7XG4gICAgZ2VvbWV0cnlLZXkgPSBcImRyYWNvOlwiICsgZHJhY29FeHRlbnNpb24uYnVmZmVyVmlldyArIFwiOlwiICsgZHJhY29FeHRlbnNpb24uaW5kaWNlcyArIFwiOlwiICsgY3JlYXRlQXR0cmlidXRlc0tleShkcmFjb0V4dGVuc2lvbi5hdHRyaWJ1dGVzKTtcbiAgfSBlbHNlIHtcbiAgICBnZW9tZXRyeUtleSA9IHByaW1pdGl2ZURlZi5pbmRpY2VzICsgXCI6XCIgKyBjcmVhdGVBdHRyaWJ1dGVzS2V5KHByaW1pdGl2ZURlZi5hdHRyaWJ1dGVzKSArIFwiOlwiICsgcHJpbWl0aXZlRGVmLm1vZGU7XG4gIH1cbiAgaWYgKHByaW1pdGl2ZURlZi50YXJnZXRzICE9PSB2b2lkIDApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBwcmltaXRpdmVEZWYudGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBnZW9tZXRyeUtleSArPSBcIjpcIiArIGNyZWF0ZUF0dHJpYnV0ZXNLZXkocHJpbWl0aXZlRGVmLnRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VvbWV0cnlLZXk7XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGVzS2V5KGF0dHJpYnV0ZXMpIHtcbiAgbGV0IGF0dHJpYnV0ZXNLZXkgPSBcIlwiO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykuc29ydCgpO1xuICBmb3IgKGxldCBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICBhdHRyaWJ1dGVzS2V5ICs9IGtleXNbaV0gKyBcIjpcIiArIGF0dHJpYnV0ZXNba2V5c1tpXV0gKyBcIjtcIjtcbiAgfVxuICByZXR1cm4gYXR0cmlidXRlc0tleTtcbn1cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShjb25zdHJ1Y3Rvcikge1xuICBzd2l0Y2ggKGNvbnN0cnVjdG9yKSB7XG4gICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDEyNztcbiAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDI1NTtcbiAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDMyNzY3O1xuICAgIGNhc2UgVWludDE2QXJyYXk6XG4gICAgICByZXR1cm4gMSAvIDY1NTM1O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBub3JtYWxpemVkIGFjY2Vzc29yIGNvbXBvbmVudCB0eXBlLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SW1hZ2VVUklNaW1lVHlwZSh1cmkpIHtcbiAgaWYgKHVyaS5zZWFyY2goL1xcLmpwZT9nKCR8XFw/KS9pKSA+IDAgfHwgdXJpLnNlYXJjaCgvXmRhdGFcXDppbWFnZVxcL2pwZWcvKSA9PT0gMClcbiAgICByZXR1cm4gXCJpbWFnZS9qcGVnXCI7XG4gIGlmICh1cmkuc2VhcmNoKC9cXC53ZWJwKCR8XFw/KS9pKSA+IDAgfHwgdXJpLnNlYXJjaCgvXmRhdGFcXDppbWFnZVxcL3dlYnAvKSA9PT0gMClcbiAgICByZXR1cm4gXCJpbWFnZS93ZWJwXCI7XG4gIHJldHVybiBcImltYWdlL3BuZ1wiO1xufVxuY29uc3QgX2lkZW50aXR5TWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0KCk7XG5jbGFzcyBHTFRGUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoanNvbiA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmpzb24gPSBqc29uO1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5jYWNoZSA9IG5ldyBHTFRGUmVnaXN0cnkoKTtcbiAgICB0aGlzLmFzc29jaWF0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcmltaXRpdmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubm9kZUNhY2hlID0ge307XG4gICAgdGhpcy5tZXNoQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMuY2FtZXJhQ2FjaGUgPSB7IHJlZnM6IHt9LCB1c2VzOiB7fSB9O1xuICAgIHRoaXMubGlnaHRDYWNoZSA9IHsgcmVmczoge30sIHVzZXM6IHt9IH07XG4gICAgdGhpcy5zb3VyY2VDYWNoZSA9IHt9O1xuICAgIHRoaXMudGV4dHVyZUNhY2hlID0ge307XG4gICAgdGhpcy5ub2RlTmFtZXNVc2VkID0ge307XG4gICAgbGV0IGlzU2FmYXJpID0gZmFsc2U7XG4gICAgbGV0IGlzRmlyZWZveCA9IGZhbHNlO1xuICAgIGxldCBmaXJlZm94VmVyc2lvbiA9IC0xO1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IHRydWU7XG4gICAgICBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJGaXJlZm94XCIpID4gLTE7XG4gICAgICBmaXJlZm94VmVyc2lvbiA9IGlzRmlyZWZveCA/IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0ZpcmVmb3hcXC8oWzAtOV0rKVxcLi8pWzFdIDogLTE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNTYWZhcmkgfHwgaXNGaXJlZm94ICYmIGZpcmVmb3hWZXJzaW9uIDwgOTgpIHtcbiAgICAgIHRoaXMudGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0dXJlTG9hZGVyID0gbmV3IEltYWdlQml0bWFwTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgdGhpcy50ZXh0dXJlTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5vcHRpb25zLnJlcXVlc3RIZWFkZXIpO1xuICAgIHRoaXMuZmlsZUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMub3B0aW9ucy5tYW5hZ2VyKTtcbiAgICB0aGlzLmZpbGVMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKFwiYXJyYXlidWZmZXJcIik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc09yaWdpbiA9PT0gXCJ1c2UtY3JlZGVudGlhbHNcIikge1xuICAgICAgdGhpcy5maWxlTG9hZGVyLnNldFdpdGhDcmVkZW50aWFscyh0cnVlKTtcbiAgICB9XG4gIH1cbiAgc2V0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgfVxuICBzZXRQbHVnaW5zKHBsdWdpbnMpIHtcbiAgICB0aGlzLnBsdWdpbnMgPSBwbHVnaW5zO1xuICB9XG4gIHBhcnNlKG9uTG9hZCwgb25FcnJvcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5leHRlbnNpb25zO1xuICAgIHRoaXMuY2FjaGUucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy5ub2RlQ2FjaGUgPSB7fTtcbiAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0Ll9tYXJrRGVmcyAmJiBleHQuX21hcmtEZWZzKCk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgIHJldHVybiBleHQuYmVmb3JlUm9vdCAmJiBleHQuYmVmb3JlUm9vdCgpO1xuICAgICAgfSlcbiAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBwYXJzZXIuZ2V0RGVwZW5kZW5jaWVzKFwic2NlbmVcIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJhbmltYXRpb25cIiksXG4gICAgICAgIHBhcnNlci5nZXREZXBlbmRlbmNpZXMoXCJjYW1lcmFcIilcbiAgICAgIF0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oZGVwZW5kZW5jaWVzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNjZW5lOiBkZXBlbmRlbmNpZXNbMF1banNvbi5zY2VuZSB8fCAwXSxcbiAgICAgICAgc2NlbmVzOiBkZXBlbmRlbmNpZXNbMF0sXG4gICAgICAgIGFuaW1hdGlvbnM6IGRlcGVuZGVuY2llc1sxXSxcbiAgICAgICAgY2FtZXJhczogZGVwZW5kZW5jaWVzWzJdLFxuICAgICAgICBhc3NldDoganNvbi5hc3NldCxcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICB1c2VyRGF0YToge31cbiAgICAgIH07XG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgcmVzdWx0LCBqc29uKTtcbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEocmVzdWx0LCBqc29uKTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGV4dC5hZnRlclJvb3QgJiYgZXh0LmFmdGVyUm9vdChyZXN1bHQpO1xuICAgICAgICB9KVxuICAgICAgKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNjZW5lIG9mIHJlc3VsdC5zY2VuZXMpIHtcbiAgICAgICAgICBzY2VuZS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICB9XG4gICAgICAgIG9uTG9hZChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkuY2F0Y2gob25FcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRoZSBzcGVjaWFsIG5vZGVzL21lc2hlcyBpbiBqc29uIGZvciBlZmZpY2llbnQgcGFyc2UuXG4gICAqL1xuICBfbWFya0RlZnMoKSB7XG4gICAgY29uc3Qgbm9kZURlZnMgPSB0aGlzLmpzb24ubm9kZXMgfHwgW107XG4gICAgY29uc3Qgc2tpbkRlZnMgPSB0aGlzLmpzb24uc2tpbnMgfHwgW107XG4gICAgY29uc3QgbWVzaERlZnMgPSB0aGlzLmpzb24ubWVzaGVzIHx8IFtdO1xuICAgIGZvciAobGV0IHNraW5JbmRleCA9IDAsIHNraW5MZW5ndGggPSBza2luRGVmcy5sZW5ndGg7IHNraW5JbmRleCA8IHNraW5MZW5ndGg7IHNraW5JbmRleCsrKSB7XG4gICAgICBjb25zdCBqb2ludHMgPSBza2luRGVmc1tza2luSW5kZXhdLmpvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIG5vZGVEZWZzW2pvaW50c1tpXV0uaXNCb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMCwgbm9kZUxlbmd0aCA9IG5vZGVEZWZzLmxlbmd0aDsgbm9kZUluZGV4IDwgbm9kZUxlbmd0aDsgbm9kZUluZGV4KyspIHtcbiAgICAgIGNvbnN0IG5vZGVEZWYgPSBub2RlRGVmc1tub2RlSW5kZXhdO1xuICAgICAgaWYgKG5vZGVEZWYubWVzaCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5tZXNoQ2FjaGUsIG5vZGVEZWYubWVzaCk7XG4gICAgICAgIGlmIChub2RlRGVmLnNraW4gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG1lc2hEZWZzW25vZGVEZWYubWVzaF0uaXNTa2lubmVkTWVzaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlRGVmLmNhbWVyYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuX2FkZE5vZGVSZWYodGhpcy5jYW1lcmFDYWNoZSwgbm9kZURlZi5jYW1lcmEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ291bnRzIHJlZmVyZW5jZXMgdG8gc2hhcmVkIG5vZGUgLyBPYmplY3QzRCByZXNvdXJjZXMuIFRoZXNlIHJlc291cmNlc1xuICAgKiBjYW4gYmUgcmV1c2VkLCBvciBcImluc3RhbnRpYXRlZFwiLCBhdCBtdWx0aXBsZSBub2RlcyBpbiB0aGUgc2NlbmVcbiAgICogaGllcmFyY2h5LiBNZXNoLCBDYW1lcmEsIGFuZCBMaWdodCBpbnN0YW5jZXMgYXJlIGluc3RhbnRpYXRlZCBhbmQgbXVzdFxuICAgKiBiZSBtYXJrZWQuIE5vbi1zY2VuZWdyYXBoIHJlc291cmNlcyAobGlrZSBNYXRlcmlhbHMsIEdlb21ldHJpZXMsIGFuZFxuICAgKiBUZXh0dXJlcykgY2FuIGJlIHJldXNlZCBkaXJlY3RseSBhbmQgYXJlIG5vdCBtYXJrZWQgaGVyZS5cbiAgICpcbiAgICogRXhhbXBsZTogQ2VzaXVtTWlsa1RydWNrIHNhbXBsZSBtb2RlbCByZXVzZXMgXCJXaGVlbFwiIG1lc2hlcy5cbiAgICovXG4gIF9hZGROb2RlUmVmKGNhY2hlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjYWNoZS5yZWZzW2luZGV4XSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYWNoZS5yZWZzW2luZGV4XSA9IGNhY2hlLnVzZXNbaW5kZXhdID0gMDtcbiAgICB9XG4gICAgY2FjaGUucmVmc1tpbmRleF0rKztcbiAgfVxuICAvKiogUmV0dXJucyBhIHJlZmVyZW5jZSB0byBhIHNoYXJlZCByZXNvdXJjZSwgY2xvbmluZyBpdCBpZiBuZWNlc3NhcnkuICovXG4gIF9nZXROb2RlUmVmKGNhY2hlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgaWYgKGNhY2hlLnJlZnNbaW5kZXhdIDw9IDEpXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIGNvbnN0IHJlZiA9IG9iamVjdC5jbG9uZSgpO1xuICAgIGNvbnN0IHVwZGF0ZU1hcHBpbmdzID0gKG9yaWdpbmFsLCBjbG9uZSkgPT4ge1xuICAgICAgY29uc3QgbWFwcGluZ3MgPSB0aGlzLmFzc29jaWF0aW9ucy5nZXQob3JpZ2luYWwpO1xuICAgICAgaWYgKG1hcHBpbmdzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNsb25lLCBtYXBwaW5ncyk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtpLCBjaGlsZF0gb2Ygb3JpZ2luYWwuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgIHVwZGF0ZU1hcHBpbmdzKGNoaWxkLCBjbG9uZS5jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGVNYXBwaW5ncyhvYmplY3QsIHJlZik7XG4gICAgcmVmLm5hbWUgKz0gXCJfaW5zdGFuY2VfXCIgKyBjYWNoZS51c2VzW2luZGV4XSsrO1xuICAgIHJldHVybiByZWY7XG4gIH1cbiAgX2ludm9rZU9uZShmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnB1c2godGhpcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHRlbnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBmdW5jKGV4dGVuc2lvbnNbaV0pO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX2ludm9rZUFsbChmdW5jKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IE9iamVjdC52YWx1ZXModGhpcy5wbHVnaW5zKTtcbiAgICBleHRlbnNpb25zLnVuc2hpZnQodGhpcyk7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXh0ZW5zaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZnVuYyhleHRlbnNpb25zW2ldKTtcbiAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgIHBlbmRpbmcucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfVxuICAvKipcbiAgICogUmVxdWVzdHMgdGhlIHNwZWNpZmllZCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEfE1hdGVyaWFsfFRIUkVFLlRleHR1cmV8QW5pbWF0aW9uQ2xpcHxBcnJheUJ1ZmZlcnxPYmplY3Q+fVxuICAgKi9cbiAgZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gdHlwZSArIFwiOlwiICsgaW5kZXg7XG4gICAgbGV0IGRlcGVuZGVuY3kgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFkZXBlbmRlbmN5KSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInNjZW5lXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMubG9hZFNjZW5lKGluZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vZGVcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTm9kZSAmJiBleHQubG9hZE5vZGUoaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWVzaFwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0LmxvYWRNZXNoICYmIGV4dC5sb2FkTWVzaChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhY2Nlc3NvclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRBY2Nlc3NvcihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJidWZmZXJWaWV3XCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZEJ1ZmZlclZpZXcgJiYgZXh0LmxvYWRCdWZmZXJWaWV3KGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJ1ZmZlclwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRCdWZmZXIoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkTWF0ZXJpYWwgJiYgZXh0LmxvYWRNYXRlcmlhbChpbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0ZXh0dXJlXCI6XG4gICAgICAgICAgZGVwZW5kZW5jeSA9IHRoaXMuX2ludm9rZU9uZShmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQubG9hZFRleHR1cmUgJiYgZXh0LmxvYWRUZXh0dXJlKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNraW5cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5sb2FkU2tpbihpbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhbmltYXRpb25cIjpcbiAgICAgICAgICBkZXBlbmRlbmN5ID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4dC5sb2FkQW5pbWF0aW9uICYmIGV4dC5sb2FkQW5pbWF0aW9uKGluZGV4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhbWVyYVwiOlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLmxvYWRDYW1lcmEoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlcGVuZGVuY3kgPSB0aGlzLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gZXh0ICE9IHRoaXMgJiYgZXh0LmdldERlcGVuZGVuY3kgJiYgZXh0LmdldERlcGVuZGVuY3kodHlwZSwgaW5kZXgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBkZXBlbmRlbmN5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY3k7XG4gIH1cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFsbCBkZXBlbmRlbmNpZXMgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGFzeW5jaHJvbm91c2x5LCB3aXRoIGNhY2hpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8T2JqZWN0Pj59XG4gICAqL1xuICBnZXREZXBlbmRlbmNpZXModHlwZSkge1xuICAgIGxldCBkZXBlbmRlbmNpZXMgPSB0aGlzLmNhY2hlLmdldCh0eXBlKTtcbiAgICBpZiAoIWRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICAgIGNvbnN0IGRlZnMgPSB0aGlzLmpzb25bdHlwZSArICh0eXBlID09PSBcIm1lc2hcIiA/IFwiZXNcIiA6IFwic1wiKV0gfHwgW107XG4gICAgICBkZXBlbmRlbmNpZXMgPSBQcm9taXNlLmFsbChcbiAgICAgICAgZGVmcy5tYXAoZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeSh0eXBlLCBpbmRleCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgdGhpcy5jYWNoZS5hZGQodHlwZSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcGVuZGVuY2llcztcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNidWZmZXJzLWFuZC1idWZmZXItdmlld3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlckluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXlCdWZmZXI+fVxuICAgKi9cbiAgbG9hZEJ1ZmZlcihidWZmZXJJbmRleCkge1xuICAgIGNvbnN0IGJ1ZmZlckRlZiA9IHRoaXMuanNvbi5idWZmZXJzW2J1ZmZlckluZGV4XTtcbiAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmZpbGVMb2FkZXI7XG4gICAgaWYgKGJ1ZmZlckRlZi50eXBlICYmIGJ1ZmZlckRlZi50eXBlICE9PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLkdMVEZMb2FkZXI6IFwiICsgYnVmZmVyRGVmLnR5cGUgKyBcIiBidWZmZXIgdHlwZSBpcyBub3Qgc3VwcG9ydGVkLlwiKTtcbiAgICB9XG4gICAgaWYgKGJ1ZmZlckRlZi51cmkgPT09IHZvaWQgMCAmJiBidWZmZXJJbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfQklOQVJZX0dMVEZdLmJvZHkpO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGxvYWRlci5sb2FkKExvYWRlclV0aWxzLnJlc29sdmVVUkwoYnVmZmVyRGVmLnVyaSwgb3B0aW9ucy5wYXRoKSwgcmVzb2x2ZSwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignVEhSRUUuR0xURkxvYWRlcjogRmFpbGVkIHRvIGxvYWQgYnVmZmVyIFwiJyArIGJ1ZmZlckRlZi51cmkgKyAnXCIuJykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjYnVmZmVycy1hbmQtYnVmZmVyLXZpZXdzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJWaWV3SW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheUJ1ZmZlcj59XG4gICAqL1xuICBsb2FkQnVmZmVyVmlldyhidWZmZXJWaWV3SW5kZXgpIHtcbiAgICBjb25zdCBidWZmZXJWaWV3RGVmID0gdGhpcy5qc29uLmJ1ZmZlclZpZXdzW2J1ZmZlclZpZXdJbmRleF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclwiLCBidWZmZXJWaWV3RGVmLmJ1ZmZlcikudGhlbihmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBidWZmZXJWaWV3RGVmLmJ5dGVMZW5ndGggfHwgMDtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBidWZmZXJWaWV3RGVmLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI2FjY2Vzc29yc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYWNjZXNzb3JJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlckF0dHJpYnV0ZXxJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZT59XG4gICAqL1xuICBsb2FkQWNjZXNzb3IoYWNjZXNzb3JJbmRleCkge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBhY2Nlc3NvckRlZiA9IHRoaXMuanNvbi5hY2Nlc3NvcnNbYWNjZXNzb3JJbmRleF07XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgPT09IHZvaWQgMCAmJiBhY2Nlc3NvckRlZi5zcGFyc2UgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBhY2Nlc3NvckRlZi5ub3JtYWxpemVkID09PSB0cnVlO1xuICAgICAgY29uc3QgYXJyYXkgPSBuZXcgVHlwZWRBcnJheShhY2Nlc3NvckRlZi5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpKTtcbiAgICB9XG4gICAgY29uc3QgcGVuZGluZ0J1ZmZlclZpZXdzID0gW107XG4gICAgaWYgKGFjY2Vzc29yRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5idWZmZXJWaWV3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKG51bGwpO1xuICAgIH1cbiAgICBpZiAoYWNjZXNzb3JEZWYuc3BhcnNlICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdCdWZmZXJWaWV3cy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcImJ1ZmZlclZpZXdcIiwgYWNjZXNzb3JEZWYuc3BhcnNlLmluZGljZXMuYnVmZmVyVmlldykpO1xuICAgICAgcGVuZGluZ0J1ZmZlclZpZXdzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYnVmZmVyVmlld1wiLCBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ1ZmZlclZpZXcpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmdCdWZmZXJWaWV3cykudGhlbihmdW5jdGlvbihidWZmZXJWaWV3cykge1xuICAgICAgY29uc3QgYnVmZmVyVmlldyA9IGJ1ZmZlclZpZXdzWzBdO1xuICAgICAgY29uc3QgaXRlbVNpemUgPSBXRUJHTF9UWVBFX1NJWkVTW2FjY2Vzc29yRGVmLnR5cGVdO1xuICAgICAgY29uc3QgVHlwZWRBcnJheSA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5jb21wb25lbnRUeXBlXTtcbiAgICAgIGNvbnN0IGVsZW1lbnRCeXRlcyA9IFR5cGVkQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICBjb25zdCBpdGVtQnl0ZXMgPSBlbGVtZW50Qnl0ZXMgKiBpdGVtU2l6ZTtcbiAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSBhY2Nlc3NvckRlZi5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBieXRlU3RyaWRlID0gYWNjZXNzb3JEZWYuYnVmZmVyVmlldyAhPT0gdm9pZCAwID8ganNvbi5idWZmZXJWaWV3c1thY2Nlc3NvckRlZi5idWZmZXJWaWV3XS5ieXRlU3RyaWRlIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGFjY2Vzc29yRGVmLm5vcm1hbGl6ZWQgPT09IHRydWU7XG4gICAgICBsZXQgYXJyYXksIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICAgIGlmIChieXRlU3RyaWRlICYmIGJ5dGVTdHJpZGUgIT09IGl0ZW1CeXRlcykge1xuICAgICAgICBjb25zdCBpYlNsaWNlID0gTWF0aC5mbG9vcihieXRlT2Zmc2V0IC8gYnl0ZVN0cmlkZSk7XG4gICAgICAgIGNvbnN0IGliQ2FjaGVLZXkgPSBcIkludGVybGVhdmVkQnVmZmVyOlwiICsgYWNjZXNzb3JEZWYuYnVmZmVyVmlldyArIFwiOlwiICsgYWNjZXNzb3JEZWYuY29tcG9uZW50VHlwZSArIFwiOlwiICsgaWJTbGljZSArIFwiOlwiICsgYWNjZXNzb3JEZWYuY291bnQ7XG4gICAgICAgIGxldCBpYiA9IHBhcnNlci5jYWNoZS5nZXQoaWJDYWNoZUtleSk7XG4gICAgICAgIGlmICghaWIpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGJ1ZmZlclZpZXcsIGliU2xpY2UgKiBieXRlU3RyaWRlLCBhY2Nlc3NvckRlZi5jb3VudCAqIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMpO1xuICAgICAgICAgIGliID0gbmV3IEludGVybGVhdmVkQnVmZmVyKGFycmF5LCBieXRlU3RyaWRlIC8gZWxlbWVudEJ5dGVzKTtcbiAgICAgICAgICBwYXJzZXIuY2FjaGUuYWRkKGliQ2FjaGVLZXksIGliKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoXG4gICAgICAgICAgaWIsXG4gICAgICAgICAgaXRlbVNpemUsXG4gICAgICAgICAgYnl0ZU9mZnNldCAlIGJ5dGVTdHJpZGUgLyBlbGVtZW50Qnl0ZXMsXG4gICAgICAgICAgbm9ybWFsaXplZFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgPT09IG51bGwpIHtcbiAgICAgICAgICBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFjY2Vzc29yRGVmLmNvdW50ICogaXRlbVNpemUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlldywgYnl0ZU9mZnNldCwgYWNjZXNzb3JEZWYuY291bnQgKiBpdGVtU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKGFjY2Vzc29yRGVmLnNwYXJzZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1TaXplSW5kaWNlcyA9IFdFQkdMX1RZUEVfU0laRVMuU0NBTEFSO1xuICAgICAgICBjb25zdCBUeXBlZEFycmF5SW5kaWNlcyA9IFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5jb21wb25lbnRUeXBlXTtcbiAgICAgICAgY29uc3QgYnl0ZU9mZnNldEluZGljZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UuaW5kaWNlcy5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgICAgIGNvbnN0IGJ5dGVPZmZzZXRWYWx1ZXMgPSBhY2Nlc3NvckRlZi5zcGFyc2UudmFsdWVzLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICAgICAgY29uc3Qgc3BhcnNlSW5kaWNlcyA9IG5ldyBUeXBlZEFycmF5SW5kaWNlcyhcbiAgICAgICAgICBidWZmZXJWaWV3c1sxXSxcbiAgICAgICAgICBieXRlT2Zmc2V0SW5kaWNlcyxcbiAgICAgICAgICBhY2Nlc3NvckRlZi5zcGFyc2UuY291bnQgKiBpdGVtU2l6ZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgc3BhcnNlVmFsdWVzID0gbmV3IFR5cGVkQXJyYXkoYnVmZmVyVmlld3NbMl0sIGJ5dGVPZmZzZXRWYWx1ZXMsIGFjY2Vzc29yRGVmLnNwYXJzZS5jb3VudCAqIGl0ZW1TaXplKTtcbiAgICAgICAgaWYgKGJ1ZmZlclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKFxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLmFycmF5LnNsaWNlKCksXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUsXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gc3BhcnNlSW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBzcGFyc2VJbmRpY2VzW2ldO1xuICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRYKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDIpXG4gICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUuc2V0WShpbmRleCwgc3BhcnNlVmFsdWVzW2kgKiBpdGVtU2l6ZSArIDFdKTtcbiAgICAgICAgICBpZiAoaXRlbVNpemUgPj0gMylcbiAgICAgICAgICAgIGJ1ZmZlckF0dHJpYnV0ZS5zZXRaKGluZGV4LCBzcGFyc2VWYWx1ZXNbaSAqIGl0ZW1TaXplICsgMl0pO1xuICAgICAgICAgIGlmIChpdGVtU2l6ZSA+PSA0KVxuICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnNldFcoaW5kZXgsIHNwYXJzZVZhbHVlc1tpICogaXRlbVNpemUgKyAzXSk7XG4gICAgICAgICAgaWYgKGl0ZW1TaXplID49IDUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBVbnN1cHBvcnRlZCBpdGVtU2l6ZSBpbiBzcGFyc2UgQnVmZmVyQXR0cmlidXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlckF0dHJpYnV0ZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3RleHR1cmVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0ZXh0dXJlSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxUSFJFRS5UZXh0dXJlfG51bGw+fVxuICAgKi9cbiAgbG9hZFRleHR1cmUodGV4dHVyZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRleHR1cmVEZWYgPSBqc29uLnRleHR1cmVzW3RleHR1cmVJbmRleF07XG4gICAgY29uc3Qgc291cmNlSW5kZXggPSB0ZXh0dXJlRGVmLnNvdXJjZTtcbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgbGV0IGxvYWRlciA9IHRoaXMudGV4dHVyZUxvYWRlcjtcbiAgICBpZiAoc291cmNlRGVmLnVyaSkge1xuICAgICAgY29uc3QgaGFuZGxlciA9IG9wdGlvbnMubWFuYWdlci5nZXRIYW5kbGVyKHNvdXJjZURlZi51cmkpO1xuICAgICAgaWYgKGhhbmRsZXIgIT09IG51bGwpXG4gICAgICAgIGxvYWRlciA9IGhhbmRsZXI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvYWRUZXh0dXJlSW1hZ2UodGV4dHVyZUluZGV4LCBzb3VyY2VJbmRleCwgbG9hZGVyKTtcbiAgfVxuICBsb2FkVGV4dHVyZUltYWdlKHRleHR1cmVJbmRleCwgc291cmNlSW5kZXgsIGxvYWRlcikge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCB0ZXh0dXJlRGVmID0ganNvbi50ZXh0dXJlc1t0ZXh0dXJlSW5kZXhdO1xuICAgIGNvbnN0IHNvdXJjZURlZiA9IGpzb24uaW1hZ2VzW3NvdXJjZUluZGV4XTtcbiAgICBjb25zdCBjYWNoZUtleSA9IChzb3VyY2VEZWYudXJpIHx8IHNvdXJjZURlZi5idWZmZXJWaWV3KSArIFwiOlwiICsgdGV4dHVyZURlZi5zYW1wbGVyO1xuICAgIGlmICh0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV07XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKS50aGVuKGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgIHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcbiAgICAgIHRleHR1cmUubmFtZSA9IHRleHR1cmVEZWYubmFtZSB8fCBzb3VyY2VEZWYubmFtZSB8fCBcIlwiO1xuICAgICAgaWYgKHRleHR1cmUubmFtZSA9PT0gXCJcIiAmJiB0eXBlb2Ygc291cmNlRGVmLnVyaSA9PT0gXCJzdHJpbmdcIiAmJiBzb3VyY2VEZWYudXJpLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGV4dHVyZS5uYW1lID0gc291cmNlRGVmLnVyaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNhbXBsZXJzID0ganNvbi5zYW1wbGVycyB8fCB7fTtcbiAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1t0ZXh0dXJlRGVmLnNhbXBsZXJdIHx8IHt9O1xuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBXRUJHTF9GSUxURVJTW3NhbXBsZXIubWFnRmlsdGVyXSB8fCBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFdFQkdMX0ZJTFRFUlNbc2FtcGxlci5taW5GaWx0ZXJdIHx8IExpbmVhck1pcG1hcExpbmVhckZpbHRlcjtcbiAgICAgIHRleHR1cmUud3JhcFMgPSBXRUJHTF9XUkFQUElOR1Nbc2FtcGxlci53cmFwU10gfHwgUmVwZWF0V3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gV0VCR0xfV1JBUFBJTkdTW3NhbXBsZXIud3JhcFRdIHx8IFJlcGVhdFdyYXBwaW5nO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQodGV4dHVyZSwgeyB0ZXh0dXJlczogdGV4dHVyZUluZGV4IH0pO1xuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICB0aGlzLnRleHR1cmVDYWNoZVtjYWNoZUtleV0gPSBwcm9taXNlO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGxvYWRJbWFnZVNvdXJjZShzb3VyY2VJbmRleCwgbG9hZGVyKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKHRoaXMuc291cmNlQ2FjaGVbc291cmNlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XS50aGVuKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLmNsb25lKCkpO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VEZWYgPSBqc29uLmltYWdlc1tzb3VyY2VJbmRleF07XG4gICAgY29uc3QgVVJMID0gc2VsZi5VUkwgfHwgc2VsZi53ZWJraXRVUkw7XG4gICAgbGV0IHNvdXJjZVVSSSA9IHNvdXJjZURlZi51cmkgfHwgXCJcIjtcbiAgICBsZXQgaXNPYmplY3RVUkwgPSBmYWxzZTtcbiAgICBpZiAoc291cmNlRGVmLmJ1ZmZlclZpZXcgIT09IHZvaWQgMCkge1xuICAgICAgc291cmNlVVJJID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJidWZmZXJWaWV3XCIsIHNvdXJjZURlZi5idWZmZXJWaWV3KS50aGVuKGZ1bmN0aW9uKGJ1ZmZlclZpZXcpIHtcbiAgICAgICAgaXNPYmplY3RVUkwgPSB0cnVlO1xuICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlclZpZXddLCB7IHR5cGU6IHNvdXJjZURlZi5taW1lVHlwZSB9KTtcbiAgICAgICAgc291cmNlVVJJID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZVVSSTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc291cmNlRGVmLnVyaSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5HTFRGTG9hZGVyOiBJbWFnZSBcIiArIHNvdXJjZUluZGV4ICsgXCIgaXMgbWlzc2luZyBVUkkgYW5kIGJ1ZmZlclZpZXdcIik7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc291cmNlVVJJKS50aGVuKGZ1bmN0aW9uKHNvdXJjZVVSSTIpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGV0IG9uTG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGlmIChsb2FkZXIuaXNJbWFnZUJpdG1hcExvYWRlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG9uTG9hZCA9IGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUoaW1hZ2VCaXRtYXApO1xuICAgICAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKHRleHR1cmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9hZGVyLmxvYWQoTG9hZGVyVXRpbHMucmVzb2x2ZVVSTChzb3VyY2VVUkkyLCBvcHRpb25zLnBhdGgpLCBvbkxvYWQsIHZvaWQgMCwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKGlzT2JqZWN0VVJMID09PSB0cnVlKSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVVJJKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEodGV4dHVyZSwgc291cmNlRGVmKTtcbiAgICAgIHRleHR1cmUudXNlckRhdGEubWltZVR5cGUgPSBzb3VyY2VEZWYubWltZVR5cGUgfHwgZ2V0SW1hZ2VVUklNaW1lVHlwZShzb3VyY2VEZWYudXJpKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogQ291bGRuJ3QgbG9hZCB0ZXh0dXJlXCIsIHNvdXJjZVVSSSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgICB0aGlzLnNvdXJjZUNhY2hlW3NvdXJjZUluZGV4XSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91c2x5IGFzc2lnbnMgYSB0ZXh0dXJlIHRvIHRoZSBnaXZlbiBtYXRlcmlhbCBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWF0ZXJpYWxQYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcE5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcERlZlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFRleHR1cmU+fVxuICAgKi9cbiAgYXNzaWduVGV4dHVyZShtYXRlcmlhbFBhcmFtcywgbWFwTmFtZSwgbWFwRGVmLCBjb2xvclNwYWNlKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICByZXR1cm4gdGhpcy5nZXREZXBlbmRlbmN5KFwidGV4dHVyZVwiLCBtYXBEZWYuaW5kZXgpLnRoZW4oZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgaWYgKCF0ZXh0dXJlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChtYXBEZWYudGV4Q29vcmQgIT09IHZvaWQgMCAmJiBtYXBEZWYudGV4Q29vcmQgPiAwKSB7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmNsb25lKCk7XG4gICAgICAgIHRleHR1cmUuY2hhbm5lbCA9IG1hcERlZi50ZXhDb29yZDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZXIuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9URVhUVVJFX1RSQU5TRk9STV0pIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gbWFwRGVmLmV4dGVuc2lvbnMgIT09IHZvaWQgMCA/IG1hcERlZi5leHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX1RFWFRVUkVfVFJBTlNGT1JNXSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgIGNvbnN0IGdsdGZSZWZlcmVuY2UgPSBwYXJzZXIuYXNzb2NpYXRpb25zLmdldCh0ZXh0dXJlKTtcbiAgICAgICAgICB0ZXh0dXJlID0gcGFyc2VyLmV4dGVuc2lvbnNbRVhURU5TSU9OUy5LSFJfVEVYVFVSRV9UUkFOU0ZPUk1dLmV4dGVuZFRleHR1cmUodGV4dHVyZSwgdHJhbnNmb3JtKTtcbiAgICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldCh0ZXh0dXJlLCBnbHRmUmVmZXJlbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbG9yU3BhY2UgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbG9yU3BhY2UgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgY29sb3JTcGFjZSA9IGNvbG9yU3BhY2UgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICAgIGlmIChcImNvbG9yU3BhY2VcIiBpbiB0ZXh0dXJlKVxuICAgICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gY29sb3JTcGFjZSA9PT0gU1JHQkNvbG9yU3BhY2UgPyBzUkdCRW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsUGFyYW1zW21hcE5hbWVdID0gdGV4dHVyZTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBc3NpZ25zIGZpbmFsIG1hdGVyaWFsIHRvIGEgTWVzaCwgTGluZSwgb3IgUG9pbnRzIGluc3RhbmNlLiBUaGUgaW5zdGFuY2VcbiAgICogYWxyZWFkeSBoYXMgYSBtYXRlcmlhbCAoZ2VuZXJhdGVkIGZyb20gdGhlIGdsVEYgbWF0ZXJpYWwgb3B0aW9ucyBhbG9uZSlcbiAgICogYnV0IHJldXNlIG9mIHRoZSBzYW1lIGdsVEYgbWF0ZXJpYWwgbWF5IHJlcXVpcmUgbXVsdGlwbGUgdGhyZWVqcyBtYXRlcmlhbHNcbiAgICogdG8gYWNjb21tb2RhdGUgZGlmZmVyZW50IHByaW1pdGl2ZSB0eXBlcywgZGVmaW5lcywgZXRjLiBOZXcgbWF0ZXJpYWxzIHdpbGxcbiAgICogYmUgY3JlYXRlZCBpZiBuZWNlc3NhcnksIGFuZCByZXVzZWQgZnJvbSBhIGNhY2hlLlxuICAgKiBAcGFyYW0gIHtPYmplY3QzRH0gbWVzaCBNZXNoLCBMaW5lLCBvciBQb2ludHMgaW5zdGFuY2UuXG4gICAqL1xuICBhc3NpZ25GaW5hbE1hdGVyaWFsKG1lc2gpIHtcbiAgICBjb25zdCBnZW9tZXRyeSA9IG1lc2guZ2VvbWV0cnk7XG4gICAgbGV0IG1hdGVyaWFsID0gbWVzaC5tYXRlcmlhbDtcbiAgICBjb25zdCB1c2VEZXJpdmF0aXZlVGFuZ2VudHMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnRhbmdlbnQgPT09IHZvaWQgMDtcbiAgICBjb25zdCB1c2VWZXJ0ZXhDb2xvcnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmNvbG9yICE9PSB2b2lkIDA7XG4gICAgY29uc3QgdXNlRmxhdFNoYWRpbmcgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdm9pZCAwO1xuICAgIGlmIChtZXNoLmlzUG9pbnRzKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiUG9pbnRzTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IHBvaW50c01hdGVyaWFsID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKCFwb2ludHNNYXRlcmlhbCkge1xuICAgICAgICBwb2ludHNNYXRlcmlhbCA9IG5ldyBQb2ludHNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKHBvaW50c01hdGVyaWFsLCBtYXRlcmlhbCk7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLmNvbG9yLmNvcHkobWF0ZXJpYWwuY29sb3IpO1xuICAgICAgICBwb2ludHNNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHBvaW50c01hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhY2hlLmFkZChjYWNoZUtleSwgcG9pbnRzTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBwb2ludHNNYXRlcmlhbDtcbiAgICB9IGVsc2UgaWYgKG1lc2guaXNMaW5lKSB7XG4gICAgICBjb25zdCBjYWNoZUtleSA9IFwiTGluZUJhc2ljTWF0ZXJpYWw6XCIgKyBtYXRlcmlhbC51dWlkO1xuICAgICAgbGV0IGxpbmVNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghbGluZU1hdGVyaWFsKSB7XG4gICAgICAgIGxpbmVNYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCgpO1xuICAgICAgICBNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKGxpbmVNYXRlcmlhbCwgbWF0ZXJpYWwpO1xuICAgICAgICBsaW5lTWF0ZXJpYWwuY29sb3IuY29weShtYXRlcmlhbC5jb2xvcik7XG4gICAgICAgIGxpbmVNYXRlcmlhbC5tYXAgPSBtYXRlcmlhbC5tYXA7XG4gICAgICAgIHRoaXMuY2FjaGUuYWRkKGNhY2hlS2V5LCBsaW5lTWF0ZXJpYWwpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWwgPSBsaW5lTWF0ZXJpYWw7XG4gICAgfVxuICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMgfHwgdXNlVmVydGV4Q29sb3JzIHx8IHVzZUZsYXRTaGFkaW5nKSB7XG4gICAgICBsZXQgY2FjaGVLZXkgPSBcIkNsb25lZE1hdGVyaWFsOlwiICsgbWF0ZXJpYWwudXVpZCArIFwiOlwiO1xuICAgICAgaWYgKHVzZURlcml2YXRpdmVUYW5nZW50cylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJkZXJpdmF0aXZlLXRhbmdlbnRzOlwiO1xuICAgICAgaWYgKHVzZVZlcnRleENvbG9ycylcbiAgICAgICAgY2FjaGVLZXkgKz0gXCJ2ZXJ0ZXgtY29sb3JzOlwiO1xuICAgICAgaWYgKHVzZUZsYXRTaGFkaW5nKVxuICAgICAgICBjYWNoZUtleSArPSBcImZsYXQtc2hhZGluZzpcIjtcbiAgICAgIGxldCBjYWNoZWRNYXRlcmlhbCA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmICghY2FjaGVkTWF0ZXJpYWwpIHtcbiAgICAgICAgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbC5jbG9uZSgpO1xuICAgICAgICBpZiAodXNlVmVydGV4Q29sb3JzKVxuICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VGbGF0U2hhZGluZylcbiAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5mbGF0U2hhZGluZyA9IHRydWU7XG4gICAgICAgIGlmICh1c2VEZXJpdmF0aXZlVGFuZ2VudHMpIHtcbiAgICAgICAgICBpZiAoY2FjaGVkTWF0ZXJpYWwubm9ybWFsU2NhbGUpXG4gICAgICAgICAgICBjYWNoZWRNYXRlcmlhbC5ub3JtYWxTY2FsZS55ICo9IC0xO1xuICAgICAgICAgIGlmIChjYWNoZWRNYXRlcmlhbC5jbGVhcmNvYXROb3JtYWxTY2FsZSlcbiAgICAgICAgICAgIGNhY2hlZE1hdGVyaWFsLmNsZWFyY29hdE5vcm1hbFNjYWxlLnkgKj0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZS5hZGQoY2FjaGVLZXksIGNhY2hlZE1hdGVyaWFsKTtcbiAgICAgICAgdGhpcy5hc3NvY2lhdGlvbnMuc2V0KGNhY2hlZE1hdGVyaWFsLCB0aGlzLmFzc29jaWF0aW9ucy5nZXQobWF0ZXJpYWwpKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsID0gY2FjaGVkTWF0ZXJpYWw7XG4gICAgfVxuICAgIG1lc2gubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgfVxuICBnZXRNYXRlcmlhbFR5cGUoKSB7XG4gICAgcmV0dXJuIE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvYmxvYi9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAvUkVBRE1FLm1kI21hdGVyaWFsc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWF0ZXJpYWxJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1hdGVyaWFsPn1cbiAgICovXG4gIGxvYWRNYXRlcmlhbChtYXRlcmlhbEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWF0ZXJpYWxEZWYgPSBqc29uLm1hdGVyaWFsc1ttYXRlcmlhbEluZGV4XTtcbiAgICBsZXQgbWF0ZXJpYWxUeXBlO1xuICAgIGNvbnN0IG1hdGVyaWFsUGFyYW1zID0ge307XG4gICAgY29uc3QgbWF0ZXJpYWxFeHRlbnNpb25zID0gbWF0ZXJpYWxEZWYuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgaWYgKG1hdGVyaWFsRXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9NQVRFUklBTFNfVU5MSVRdKSB7XG4gICAgICBjb25zdCBrbXVFeHRlbnNpb24gPSBleHRlbnNpb25zW0VYVEVOU0lPTlMuS0hSX01BVEVSSUFMU19VTkxJVF07XG4gICAgICBtYXRlcmlhbFR5cGUgPSBrbXVFeHRlbnNpb24uZ2V0TWF0ZXJpYWxUeXBlKCk7XG4gICAgICBwZW5kaW5nLnB1c2goa211RXh0ZW5zaW9uLmV4dGVuZFBhcmFtcyhtYXRlcmlhbFBhcmFtcywgbWF0ZXJpYWxEZWYsIHBhcnNlcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZXRhbGxpY1JvdWdobmVzcyA9IG1hdGVyaWFsRGVmLnBick1ldGFsbGljUm91Z2huZXNzIHx8IHt9O1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuY29sb3IgPSBuZXcgQ29sb3IoMSwgMSwgMSk7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5vcGFjaXR5ID0gMTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGFsbGljUm91Z2huZXNzLmJhc2VDb2xvckZhY3RvcikpIHtcbiAgICAgICAgY29uc3QgYXJyYXkgPSBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JGYWN0b3I7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmNvbG9yLnNldFJHQihhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBMaW5lYXJTUkdCQ29sb3JTcGFjZSk7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLm9wYWNpdHkgPSBhcnJheVszXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcIm1hcFwiLCBtZXRhbGxpY1JvdWdobmVzcy5iYXNlQ29sb3JUZXh0dXJlLCBTUkdCQ29sb3JTcGFjZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxQYXJhbXMubWV0YWxuZXNzID0gbWV0YWxsaWNSb3VnaG5lc3MubWV0YWxsaWNGYWN0b3IgIT09IHZvaWQgMCA/IG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljRmFjdG9yIDogMTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnJvdWdobmVzcyA9IG1ldGFsbGljUm91Z2huZXNzLnJvdWdobmVzc0ZhY3RvciAhPT0gdm9pZCAwID8gbWV0YWxsaWNSb3VnaG5lc3Mucm91Z2huZXNzRmFjdG9yIDogMTtcbiAgICAgIGlmIChtZXRhbGxpY1JvdWdobmVzcy5tZXRhbGxpY1JvdWdobmVzc1RleHR1cmUgIT09IHZvaWQgMCkge1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibWV0YWxuZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwicm91Z2huZXNzTWFwXCIsIG1ldGFsbGljUm91Z2huZXNzLm1ldGFsbGljUm91Z2huZXNzVGV4dHVyZSkpO1xuICAgICAgfVxuICAgICAgbWF0ZXJpYWxUeXBlID0gdGhpcy5faW52b2tlT25lKGZ1bmN0aW9uKGV4dCkge1xuICAgICAgICByZXR1cm4gZXh0LmdldE1hdGVyaWFsVHlwZSAmJiBleHQuZ2V0TWF0ZXJpYWxUeXBlKG1hdGVyaWFsSW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nLnB1c2goXG4gICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuX2ludm9rZUFsbChmdW5jdGlvbihleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHQuZXh0ZW5kTWF0ZXJpYWxQYXJhbXMgJiYgZXh0LmV4dGVuZE1hdGVyaWFsUGFyYW1zKG1hdGVyaWFsSW5kZXgsIG1hdGVyaWFsUGFyYW1zKTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZG91YmxlU2lkZWQgPT09IHRydWUpIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnNpZGUgPSBEb3VibGVTaWRlO1xuICAgIH1cbiAgICBjb25zdCBhbHBoYU1vZGUgPSBtYXRlcmlhbERlZi5hbHBoYU1vZGUgfHwgQUxQSEFfTU9ERVMuT1BBUVVFO1xuICAgIGlmIChhbHBoYU1vZGUgPT09IEFMUEhBX01PREVTLkJMRU5EKSB7XG4gICAgICBtYXRlcmlhbFBhcmFtcy50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICBtYXRlcmlhbFBhcmFtcy5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoYWxwaGFNb2RlID09PSBBTFBIQV9NT0RFUy5NQVNLKSB7XG4gICAgICAgIG1hdGVyaWFsUGFyYW1zLmFscGhhVGVzdCA9IG1hdGVyaWFsRGVmLmFscGhhQ3V0b2ZmICE9PSB2b2lkIDAgPyBtYXRlcmlhbERlZi5hbHBoYUN1dG9mZiA6IDAuNTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBwZW5kaW5nLnB1c2gocGFyc2VyLmFzc2lnblRleHR1cmUobWF0ZXJpYWxQYXJhbXMsIFwibm9ybWFsTWFwXCIsIG1hdGVyaWFsRGVmLm5vcm1hbFRleHR1cmUpKTtcbiAgICAgIG1hdGVyaWFsUGFyYW1zLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoMSwgMSk7XG4gICAgICBpZiAobWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gbWF0ZXJpYWxEZWYubm9ybWFsVGV4dHVyZS5zY2FsZTtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMubm9ybWFsU2NhbGUuc2V0KHNjYWxlLCBzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImFvTWFwXCIsIG1hdGVyaWFsRGVmLm9jY2x1c2lvblRleHR1cmUpKTtcbiAgICAgIGlmIChtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWF0ZXJpYWxQYXJhbXMuYW9NYXBJbnRlbnNpdHkgPSBtYXRlcmlhbERlZi5vY2NsdXNpb25UZXh0dXJlLnN0cmVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVGYWN0b3IgIT09IHZvaWQgMCAmJiBtYXRlcmlhbFR5cGUgIT09IE1lc2hCYXNpY01hdGVyaWFsKSB7XG4gICAgICBjb25zdCBlbWlzc2l2ZUZhY3RvciA9IG1hdGVyaWFsRGVmLmVtaXNzaXZlRmFjdG9yO1xuICAgICAgbWF0ZXJpYWxQYXJhbXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoKS5zZXRSR0IoXG4gICAgICAgIGVtaXNzaXZlRmFjdG9yWzBdLFxuICAgICAgICBlbWlzc2l2ZUZhY3RvclsxXSxcbiAgICAgICAgZW1pc3NpdmVGYWN0b3JbMl0sXG4gICAgICAgIExpbmVhclNSR0JDb2xvclNwYWNlXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobWF0ZXJpYWxEZWYuZW1pc3NpdmVUZXh0dXJlICE9PSB2b2lkIDAgJiYgbWF0ZXJpYWxUeXBlICE9PSBNZXNoQmFzaWNNYXRlcmlhbCkge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5hc3NpZ25UZXh0dXJlKG1hdGVyaWFsUGFyYW1zLCBcImVtaXNzaXZlTWFwXCIsIG1hdGVyaWFsRGVmLmVtaXNzaXZlVGV4dHVyZSwgU1JHQkNvbG9yU3BhY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBtYXRlcmlhbFR5cGUobWF0ZXJpYWxQYXJhbXMpO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLm5hbWUpXG4gICAgICAgIG1hdGVyaWFsLm5hbWUgPSBtYXRlcmlhbERlZi5uYW1lO1xuICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQobWF0ZXJpYWwsIHsgbWF0ZXJpYWxzOiBtYXRlcmlhbEluZGV4IH0pO1xuICAgICAgaWYgKG1hdGVyaWFsRGVmLmV4dGVuc2lvbnMpXG4gICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtYXRlcmlhbCwgbWF0ZXJpYWxEZWYpO1xuICAgICAgcmV0dXJuIG1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIC8qKiBXaGVuIE9iamVjdDNEIGluc3RhbmNlcyBhcmUgdGFyZ2V0ZWQgYnkgYW5pbWF0aW9uLCB0aGV5IG5lZWQgdW5pcXVlIG5hbWVzLiAqL1xuICBjcmVhdGVVbmlxdWVOYW1lKG9yaWdpbmFsTmFtZSkge1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBQcm9wZXJ0eUJpbmRpbmcuc2FuaXRpemVOb2RlTmFtZShvcmlnaW5hbE5hbWUgfHwgXCJcIik7XG4gICAgaWYgKHNhbml0aXplZE5hbWUgaW4gdGhpcy5ub2RlTmFtZXNVc2VkKSB7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZSArIFwiX1wiICsgKyt0aGlzLm5vZGVOYW1lc1VzZWRbc2FuaXRpemVkTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm9kZU5hbWVzVXNlZFtzYW5pdGl6ZWROYW1lXSA9IDA7XG4gICAgICByZXR1cm4gc2FuaXRpemVkTmFtZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi9ibG9iL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMC9SRUFETUUubWQjZ2VvbWV0cnlcbiAgICpcbiAgICogQ3JlYXRlcyBCdWZmZXJHZW9tZXRyaWVzIGZyb20gcHJpbWl0aXZlcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxHTFRGLlByaW1pdGl2ZT59IHByaW1pdGl2ZXNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxCdWZmZXJHZW9tZXRyeT4+fVxuICAgKi9cbiAgbG9hZEdlb21ldHJpZXMocHJpbWl0aXZlcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMucHJpbWl0aXZlQ2FjaGU7XG4gICAgZnVuY3Rpb24gY3JlYXRlRHJhY29QcmltaXRpdmUocHJpbWl0aXZlKSB7XG4gICAgICByZXR1cm4gZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXS5kZWNvZGVQcmltaXRpdmUocHJpbWl0aXZlLCBwYXJzZXIpLnRoZW4oZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgcmV0dXJuIGFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMoZ2VvbWV0cnksIHByaW1pdGl2ZSwgcGFyc2VyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xuICAgICAgY29uc3QgY2FjaGVLZXkgPSBjcmVhdGVQcmltaXRpdmVLZXkocHJpbWl0aXZlKTtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgcGVuZGluZy5wdXNoKGNhY2hlZC5wcm9taXNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBnZW9tZXRyeVByb21pc2U7XG4gICAgICAgIGlmIChwcmltaXRpdmUuZXh0ZW5zaW9ucyAmJiBwcmltaXRpdmUuZXh0ZW5zaW9uc1tFWFRFTlNJT05TLktIUl9EUkFDT19NRVNIX0NPTVBSRVNTSU9OXSkge1xuICAgICAgICAgIGdlb21ldHJ5UHJvbWlzZSA9IGNyZWF0ZURyYWNvUHJpbWl0aXZlKHByaW1pdGl2ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VvbWV0cnlQcm9taXNlID0gYWRkUHJpbWl0aXZlQXR0cmlidXRlcyhuZXcgQnVmZmVyR2VvbWV0cnkoKSwgcHJpbWl0aXZlLCBwYXJzZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHsgcHJpbWl0aXZlLCBwcm9taXNlOiBnZW9tZXRyeVByb21pc2UgfTtcbiAgICAgICAgcGVuZGluZy5wdXNoKGdlb21ldHJ5UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL2Jsb2IvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wL1JFQURNRS5tZCNtZXNoZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1lc2hJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEdyb3VwfE1lc2h8U2tpbm5lZE1lc2g+fVxuICAgKi9cbiAgbG9hZE1lc2gobWVzaEluZGV4KSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3QgbWVzaERlZiA9IGpzb24ubWVzaGVzW21lc2hJbmRleF07XG4gICAgY29uc3QgcHJpbWl0aXZlcyA9IG1lc2hEZWYucHJpbWl0aXZlcztcbiAgICBjb25zdCBwZW5kaW5nID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gcHJpbWl0aXZlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICBjb25zdCBtYXRlcmlhbCA9IHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwgPT09IHZvaWQgMCA/IGNyZWF0ZURlZmF1bHRNYXRlcmlhbCh0aGlzLmNhY2hlKSA6IHRoaXMuZ2V0RGVwZW5kZW5jeShcIm1hdGVyaWFsXCIsIHByaW1pdGl2ZXNbaV0ubWF0ZXJpYWwpO1xuICAgICAgcGVuZGluZy5wdXNoKG1hdGVyaWFsKTtcbiAgICB9XG4gICAgcGVuZGluZy5wdXNoKHBhcnNlci5sb2FkR2VvbWV0cmllcyhwcmltaXRpdmVzKSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgbWF0ZXJpYWxzID0gcmVzdWx0cy5zbGljZSgwLCByZXN1bHRzLmxlbmd0aCAtIDEpO1xuICAgICAgY29uc3QgZ2VvbWV0cmllcyA9IHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IG1lc2hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcbiAgICAgICAgbGV0IG1lc2g7XG4gICAgICAgIGNvbnN0IG1hdGVyaWFsID0gbWF0ZXJpYWxzW2ldO1xuICAgICAgICBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRVMgfHwgcHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9TVFJJUCB8fCBwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX0ZBTiB8fCBwcmltaXRpdmUubW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbWVzaCA9IG1lc2hEZWYuaXNTa2lubmVkTWVzaCA9PT0gdHJ1ZSA/IG5ldyBTa2lubmVkTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpIDogbmV3IE1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgICBpZiAobWVzaC5pc1NraW5uZWRNZXNoID09PSB0cnVlKSB7XG4gICAgICAgICAgICBtZXNoLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlRSSUFOR0xFX1NUUklQKSB7XG4gICAgICAgICAgICBtZXNoLmdlb21ldHJ5ID0gdG9UcmlhbmdsZXNEcmF3TW9kZShtZXNoLmdlb21ldHJ5LCBUcmlhbmdsZVN0cmlwRHJhd01vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJpbWl0aXZlLm1vZGUgPT09IFdFQkdMX0NPTlNUQU5UUy5UUklBTkdMRV9GQU4pIHtcbiAgICAgICAgICAgIG1lc2guZ2VvbWV0cnkgPSB0b1RyaWFuZ2xlc0RyYXdNb2RlKG1lc2guZ2VvbWV0cnksIFRyaWFuZ2xlRmFuRHJhd01vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVTKSB7XG4gICAgICAgICAgbWVzaCA9IG5ldyBMaW5lU2VnbWVudHMoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfU1RSSVApIHtcbiAgICAgICAgICBtZXNoID0gbmV3IExpbmUoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLkxJTkVfTE9PUCkge1xuICAgICAgICAgIG1lc2ggPSBuZXcgTGluZUxvb3AoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmltaXRpdmUubW9kZSA9PT0gV0VCR0xfQ09OU1RBTlRTLlBPSU5UUykge1xuICAgICAgICAgIG1lc2ggPSBuZXcgUG9pbnRzKGdlb21ldHJ5LCBtYXRlcmlhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuR0xURkxvYWRlcjogUHJpbWl0aXZlIG1vZGUgdW5zdXBwb3J0ZWQ6IFwiICsgcHJpbWl0aXZlLm1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhtZXNoLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHVwZGF0ZU1vcnBoVGFyZ2V0cyhtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNoLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShtZXNoRGVmLm5hbWUgfHwgXCJtZXNoX1wiICsgbWVzaEluZGV4KTtcbiAgICAgICAgYXNzaWduRXh0cmFzVG9Vc2VyRGF0YShtZXNoLCBtZXNoRGVmKTtcbiAgICAgICAgaWYgKHByaW1pdGl2ZS5leHRlbnNpb25zKVxuICAgICAgICAgIGFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YShleHRlbnNpb25zLCBtZXNoLCBwcmltaXRpdmUpO1xuICAgICAgICBwYXJzZXIuYXNzaWduRmluYWxNYXRlcmlhbChtZXNoKTtcbiAgICAgICAgbWVzaGVzLnB1c2gobWVzaCk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBwYXJzZXIuYXNzb2NpYXRpb25zLnNldChtZXNoZXNbaV0sIHtcbiAgICAgICAgICBtZXNoZXM6IG1lc2hJbmRleCxcbiAgICAgICAgICBwcmltaXRpdmVzOiBpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lc2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKG1lc2hEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgbWVzaGVzWzBdLCBtZXNoRGVmKTtcbiAgICAgICAgcmV0dXJuIG1lc2hlc1swXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdyb3VwID0gbmV3IEdyb3VwKCk7XG4gICAgICBpZiAobWVzaERlZi5leHRlbnNpb25zKVxuICAgICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgZ3JvdXAsIG1lc2hEZWYpO1xuICAgICAgcGFyc2VyLmFzc29jaWF0aW9ucy5zZXQoZ3JvdXAsIHsgbWVzaGVzOiBtZXNoSW5kZXggfSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBtZXNoZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cC5hZGQobWVzaGVzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI2NhbWVyYXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNhbWVyYUluZGV4XG4gICAqIEByZXR1cm4ge1Byb21pc2U8VEhSRUUuQ2FtZXJhPn1cbiAgICovXG4gIGxvYWRDYW1lcmEoY2FtZXJhSW5kZXgpIHtcbiAgICBsZXQgY2FtZXJhO1xuICAgIGNvbnN0IGNhbWVyYURlZiA9IHRoaXMuanNvbi5jYW1lcmFzW2NhbWVyYUluZGV4XTtcbiAgICBjb25zdCBwYXJhbXMgPSBjYW1lcmFEZWZbY2FtZXJhRGVmLnR5cGVdO1xuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIGNhbWVyYSBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi50eXBlID09PSBcInBlcnNwZWN0aXZlXCIpIHtcbiAgICAgIGNhbWVyYSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYShcbiAgICAgICAgTWF0aFV0aWxzLnJhZFRvRGVnKHBhcmFtcy55Zm92KSxcbiAgICAgICAgcGFyYW1zLmFzcGVjdFJhdGlvIHx8IDEsXG4gICAgICAgIHBhcmFtcy56bmVhciB8fCAxLFxuICAgICAgICBwYXJhbXMuemZhciB8fCAyZTZcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjYW1lcmFEZWYudHlwZSA9PT0gXCJvcnRob2dyYXBoaWNcIikge1xuICAgICAgY2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSgtcGFyYW1zLnhtYWcsIHBhcmFtcy54bWFnLCBwYXJhbXMueW1hZywgLXBhcmFtcy55bWFnLCBwYXJhbXMuem5lYXIsIHBhcmFtcy56ZmFyKTtcbiAgICB9XG4gICAgaWYgKGNhbWVyYURlZi5uYW1lKVxuICAgICAgY2FtZXJhLm5hbWUgPSB0aGlzLmNyZWF0ZVVuaXF1ZU5hbWUoY2FtZXJhRGVmLm5hbWUpO1xuICAgIGFzc2lnbkV4dHJhc1RvVXNlckRhdGEoY2FtZXJhLCBjYW1lcmFEZWYpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2FtZXJhKTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI3NraW5zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBza2luSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxTa2VsZXRvbj59XG4gICAqL1xuICBsb2FkU2tpbihza2luSW5kZXgpIHtcbiAgICBjb25zdCBza2luRGVmID0gdGhpcy5qc29uLnNraW5zW3NraW5JbmRleF07XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHNraW5EZWYuam9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIHBlbmRpbmcucHVzaCh0aGlzLl9sb2FkTm9kZVNoYWxsb3coc2tpbkRlZi5qb2ludHNbaV0pKTtcbiAgICB9XG4gICAgaWYgKHNraW5EZWYuaW52ZXJzZUJpbmRNYXRyaWNlcyAhPT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgc2tpbkRlZi5pbnZlcnNlQmluZE1hdHJpY2VzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmcucHVzaChudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHBlbmRpbmcpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgY29uc3QgaW52ZXJzZUJpbmRNYXRyaWNlcyA9IHJlc3VsdHMucG9wKCk7XG4gICAgICBjb25zdCBqb2ludE5vZGVzID0gcmVzdWx0cztcbiAgICAgIGNvbnN0IGJvbmVzID0gW107XG4gICAgICBjb25zdCBib25lSW52ZXJzZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IGpvaW50Tm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBqb2ludE5vZGUgPSBqb2ludE5vZGVzW2ldO1xuICAgICAgICBpZiAoam9pbnROb2RlKSB7XG4gICAgICAgICAgYm9uZXMucHVzaChqb2ludE5vZGUpO1xuICAgICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgICAgaWYgKGludmVyc2VCaW5kTWF0cmljZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1hdC5mcm9tQXJyYXkoaW52ZXJzZUJpbmRNYXRyaWNlcy5hcnJheSwgaSAqIDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm9uZUludmVyc2VzLnB1c2gobWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RIUkVFLkdMVEZMb2FkZXI6IEpvaW50IFwiJXNcIiBjb3VsZCBub3QgYmUgZm91bmQuJywgc2tpbkRlZi5qb2ludHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNrZWxldG9uKGJvbmVzLCBib25lSW52ZXJzZXMpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZpY2F0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vS2hyb25vc0dyb3VwL2dsVEYvdHJlZS9tYXN0ZXIvc3BlY2lmaWNhdGlvbi8yLjAjYW5pbWF0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0aW9uSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxBbmltYXRpb25DbGlwPn1cbiAgICovXG4gIGxvYWRBbmltYXRpb24oYW5pbWF0aW9uSW5kZXgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5qc29uO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRGVmID0ganNvbi5hbmltYXRpb25zW2FuaW1hdGlvbkluZGV4XTtcbiAgICBjb25zdCBhbmltYXRpb25OYW1lID0gYW5pbWF0aW9uRGVmLm5hbWUgPyBhbmltYXRpb25EZWYubmFtZSA6IFwiYW5pbWF0aW9uX1wiICsgYW5pbWF0aW9uSW5kZXg7XG4gICAgY29uc3QgcGVuZGluZ05vZGVzID0gW107XG4gICAgY29uc3QgcGVuZGluZ0lucHV0QWNjZXNzb3JzID0gW107XG4gICAgY29uc3QgcGVuZGluZ091dHB1dEFjY2Vzc29ycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdTYW1wbGVycyA9IFtdO1xuICAgIGNvbnN0IHBlbmRpbmdUYXJnZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gYW5pbWF0aW9uRGVmLmNoYW5uZWxzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBhbmltYXRpb25EZWYuY2hhbm5lbHNbaV07XG4gICAgICBjb25zdCBzYW1wbGVyID0gYW5pbWF0aW9uRGVmLnNhbXBsZXJzW2NoYW5uZWwuc2FtcGxlcl07XG4gICAgICBjb25zdCB0YXJnZXQgPSBjaGFubmVsLnRhcmdldDtcbiAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubm9kZTtcbiAgICAgIGNvbnN0IGlucHV0ID0gYW5pbWF0aW9uRGVmLnBhcmFtZXRlcnMgIT09IHZvaWQgMCA/IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzW3NhbXBsZXIuaW5wdXRdIDogc2FtcGxlci5pbnB1dDtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGFuaW1hdGlvbkRlZi5wYXJhbWV0ZXJzICE9PSB2b2lkIDAgPyBhbmltYXRpb25EZWYucGFyYW1ldGVyc1tzYW1wbGVyLm91dHB1dF0gOiBzYW1wbGVyLm91dHB1dDtcbiAgICAgIGlmICh0YXJnZXQubm9kZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHBlbmRpbmdOb2Rlcy5wdXNoKHRoaXMuZ2V0RGVwZW5kZW5jeShcIm5vZGVcIiwgbmFtZSkpO1xuICAgICAgcGVuZGluZ0lucHV0QWNjZXNzb3JzLnB1c2godGhpcy5nZXREZXBlbmRlbmN5KFwiYWNjZXNzb3JcIiwgaW5wdXQpKTtcbiAgICAgIHBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMucHVzaCh0aGlzLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBvdXRwdXQpKTtcbiAgICAgIHBlbmRpbmdTYW1wbGVycy5wdXNoKHNhbXBsZXIpO1xuICAgICAgcGVuZGluZ1RhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgUHJvbWlzZS5hbGwocGVuZGluZ05vZGVzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdJbnB1dEFjY2Vzc29ycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nT3V0cHV0QWNjZXNzb3JzKSxcbiAgICAgIFByb21pc2UuYWxsKHBlbmRpbmdTYW1wbGVycyksXG4gICAgICBQcm9taXNlLmFsbChwZW5kaW5nVGFyZ2V0cylcbiAgICBdKS50aGVuKGZ1bmN0aW9uKGRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3Qgbm9kZXMgPSBkZXBlbmRlbmNpZXNbMF07XG4gICAgICBjb25zdCBpbnB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1sxXTtcbiAgICAgIGNvbnN0IG91dHB1dEFjY2Vzc29ycyA9IGRlcGVuZGVuY2llc1syXTtcbiAgICAgIGNvbnN0IHNhbXBsZXJzID0gZGVwZW5kZW5jaWVzWzNdO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IGRlcGVuZGVuY2llc1s0XTtcbiAgICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZXMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGNvbnN0IGlucHV0QWNjZXNzb3IgPSBpbnB1dEFjY2Vzc29yc1tpXTtcbiAgICAgICAgY29uc3Qgb3V0cHV0QWNjZXNzb3IgPSBvdXRwdXRBY2Nlc3NvcnNbaV07XG4gICAgICAgIGNvbnN0IHNhbXBsZXIgPSBzYW1wbGVyc1tpXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHZvaWQgMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUudXBkYXRlTWF0cml4KSB7XG4gICAgICAgICAgbm9kZS51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVkVHJhY2tzID0gcGFyc2VyLl9jcmVhdGVBbmltYXRpb25UcmFja3Mobm9kZSwgaW5wdXRBY2Nlc3Nvciwgb3V0cHV0QWNjZXNzb3IsIHNhbXBsZXIsIHRhcmdldCk7XG4gICAgICAgIGlmIChjcmVhdGVkVHJhY2tzKSB7XG4gICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjcmVhdGVkVHJhY2tzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICB0cmFja3MucHVzaChjcmVhdGVkVHJhY2tzW2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcChhbmltYXRpb25OYW1lLCB2b2lkIDAsIHRyYWNrcyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlTm9kZU1lc2gobm9kZUluZGV4KSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuanNvbjtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGNvbnN0IG5vZGVEZWYgPSBqc29uLm5vZGVzW25vZGVJbmRleF07XG4gICAgaWYgKG5vZGVEZWYubWVzaCA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHBhcnNlci5nZXREZXBlbmRlbmN5KFwibWVzaFwiLCBub2RlRGVmLm1lc2gpLnRoZW4oZnVuY3Rpb24obWVzaCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIubWVzaENhY2hlLCBub2RlRGVmLm1lc2gsIG1lc2gpO1xuICAgICAgaWYgKG5vZGVEZWYud2VpZ2h0cyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG5vZGUudHJhdmVyc2UoZnVuY3Rpb24obykge1xuICAgICAgICAgIGlmICghby5pc01lc2gpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gbm9kZURlZi53ZWlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcbiAgICAgICAgICAgIG8ubW9ycGhUYXJnZXRJbmZsdWVuY2VzW2ldID0gbm9kZURlZi53ZWlnaHRzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogU3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL0tocm9ub3NHcm91cC9nbFRGL3RyZWUvbWFzdGVyL3NwZWNpZmljYXRpb24vMi4wI25vZGVzLWFuZC1oaWVyYXJjaHlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vZGVJbmRleFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE9iamVjdDNEPn1cbiAgICovXG4gIGxvYWROb2RlKG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgcGFyc2VyID0gdGhpcztcbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVQZW5kaW5nID0gcGFyc2VyLl9sb2FkTm9kZVNoYWxsb3cobm9kZUluZGV4KTtcbiAgICBjb25zdCBjaGlsZFBlbmRpbmcgPSBbXTtcbiAgICBjb25zdCBjaGlsZHJlbkRlZiA9IG5vZGVEZWYuY2hpbGRyZW4gfHwgW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW5EZWYubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY2hpbGRQZW5kaW5nLnB1c2gocGFyc2VyLmdldERlcGVuZGVuY3koXCJub2RlXCIsIGNoaWxkcmVuRGVmW2ldKSk7XG4gICAgfVxuICAgIGNvbnN0IHNrZWxldG9uUGVuZGluZyA9IG5vZGVEZWYuc2tpbiA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZXNvbHZlKG51bGwpIDogcGFyc2VyLmdldERlcGVuZGVuY3koXCJza2luXCIsIG5vZGVEZWYuc2tpbik7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtub2RlUGVuZGluZywgUHJvbWlzZS5hbGwoY2hpbGRQZW5kaW5nKSwgc2tlbGV0b25QZW5kaW5nXSkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICBjb25zdCBub2RlID0gcmVzdWx0c1swXTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gcmVzdWx0c1sxXTtcbiAgICAgIGNvbnN0IHNrZWxldG9uID0gcmVzdWx0c1syXTtcbiAgICAgIGlmIChza2VsZXRvbiAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG1lc2gpIHtcbiAgICAgICAgICBpZiAoIW1lc2guaXNTa2lubmVkTWVzaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBtZXNoLmJpbmQoc2tlbGV0b24sIF9pZGVudGl0eU1hdHJpeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBub2RlLmFkZChjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KTtcbiAgfVxuICAvLyAuX2xvYWROb2RlU2hhbGxvdygpIHBhcnNlcyBhIHNpbmdsZSBub2RlLlxuICAvLyBza2luIGFuZCBjaGlsZCBub2RlcyBhcmUgY3JlYXRlZCBhbmQgYWRkZWQgaW4gLmxvYWROb2RlKCkgKG5vICdfJyBwcmVmaXgpLlxuICBfbG9hZE5vZGVTaGFsbG93KG5vZGVJbmRleCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmpzb247XG4gICAgY29uc3QgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzO1xuICAgIGlmICh0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVDYWNoZVtub2RlSW5kZXhdO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGVmID0ganNvbi5ub2Rlc1tub2RlSW5kZXhdO1xuICAgIGNvbnN0IG5vZGVOYW1lID0gbm9kZURlZi5uYW1lID8gcGFyc2VyLmNyZWF0ZVVuaXF1ZU5hbWUobm9kZURlZi5uYW1lKSA6IFwiXCI7XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGNvbnN0IG1lc2hQcm9taXNlID0gcGFyc2VyLl9pbnZva2VPbmUoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVNZXNoICYmIGV4dC5jcmVhdGVOb2RlTWVzaChub2RlSW5kZXgpO1xuICAgIH0pO1xuICAgIGlmIChtZXNoUHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKG1lc2hQcm9taXNlKTtcbiAgICB9XG4gICAgaWYgKG5vZGVEZWYuY2FtZXJhICE9PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmcucHVzaChcbiAgICAgICAgcGFyc2VyLmdldERlcGVuZGVuY3koXCJjYW1lcmFcIiwgbm9kZURlZi5jYW1lcmEpLnRoZW4oZnVuY3Rpb24oY2FtZXJhKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlci5fZ2V0Tm9kZVJlZihwYXJzZXIuY2FtZXJhQ2FjaGUsIG5vZGVEZWYuY2FtZXJhLCBjYW1lcmEpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcGFyc2VyLl9pbnZva2VBbGwoZnVuY3Rpb24oZXh0KSB7XG4gICAgICByZXR1cm4gZXh0LmNyZWF0ZU5vZGVBdHRhY2htZW50ICYmIGV4dC5jcmVhdGVOb2RlQXR0YWNobWVudChub2RlSW5kZXgpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgcGVuZGluZy5wdXNoKHByb21pc2UpO1xuICAgIH0pO1xuICAgIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF0gPSBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKG5vZGVEZWYuaXNCb25lID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgQm9uZSgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBHcm91cCgpO1xuICAgICAgfSBlbHNlIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBub2RlID0gb2JqZWN0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgT2JqZWN0M0QoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlICE9PSBvYmplY3RzWzBdKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgIG5vZGUuYWRkKG9iamVjdHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZURlZi5uYW1lKSB7XG4gICAgICAgIG5vZGUudXNlckRhdGEubmFtZSA9IG5vZGVEZWYubmFtZTtcbiAgICAgICAgbm9kZS5uYW1lID0gbm9kZU5hbWU7XG4gICAgICB9XG4gICAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYuZXh0ZW5zaW9ucylcbiAgICAgICAgYWRkVW5rbm93bkV4dGVuc2lvbnNUb1VzZXJEYXRhKGV4dGVuc2lvbnMsIG5vZGUsIG5vZGVEZWYpO1xuICAgICAgaWYgKG5vZGVEZWYubWF0cml4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgbWF0cml4LmZyb21BcnJheShub2RlRGVmLm1hdHJpeCk7XG4gICAgICAgIG5vZGUuYXBwbHlNYXRyaXg0KG1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobm9kZURlZi50cmFuc2xhdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgbm9kZS5wb3NpdGlvbi5mcm9tQXJyYXkobm9kZURlZi50cmFuc2xhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYucm90YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUucXVhdGVybmlvbi5mcm9tQXJyYXkobm9kZURlZi5yb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGVEZWYuc2NhbGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIG5vZGUuc2NhbGUuZnJvbUFycmF5KG5vZGVEZWYuc2NhbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXBhcnNlci5hc3NvY2lhdGlvbnMuaGFzKG5vZGUpKSB7XG4gICAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuc2V0KG5vZGUsIHt9KTtcbiAgICAgIH1cbiAgICAgIHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUpLm5vZGVzID0gbm9kZUluZGV4O1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMubm9kZUNhY2hlW25vZGVJbmRleF07XG4gIH1cbiAgLyoqXG4gICAqIFNwZWNpZmljYXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9LaHJvbm9zR3JvdXAvZ2xURi90cmVlL21hc3Rlci9zcGVjaWZpY2F0aW9uLzIuMCNzY2VuZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjZW5lSW5kZXhcbiAgICogQHJldHVybiB7UHJvbWlzZTxHcm91cD59XG4gICAqL1xuICBsb2FkU2NlbmUoc2NlbmVJbmRleCkge1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB0aGlzLmV4dGVuc2lvbnM7XG4gICAgY29uc3Qgc2NlbmVEZWYgPSB0aGlzLmpzb24uc2NlbmVzW3NjZW5lSW5kZXhdO1xuICAgIGNvbnN0IHBhcnNlciA9IHRoaXM7XG4gICAgY29uc3Qgc2NlbmUgPSBuZXcgR3JvdXAoKTtcbiAgICBpZiAoc2NlbmVEZWYubmFtZSlcbiAgICAgIHNjZW5lLm5hbWUgPSBwYXJzZXIuY3JlYXRlVW5pcXVlTmFtZShzY2VuZURlZi5uYW1lKTtcbiAgICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKHNjZW5lLCBzY2VuZURlZik7XG4gICAgaWYgKHNjZW5lRGVmLmV4dGVuc2lvbnMpXG4gICAgICBhZGRVbmtub3duRXh0ZW5zaW9uc1RvVXNlckRhdGEoZXh0ZW5zaW9ucywgc2NlbmUsIHNjZW5lRGVmKTtcbiAgICBjb25zdCBub2RlSWRzID0gc2NlbmVEZWYubm9kZXMgfHwgW107XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IG5vZGVJZHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgcGVuZGluZy5wdXNoKHBhcnNlci5nZXREZXBlbmRlbmN5KFwibm9kZVwiLCBub2RlSWRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKG5vZGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWwgPSBub2Rlcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIHNjZW5lLmFkZChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWR1Y2VBc3NvY2lhdGlvbnMgPSAobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByZWR1Y2VkQXNzb2NpYXRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyc2VyLmFzc29jaWF0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBNYXRlcmlhbCB8fCBrZXkgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICByZWR1Y2VkQXNzb2NpYXRpb25zLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50cmF2ZXJzZSgobm9kZTIpID0+IHtcbiAgICAgICAgICBjb25zdCBtYXBwaW5ncyA9IHBhcnNlci5hc3NvY2lhdGlvbnMuZ2V0KG5vZGUyKTtcbiAgICAgICAgICBpZiAobWFwcGluZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVkdWNlZEFzc29jaWF0aW9ucy5zZXQobm9kZTIsIG1hcHBpbmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVkdWNlZEFzc29jaWF0aW9ucztcbiAgICAgIH07XG4gICAgICBwYXJzZXIuYXNzb2NpYXRpb25zID0gcmVkdWNlQXNzb2NpYXRpb25zKHNjZW5lKTtcbiAgICAgIHJldHVybiBzY2VuZTtcbiAgICB9KTtcbiAgfVxuICBfY3JlYXRlQW5pbWF0aW9uVHJhY2tzKG5vZGUsIGlucHV0QWNjZXNzb3IsIG91dHB1dEFjY2Vzc29yLCBzYW1wbGVyLCB0YXJnZXQpIHtcbiAgICBjb25zdCB0cmFja3MgPSBbXTtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gbm9kZS5uYW1lID8gbm9kZS5uYW1lIDogbm9kZS51dWlkO1xuICAgIGNvbnN0IHRhcmdldE5hbWVzID0gW107XG4gICAgaWYgKFBBVEhfUFJPUEVSVElFU1t0YXJnZXQucGF0aF0gPT09IFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzKSB7XG4gICAgICBub2RlLnRyYXZlcnNlKGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcykge1xuICAgICAgICAgIHRhcmdldE5hbWVzLnB1c2gob2JqZWN0Lm5hbWUgPyBvYmplY3QubmFtZSA6IG9iamVjdC51dWlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldE5hbWVzLnB1c2godGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIGxldCBUeXBlZEtleWZyYW1lVHJhY2s7XG4gICAgc3dpdGNoIChQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdKSB7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy53ZWlnaHRzOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnJvdGF0aW9uOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBBVEhfUFJPUEVSVElFUy5wb3NpdGlvbjpcbiAgICAgIGNhc2UgUEFUSF9QUk9QRVJUSUVTLnNjYWxlOlxuICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBWZWN0b3JLZXlmcmFtZVRyYWNrO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN3aXRjaCAob3V0cHV0QWNjZXNzb3IuaXRlbVNpemUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBUeXBlZEtleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgVHlwZWRLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9uID0gc2FtcGxlci5pbnRlcnBvbGF0aW9uICE9PSB2b2lkIDAgPyBJTlRFUlBPTEFUSU9OW3NhbXBsZXIuaW50ZXJwb2xhdGlvbl0gOiBJbnRlcnBvbGF0ZUxpbmVhcjtcbiAgICBjb25zdCBvdXRwdXRBcnJheSA9IHRoaXMuX2dldEFycmF5RnJvbUFjY2Vzc29yKG91dHB1dEFjY2Vzc29yKTtcbiAgICBmb3IgKGxldCBqID0gMCwgamwgPSB0YXJnZXROYW1lcy5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICBjb25zdCB0cmFjayA9IG5ldyBUeXBlZEtleWZyYW1lVHJhY2soXG4gICAgICAgIHRhcmdldE5hbWVzW2pdICsgXCIuXCIgKyBQQVRIX1BST1BFUlRJRVNbdGFyZ2V0LnBhdGhdLFxuICAgICAgICBpbnB1dEFjY2Vzc29yLmFycmF5LFxuICAgICAgICBvdXRwdXRBcnJheSxcbiAgICAgICAgaW50ZXJwb2xhdGlvblxuICAgICAgKTtcbiAgICAgIGlmIChzYW1wbGVyLmludGVycG9sYXRpb24gPT09IFwiQ1VCSUNTUExJTkVcIikge1xuICAgICAgICB0aGlzLl9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQodHJhY2spO1xuICAgICAgfVxuICAgICAgdHJhY2tzLnB1c2godHJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2tzO1xuICB9XG4gIF9nZXRBcnJheUZyb21BY2Nlc3NvcihhY2Nlc3Nvcikge1xuICAgIGxldCBvdXRwdXRBcnJheSA9IGFjY2Vzc29yLmFycmF5O1xuICAgIGlmIChhY2Nlc3Nvci5ub3JtYWxpemVkKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IGdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZShvdXRwdXRBcnJheS5jb25zdHJ1Y3Rvcik7XG4gICAgICBjb25zdCBzY2FsZWQgPSBuZXcgRmxvYXQzMkFycmF5KG91dHB1dEFycmF5Lmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBqID0gMCwgamwgPSBvdXRwdXRBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgIHNjYWxlZFtqXSA9IG91dHB1dEFycmF5W2pdICogc2NhbGU7XG4gICAgICB9XG4gICAgICBvdXRwdXRBcnJheSA9IHNjYWxlZDtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dEFycmF5O1xuICB9XG4gIF9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQodHJhY2spIHtcbiAgICB0cmFjay5jcmVhdGVJbnRlcnBvbGFudCA9IGZ1bmN0aW9uIEludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZShyZXN1bHQpIHtcbiAgICAgIGNvbnN0IGludGVycG9sYW50VHlwZSA9IHRoaXMgaW5zdGFuY2VvZiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayA/IEdMVEZDdWJpY1NwbGluZVF1YXRlcm5pb25JbnRlcnBvbGFudCA6IEdMVEZDdWJpY1NwbGluZUludGVycG9sYW50O1xuICAgICAgcmV0dXJuIG5ldyBpbnRlcnBvbGFudFR5cGUodGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCkgLyAzLCByZXN1bHQpO1xuICAgIH07XG4gICAgdHJhY2suY3JlYXRlSW50ZXJwb2xhbnQuaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IGJveCA9IG5ldyBCb3gzKCk7XG4gIGlmIChhdHRyaWJ1dGVzLlBPU0lUSU9OICE9PSB2b2lkIDApIHtcbiAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1thdHRyaWJ1dGVzLlBPU0lUSU9OXTtcbiAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgY29uc3QgbWF4ID0gYWNjZXNzb3IubWF4O1xuICAgIGlmIChtaW4gIT09IHZvaWQgMCAmJiBtYXggIT09IHZvaWQgMCkge1xuICAgICAgYm94LnNldChuZXcgVmVjdG9yMyhtaW5bMF0sIG1pblsxXSwgbWluWzJdKSwgbmV3IFZlY3RvcjMobWF4WzBdLCBtYXhbMV0sIG1heFsyXSkpO1xuICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgYm94U2NhbGUgPSBnZXROb3JtYWxpemVkQ29tcG9uZW50U2NhbGUoV0VCR0xfQ09NUE9ORU5UX1RZUEVTW2FjY2Vzc29yLmNvbXBvbmVudFR5cGVdKTtcbiAgICAgICAgYm94Lm1pbi5tdWx0aXBseVNjYWxhcihib3hTY2FsZSk7XG4gICAgICAgIGJveC5tYXgubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJUSFJFRS5HTFRGTG9hZGVyOiBNaXNzaW5nIG1pbi9tYXggcHJvcGVydGllcyBmb3IgYWNjZXNzb3IgUE9TSVRJT04uXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0cyA9IHByaW1pdGl2ZURlZi50YXJnZXRzO1xuICBpZiAodGFyZ2V0cyAhPT0gdm9pZCAwKSB7XG4gICAgY29uc3QgbWF4RGlzcGxhY2VtZW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbCA9IHRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGlmICh0YXJnZXQuUE9TSVRJT04gIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBhY2Nlc3NvciA9IHBhcnNlci5qc29uLmFjY2Vzc29yc1t0YXJnZXQuUE9TSVRJT05dO1xuICAgICAgICBjb25zdCBtaW4gPSBhY2Nlc3Nvci5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IGFjY2Vzc29yLm1heDtcbiAgICAgICAgaWYgKG1pbiAhPT0gdm9pZCAwICYmIG1heCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmVjdG9yLnNldFgoTWF0aC5tYXgoTWF0aC5hYnMobWluWzBdKSwgTWF0aC5hYnMobWF4WzBdKSkpO1xuICAgICAgICAgIHZlY3Rvci5zZXRZKE1hdGgubWF4KE1hdGguYWJzKG1pblsxXSksIE1hdGguYWJzKG1heFsxXSkpKTtcbiAgICAgICAgICB2ZWN0b3Iuc2V0WihNYXRoLm1heChNYXRoLmFicyhtaW5bMl0pLCBNYXRoLmFicyhtYXhbMl0pKSk7XG4gICAgICAgICAgaWYgKGFjY2Vzc29yLm5vcm1hbGl6ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveFNjYWxlID0gZ2V0Tm9ybWFsaXplZENvbXBvbmVudFNjYWxlKFdFQkdMX0NPTVBPTkVOVF9UWVBFU1thY2Nlc3Nvci5jb21wb25lbnRUeXBlXSk7XG4gICAgICAgICAgICB2ZWN0b3IubXVsdGlwbHlTY2FsYXIoYm94U2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXhEaXNwbGFjZW1lbnQubWF4KHZlY3Rvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVEhSRUUuR0xURkxvYWRlcjogTWlzc2luZyBtaW4vbWF4IHByb3BlcnRpZXMgZm9yIGFjY2Vzc29yIFBPU0lUSU9OLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBib3guZXhwYW5kQnlWZWN0b3IobWF4RGlzcGxhY2VtZW50KTtcbiAgfVxuICBnZW9tZXRyeS5ib3VuZGluZ0JveCA9IGJveDtcbiAgY29uc3Qgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuICBib3guZ2V0Q2VudGVyKHNwaGVyZS5jZW50ZXIpO1xuICBzcGhlcmUucmFkaXVzID0gYm94Lm1pbi5kaXN0YW5jZVRvKGJveC5tYXgpIC8gMjtcbiAgZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPSBzcGhlcmU7XG59XG5mdW5jdGlvbiBhZGRQcmltaXRpdmVBdHRyaWJ1dGVzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gcHJpbWl0aXZlRGVmLmF0dHJpYnV0ZXM7XG4gIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgZnVuY3Rpb24gYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYWNjZXNzb3JJbmRleCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiBwYXJzZXIuZ2V0RGVwZW5kZW5jeShcImFjY2Vzc29yXCIsIGFjY2Vzc29ySW5kZXgpLnRoZW4oZnVuY3Rpb24oYWNjZXNzb3IpIHtcbiAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBhY2Nlc3Nvcik7XG4gICAgfSk7XG4gIH1cbiAgZm9yIChjb25zdCBnbHRmQXR0cmlidXRlTmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdGhyZWVBdHRyaWJ1dGVOYW1lID0gQVRUUklCVVRFU1tnbHRmQXR0cmlidXRlTmFtZV0gfHwgZ2x0ZkF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAodGhyZWVBdHRyaWJ1dGVOYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpXG4gICAgICBjb250aW51ZTtcbiAgICBwZW5kaW5nLnB1c2goYXNzaWduQXR0cmlidXRlQWNjZXNzb3IoYXR0cmlidXRlc1tnbHRmQXR0cmlidXRlTmFtZV0sIHRocmVlQXR0cmlidXRlTmFtZSkpO1xuICB9XG4gIGlmIChwcmltaXRpdmVEZWYuaW5kaWNlcyAhPT0gdm9pZCAwICYmICFnZW9tZXRyeS5pbmRleCkge1xuICAgIGNvbnN0IGFjY2Vzc29yID0gcGFyc2VyLmdldERlcGVuZGVuY3koXCJhY2Nlc3NvclwiLCBwcmltaXRpdmVEZWYuaW5kaWNlcykudGhlbihmdW5jdGlvbihhY2Nlc3NvcjIpIHtcbiAgICAgIGdlb21ldHJ5LnNldEluZGV4KGFjY2Vzc29yMik7XG4gICAgfSk7XG4gICAgcGVuZGluZy5wdXNoKGFjY2Vzc29yKTtcbiAgfVxuICBhc3NpZ25FeHRyYXNUb1VzZXJEYXRhKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYpO1xuICBjb21wdXRlQm91bmRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYsIHBhcnNlcik7XG4gIHJldHVybiBQcm9taXNlLmFsbChwZW5kaW5nKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcmltaXRpdmVEZWYudGFyZ2V0cyAhPT0gdm9pZCAwID8gYWRkTW9ycGhUYXJnZXRzKGdlb21ldHJ5LCBwcmltaXRpdmVEZWYudGFyZ2V0cywgcGFyc2VyKSA6IGdlb21ldHJ5O1xuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEdMVEZMb2FkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HTFRGTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkxvYWRlciIsIkxvYWRlclV0aWxzIiwiRmlsZUxvYWRlciIsIkNvbG9yIiwiU3BvdExpZ2h0IiwiUG9pbnRMaWdodCIsIkRpcmVjdGlvbmFsTGlnaHQiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIk1lc2hQaHlzaWNhbE1hdGVyaWFsIiwiVmVjdG9yMiIsIk1hdHJpeDQiLCJWZWN0b3IzIiwiUXVhdGVybmlvbiIsIkluc3RhbmNlZE1lc2giLCJJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUiLCJPYmplY3QzRCIsIlRleHR1cmVMb2FkZXIiLCJJbWFnZUJpdG1hcExvYWRlciIsIkJ1ZmZlckF0dHJpYnV0ZSIsIkludGVybGVhdmVkQnVmZmVyIiwiSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJMaW5lYXJGaWx0ZXIiLCJMaW5lYXJNaXBtYXBMaW5lYXJGaWx0ZXIiLCJSZXBlYXRXcmFwcGluZyIsIlBvaW50c01hdGVyaWFsIiwiTWF0ZXJpYWwiLCJMaW5lQmFzaWNNYXRlcmlhbCIsIk1lc2hTdGFuZGFyZE1hdGVyaWFsIiwiRG91YmxlU2lkZSIsIlByb3BlcnR5QmluZGluZyIsIkJ1ZmZlckdlb21ldHJ5IiwiU2tpbm5lZE1lc2giLCJNZXNoIiwiVHJpYW5nbGVTdHJpcERyYXdNb2RlIiwiVHJpYW5nbGVGYW5EcmF3TW9kZSIsIkxpbmVTZWdtZW50cyIsIkxpbmUiLCJMaW5lTG9vcCIsIlBvaW50cyIsIkdyb3VwIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJNYXRoVXRpbHMiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJTa2VsZXRvbiIsIkFuaW1hdGlvbkNsaXAiLCJCb25lIiwiSW50ZXJwb2xhdGVMaW5lYXIiLCJOZWFyZXN0RmlsdGVyIiwiTmVhcmVzdE1pcG1hcE5lYXJlc3RGaWx0ZXIiLCJMaW5lYXJNaXBtYXBOZWFyZXN0RmlsdGVyIiwiTmVhcmVzdE1pcG1hcExpbmVhckZpbHRlciIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJNaXJyb3JlZFJlcGVhdFdyYXBwaW5nIiwiSW50ZXJwb2xhdGVEaXNjcmV0ZSIsIkZyb250U2lkZSIsIlRleHR1cmUiLCJWZWN0b3JLZXlmcmFtZVRyYWNrIiwiTnVtYmVyS2V5ZnJhbWVUcmFjayIsIlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrIiwiQm94MyIsIlNwaGVyZSIsIkludGVycG9sYW50IiwidG9UcmlhbmdsZXNEcmF3TW9kZSIsInZlcnNpb24iLCJkZWNvZGVUZXh0IiwiU1JHQkNvbG9yU3BhY2UiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsInNSR0JFbmNvZGluZyIsIkxpbmVhckVuY29kaW5nIiwiR0xURkxvYWRlciIsImNvbnN0cnVjdG9yIiwibWFuYWdlciIsImRyYWNvTG9hZGVyIiwia3R4MkxvYWRlciIsIm1lc2hvcHREZWNvZGVyIiwicGx1Z2luQ2FsbGJhY2tzIiwicmVnaXN0ZXIiLCJwYXJzZXIiLCJHTFRGTWF0ZXJpYWxzQ2xlYXJjb2F0RXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0Rpc3BlcnNpb25FeHRlbnNpb24iLCJHTFRGVGV4dHVyZUJhc2lzVUV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlV2ViUEV4dGVuc2lvbiIsIkdMVEZUZXh0dXJlQVZJRkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNTaGVlbkV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNUcmFuc21pc3Npb25FeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzVm9sdW1lRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lvckV4dGVuc2lvbiIsIkdMVEZNYXRlcmlhbHNFbWlzc2l2ZVN0cmVuZ3RoRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc1NwZWN1bGFyRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0lyaWRlc2NlbmNlRXh0ZW5zaW9uIiwiR0xURk1hdGVyaWFsc0FuaXNvdHJvcHlFeHRlbnNpb24iLCJHTFRGTWF0ZXJpYWxzQnVtcEV4dGVuc2lvbiIsIkdMVEZMaWdodHNFeHRlbnNpb24iLCJHTFRGTWVzaG9wdENvbXByZXNzaW9uIiwiR0xURk1lc2hHcHVJbnN0YW5jaW5nIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwic2NvcGUiLCJyZXNvdXJjZVBhdGgiLCJwYXRoIiwicmVsYXRpdmVVcmwiLCJleHRyYWN0VXJsQmFzZSIsInJlc29sdmVVUkwiLCJpdGVtU3RhcnQiLCJfb25FcnJvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJpdGVtRXJyb3IiLCJpdGVtRW5kIiwibG9hZGVyIiwic2V0UGF0aCIsInNldFJlc3BvbnNlVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJyZXF1ZXN0SGVhZGVyIiwic2V0V2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiZGF0YSIsInBhcnNlIiwiZ2x0ZiIsInNldERSQUNPTG9hZGVyIiwic2V0RERTTG9hZGVyIiwiRXJyb3IiLCJzZXRLVFgyTG9hZGVyIiwic2V0TWVzaG9wdERlY29kZXIiLCJjYWxsYmFjayIsImluZGV4T2YiLCJwdXNoIiwidW5yZWdpc3RlciIsInNwbGljZSIsImpzb24iLCJleHRlbnNpb25zIiwicGx1Z2lucyIsIkpTT04iLCJBcnJheUJ1ZmZlciIsIm1hZ2ljIiwiVWludDhBcnJheSIsInNsaWNlIiwiQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTUFHSUMiLCJFWFRFTlNJT05TIiwiS0hSX0JJTkFSWV9HTFRGIiwiR0xURkJpbmFyeUV4dGVuc2lvbiIsImNvbnRlbnQiLCJhc3NldCIsIkdMVEZQYXJzZXIiLCJjcm9zc09yaWdpbiIsImZpbGVMb2FkZXIiLCJpIiwibGVuZ3RoIiwicGx1Z2luIiwibmFtZSIsImV4dGVuc2lvbnNVc2VkIiwiZXh0ZW5zaW9uTmFtZSIsImV4dGVuc2lvbnNSZXF1aXJlZCIsIktIUl9NQVRFUklBTFNfVU5MSVQiLCJHTFRGTWF0ZXJpYWxzVW5saXRFeHRlbnNpb24iLCJLSFJfRFJBQ09fTUVTSF9DT01QUkVTU0lPTiIsIkdMVEZEcmFjb01lc2hDb21wcmVzc2lvbkV4dGVuc2lvbiIsIktIUl9URVhUVVJFX1RSQU5TRk9STSIsIkdMVEZUZXh0dXJlVHJhbnNmb3JtRXh0ZW5zaW9uIiwiS0hSX01FU0hfUVVBTlRJWkFUSU9OIiwiR0xURk1lc2hRdWFudGl6YXRpb25FeHRlbnNpb24iLCJ3YXJuIiwic2V0RXh0ZW5zaW9ucyIsInNldFBsdWdpbnMiLCJwYXJzZUFzeW5jIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJHTFRGUmVnaXN0cnkiLCJvYmplY3RzIiwiZ2V0Iiwia2V5IiwiYWRkIiwib2JqZWN0IiwicmVtb3ZlIiwicmVtb3ZlQWxsIiwiS0hSX0xJR0hUU19QVU5DVFVBTCIsIktIUl9NQVRFUklBTFNfQ0xFQVJDT0FUIiwiS0hSX01BVEVSSUFMU19ESVNQRVJTSU9OIiwiS0hSX01BVEVSSUFMU19JT1IiLCJLSFJfTUFURVJJQUxTX1NIRUVOIiwiS0hSX01BVEVSSUFMU19TUEVDVUxBUiIsIktIUl9NQVRFUklBTFNfVFJBTlNNSVNTSU9OIiwiS0hSX01BVEVSSUFMU19JUklERVNDRU5DRSIsIktIUl9NQVRFUklBTFNfQU5JU09UUk9QWSIsIktIUl9NQVRFUklBTFNfVk9MVU1FIiwiS0hSX1RFWFRVUkVfQkFTSVNVIiwiS0hSX01BVEVSSUFMU19FTUlTU0lWRV9TVFJFTkdUSCIsIkVYVF9NQVRFUklBTFNfQlVNUCIsIkVYVF9URVhUVVJFX1dFQlAiLCJFWFRfVEVYVFVSRV9BVklGIiwiRVhUX01FU0hPUFRfQ09NUFJFU1NJT04iLCJFWFRfTUVTSF9HUFVfSU5TVEFOQ0lORyIsImNhY2hlIiwicmVmcyIsInVzZXMiLCJfbWFya0RlZnMiLCJub2RlRGVmcyIsIm5vZGVzIiwibm9kZUluZGV4Iiwibm9kZUxlbmd0aCIsIm5vZGVEZWYiLCJsaWdodCIsIl9hZGROb2RlUmVmIiwiX2xvYWRMaWdodCIsImxpZ2h0SW5kZXgiLCJjYWNoZUtleSIsImRlcGVuZGVuY3kiLCJsaWdodERlZnMiLCJsaWdodHMiLCJsaWdodERlZiIsImxpZ2h0Tm9kZSIsImNvbG9yIiwic2V0UkdCIiwicmFuZ2UiLCJ0eXBlIiwidGFyZ2V0IiwicG9zaXRpb24iLCJzZXQiLCJkaXN0YW5jZSIsInNwb3QiLCJpbm5lckNvbmVBbmdsZSIsIm91dGVyQ29uZUFuZ2xlIiwiTWF0aCIsIlBJIiwiYW5nbGUiLCJwZW51bWJyYSIsImRlY2F5IiwiYXNzaWduRXh0cmFzVG9Vc2VyRGF0YSIsImludGVuc2l0eSIsImNyZWF0ZVVuaXF1ZU5hbWUiLCJnZXREZXBlbmRlbmN5IiwiaW5kZXgiLCJjcmVhdGVOb2RlQXR0YWNobWVudCIsInNlbGYyIiwidGhlbiIsIl9nZXROb2RlUmVmIiwiZ2V0TWF0ZXJpYWxUeXBlIiwiZXh0ZW5kUGFyYW1zIiwibWF0ZXJpYWxQYXJhbXMiLCJtYXRlcmlhbERlZiIsInBlbmRpbmciLCJvcGFjaXR5IiwibWV0YWxsaWNSb3VnaG5lc3MiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyIsIkFycmF5IiwiaXNBcnJheSIsImJhc2VDb2xvckZhY3RvciIsImFycmF5IiwiYmFzZUNvbG9yVGV4dHVyZSIsImFzc2lnblRleHR1cmUiLCJhbGwiLCJleHRlbmRNYXRlcmlhbFBhcmFtcyIsIm1hdGVyaWFsSW5kZXgiLCJtYXRlcmlhbHMiLCJlbWlzc2l2ZVN0cmVuZ3RoIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJleHRlbnNpb24iLCJjbGVhcmNvYXRGYWN0b3IiLCJjbGVhcmNvYXQiLCJjbGVhcmNvYXRUZXh0dXJlIiwiY2xlYXJjb2F0Um91Z2huZXNzRmFjdG9yIiwiY2xlYXJjb2F0Um91Z2huZXNzIiwiY2xlYXJjb2F0Um91Z2huZXNzVGV4dHVyZSIsImNsZWFyY29hdE5vcm1hbFRleHR1cmUiLCJzY2FsZSIsImNsZWFyY29hdE5vcm1hbFNjYWxlIiwiZGlzcGVyc2lvbiIsImlyaWRlc2NlbmNlRmFjdG9yIiwiaXJpZGVzY2VuY2UiLCJpcmlkZXNjZW5jZVRleHR1cmUiLCJpcmlkZXNjZW5jZUlvciIsImlyaWRlc2NlbmNlSU9SIiwiaXJpZGVzY2VuY2VUaGlja25lc3NSYW5nZSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWluaW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzTWF4aW11bSIsImlyaWRlc2NlbmNlVGhpY2tuZXNzVGV4dHVyZSIsInNoZWVuQ29sb3IiLCJzaGVlblJvdWdobmVzcyIsInNoZWVuIiwic2hlZW5Db2xvckZhY3RvciIsImNvbG9yRmFjdG9yIiwic2hlZW5Sb3VnaG5lc3NGYWN0b3IiLCJzaGVlbkNvbG9yVGV4dHVyZSIsInNoZWVuUm91Z2huZXNzVGV4dHVyZSIsInRyYW5zbWlzc2lvbkZhY3RvciIsInRyYW5zbWlzc2lvbiIsInRyYW5zbWlzc2lvblRleHR1cmUiLCJ0aGlja25lc3MiLCJ0aGlja25lc3NGYWN0b3IiLCJ0aGlja25lc3NUZXh0dXJlIiwiYXR0ZW51YXRpb25EaXN0YW5jZSIsIkluZmluaXR5IiwiY29sb3JBcnJheSIsImF0dGVudWF0aW9uQ29sb3IiLCJpb3IiLCJzcGVjdWxhckludGVuc2l0eSIsInNwZWN1bGFyRmFjdG9yIiwic3BlY3VsYXJUZXh0dXJlIiwic3BlY3VsYXJDb2xvckZhY3RvciIsInNwZWN1bGFyQ29sb3IiLCJzcGVjdWxhckNvbG9yVGV4dHVyZSIsImJ1bXBTY2FsZSIsImJ1bXBGYWN0b3IiLCJidW1wVGV4dHVyZSIsImFuaXNvdHJvcHlTdHJlbmd0aCIsImFuaXNvdHJvcHkiLCJhbmlzb3Ryb3B5Um90YXRpb24iLCJhbmlzb3Ryb3B5VGV4dHVyZSIsImxvYWRUZXh0dXJlIiwidGV4dHVyZUluZGV4IiwidGV4dHVyZURlZiIsInRleHR1cmVzIiwib3B0aW9ucyIsImxvYWRUZXh0dXJlSW1hZ2UiLCJzb3VyY2UiLCJpc1N1cHBvcnRlZCIsImltYWdlcyIsInRleHR1cmVMb2FkZXIiLCJ1cmkiLCJoYW5kbGVyIiwiZ2V0SGFuZGxlciIsImRldGVjdFN1cHBvcnQiLCJpbWFnZSIsIkltYWdlIiwic3JjIiwib25sb2FkIiwib25lcnJvciIsImhlaWdodCIsImxvYWRCdWZmZXJWaWV3IiwiYnVmZmVyVmlldyIsImJ1ZmZlclZpZXdzIiwiZXh0ZW5zaW9uRGVmIiwiYnVmZmVyIiwiZGVjb2RlciIsInN1cHBvcnRlZCIsInJlcyIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiY291bnQiLCJzdHJpZGUiLCJieXRlU3RyaWRlIiwiZGVjb2RlR2x0ZkJ1ZmZlckFzeW5jIiwibW9kZSIsImZpbHRlciIsInJlczIiLCJyZWFkeSIsInJlc3VsdCIsImRlY29kZUdsdGZCdWZmZXIiLCJjcmVhdGVOb2RlTWVzaCIsIm1lc2giLCJtZXNoRGVmIiwibWVzaGVzIiwicHJpbWl0aXZlIiwicHJpbWl0aXZlcyIsIldFQkdMX0NPTlNUQU5UUyIsIlRSSUFOR0xFUyIsIlRSSUFOR0xFX1NUUklQIiwiVFJJQU5HTEVfRkFOIiwiYXR0cmlidXRlc0RlZiIsImF0dHJpYnV0ZXMiLCJhY2Nlc3NvciIsInJlc3VsdHMiLCJub2RlT2JqZWN0IiwicG9wIiwiaXNHcm91cCIsImNoaWxkcmVuIiwiaW5zdGFuY2VkTWVzaGVzIiwibSIsInAiLCJxIiwicyIsImluc3RhbmNlZE1lc2giLCJnZW9tZXRyeSIsIm1hdGVyaWFsIiwiVFJBTlNMQVRJT04iLCJmcm9tQnVmZmVyQXR0cmlidXRlIiwiUk9UQVRJT04iLCJTQ0FMRSIsInNldE1hdHJpeEF0IiwiY29tcG9zZSIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyIiwiaW5zdGFuY2VDb2xvciIsIml0ZW1TaXplIiwibm9ybWFsaXplZCIsInNldEF0dHJpYnV0ZSIsInByb3RvdHlwZSIsImNvcHkiLCJjYWxsIiwiYXNzaWduRmluYWxNYXRlcmlhbCIsImNsZWFyIiwiQklOQVJZX0VYVEVOU0lPTl9IRUFERVJfTEVOR1RIIiwiQklOQVJZX0VYVEVOU0lPTl9DSFVOS19UWVBFUyIsIkJJTiIsImJvZHkiLCJoZWFkZXJWaWV3IiwiRGF0YVZpZXciLCJoZWFkZXIiLCJnZXRVaW50MzIiLCJjaHVua0NvbnRlbnRzTGVuZ3RoIiwiY2h1bmtWaWV3IiwiY2h1bmtJbmRleCIsImNodW5rTGVuZ3RoIiwiY2h1bmtUeXBlIiwiY29udGVudEFycmF5IiwicHJlbG9hZCIsImRlY29kZVByaW1pdGl2ZSIsImJ1ZmZlclZpZXdJbmRleCIsImdsdGZBdHRyaWJ1dGVNYXAiLCJ0aHJlZUF0dHJpYnV0ZU1hcCIsImF0dHJpYnV0ZU5vcm1hbGl6ZWRNYXAiLCJhdHRyaWJ1dGVUeXBlTWFwIiwidGhyZWVBdHRyaWJ1dGVOYW1lIiwiQVRUUklCVVRFUyIsInRvTG93ZXJDYXNlIiwiYWNjZXNzb3JEZWYiLCJhY2Nlc3NvcnMiLCJjb21wb25lbnRUeXBlIiwiV0VCR0xfQ09NUE9ORU5UX1RZUEVTIiwiZGVjb2RlRHJhY29GaWxlIiwiYXR0cmlidXRlIiwiZXh0ZW5kVGV4dHVyZSIsInRleHR1cmUiLCJ0cmFuc2Zvcm0iLCJ0ZXhDb29yZCIsImNoYW5uZWwiLCJvZmZzZXQiLCJyb3RhdGlvbiIsImNsb25lIiwiZnJvbUFycmF5IiwicmVwZWF0IiwibmVlZHNVcGRhdGUiLCJHTFRGQ3ViaWNTcGxpbmVJbnRlcnBvbGFudCIsInBhcmFtZXRlclBvc2l0aW9ucyIsInNhbXBsZVZhbHVlcyIsInNhbXBsZVNpemUiLCJyZXN1bHRCdWZmZXIiLCJjb3B5U2FtcGxlVmFsdWVfIiwidmFsdWVzIiwidmFsdWVTaXplIiwiaW50ZXJwb2xhdGVfIiwiaTEiLCJ0MCIsInQiLCJ0MSIsInN0cmlkZTIiLCJzdHJpZGUzIiwidGQiLCJwcCIsInBwcCIsIm9mZnNldDEiLCJvZmZzZXQwIiwiczIiLCJzMyIsInMwIiwiczEiLCJwMCIsIm0wIiwicDEiLCJtMSIsIl9xIiwiR0xURkN1YmljU3BsaW5lUXVhdGVybmlvbkludGVycG9sYW50Iiwibm9ybWFsaXplIiwidG9BcnJheSIsIkZMT0FUIiwiRkxPQVRfTUFUMyIsIkZMT0FUX01BVDQiLCJGTE9BVF9WRUMyIiwiRkxPQVRfVkVDMyIsIkZMT0FUX1ZFQzQiLCJMSU5FQVIiLCJSRVBFQVQiLCJTQU1QTEVSXzJEIiwiUE9JTlRTIiwiTElORVMiLCJMSU5FX0xPT1AiLCJMSU5FX1NUUklQIiwiVU5TSUdORURfQllURSIsIlVOU0lHTkVEX1NIT1JUIiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJXRUJHTF9GSUxURVJTIiwiV0VCR0xfV1JBUFBJTkdTIiwiV0VCR0xfVFlQRV9TSVpFUyIsIlNDQUxBUiIsIlZFQzIiLCJWRUMzIiwiVkVDNCIsIk1BVDIiLCJNQVQzIiwiTUFUNCIsIlBPU0lUSU9OIiwiTk9STUFMIiwiVEFOR0VOVCIsIlRFWENPT1JEXzAiLCJURVhDT09SRF8xIiwiVEVYQ09PUkRfMiIsIlRFWENPT1JEXzMiLCJDT0xPUl8wIiwiV0VJR0hUU18wIiwiSk9JTlRTXzAiLCJQQVRIX1BST1BFUlRJRVMiLCJ0cmFuc2xhdGlvbiIsIndlaWdodHMiLCJJTlRFUlBPTEFUSU9OIiwiQ1VCSUNTUExJTkUiLCJTVEVQIiwiQUxQSEFfTU9ERVMiLCJPUEFRVUUiLCJNQVNLIiwiQkxFTkQiLCJjcmVhdGVEZWZhdWx0TWF0ZXJpYWwiLCJlbWlzc2l2ZSIsIm1ldGFsbmVzcyIsInJvdWdobmVzcyIsInRyYW5zcGFyZW50IiwiZGVwdGhUZXN0Iiwic2lkZSIsImFkZFVua25vd25FeHRlbnNpb25zVG9Vc2VyRGF0YSIsImtub3duRXh0ZW5zaW9ucyIsIm9iamVjdERlZiIsInVzZXJEYXRhIiwiZ2x0ZkV4dGVuc2lvbnMiLCJnbHRmRGVmIiwiZXh0cmFzIiwiT2JqZWN0IiwiYXNzaWduIiwiYWRkTW9ycGhUYXJnZXRzIiwidGFyZ2V0cyIsImhhc01vcnBoUG9zaXRpb24iLCJoYXNNb3JwaE5vcm1hbCIsImhhc01vcnBoQ29sb3IiLCJpbCIsInBlbmRpbmdQb3NpdGlvbkFjY2Vzc29ycyIsInBlbmRpbmdOb3JtYWxBY2Nlc3NvcnMiLCJwZW5kaW5nQ29sb3JBY2Nlc3NvcnMiLCJwZW5kaW5nQWNjZXNzb3IiLCJub3JtYWwiLCJtb3JwaFBvc2l0aW9ucyIsIm1vcnBoTm9ybWFscyIsIm1vcnBoQ29sb3JzIiwibW9ycGhBdHRyaWJ1dGVzIiwibW9ycGhUYXJnZXRzUmVsYXRpdmUiLCJ1cGRhdGVNb3JwaFRhcmdldHMiLCJtb3JwaFRhcmdldEluZmx1ZW5jZXMiLCJ0YXJnZXROYW1lcyIsIm1vcnBoVGFyZ2V0RGljdGlvbmFyeSIsImNyZWF0ZVByaW1pdGl2ZUtleSIsInByaW1pdGl2ZURlZiIsImdlb21ldHJ5S2V5IiwiZHJhY29FeHRlbnNpb24iLCJpbmRpY2VzIiwiY3JlYXRlQXR0cmlidXRlc0tleSIsImF0dHJpYnV0ZXNLZXkiLCJrZXlzIiwic29ydCIsImdldE5vcm1hbGl6ZWRDb21wb25lbnRTY2FsZSIsImdldEltYWdlVVJJTWltZVR5cGUiLCJzZWFyY2giLCJfaWRlbnRpdHlNYXRyaXgiLCJhc3NvY2lhdGlvbnMiLCJNYXAiLCJwcmltaXRpdmVDYWNoZSIsIm5vZGVDYWNoZSIsIm1lc2hDYWNoZSIsImNhbWVyYUNhY2hlIiwibGlnaHRDYWNoZSIsInNvdXJjZUNhY2hlIiwidGV4dHVyZUNhY2hlIiwibm9kZU5hbWVzVXNlZCIsImlzU2FmYXJpIiwiaXNGaXJlZm94IiwiZmlyZWZveFZlcnNpb24iLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0ZXN0IiwibWF0Y2giLCJjcmVhdGVJbWFnZUJpdG1hcCIsInNldENyb3NzT3JpZ2luIiwiX2ludm9rZUFsbCIsImV4dCIsImJlZm9yZVJvb3QiLCJnZXREZXBlbmRlbmNpZXMiLCJkZXBlbmRlbmNpZXMiLCJzY2VuZSIsInNjZW5lcyIsImFuaW1hdGlvbnMiLCJjYW1lcmFzIiwiYWZ0ZXJSb290IiwidXBkYXRlTWF0cml4V29ybGQiLCJjYXRjaCIsInNraW5EZWZzIiwic2tpbnMiLCJtZXNoRGVmcyIsInNraW5JbmRleCIsInNraW5MZW5ndGgiLCJqb2ludHMiLCJpc0JvbmUiLCJza2luIiwiaXNTa2lubmVkTWVzaCIsImNhbWVyYSIsInJlZiIsInVwZGF0ZU1hcHBpbmdzIiwib3JpZ2luYWwiLCJtYXBwaW5ncyIsImNoaWxkIiwiZW50cmllcyIsIl9pbnZva2VPbmUiLCJmdW5jIiwidW5zaGlmdCIsImxvYWRTY2VuZSIsImxvYWROb2RlIiwibG9hZE1lc2giLCJsb2FkQWNjZXNzb3IiLCJsb2FkQnVmZmVyIiwibG9hZE1hdGVyaWFsIiwibG9hZFNraW4iLCJsb2FkQW5pbWF0aW9uIiwibG9hZENhbWVyYSIsImRlZnMiLCJtYXAiLCJkZWYiLCJidWZmZXJJbmRleCIsImJ1ZmZlckRlZiIsImJ1ZmZlcnMiLCJidWZmZXJWaWV3RGVmIiwiYWNjZXNzb3JJbmRleCIsInNwYXJzZSIsIlR5cGVkQXJyYXkiLCJwZW5kaW5nQnVmZmVyVmlld3MiLCJlbGVtZW50Qnl0ZXMiLCJCWVRFU19QRVJfRUxFTUVOVCIsIml0ZW1CeXRlcyIsImJ1ZmZlckF0dHJpYnV0ZSIsImliU2xpY2UiLCJmbG9vciIsImliQ2FjaGVLZXkiLCJpYiIsIml0ZW1TaXplSW5kaWNlcyIsIlR5cGVkQXJyYXlJbmRpY2VzIiwiYnl0ZU9mZnNldEluZGljZXMiLCJieXRlT2Zmc2V0VmFsdWVzIiwic3BhcnNlSW5kaWNlcyIsInNwYXJzZVZhbHVlcyIsInNldFgiLCJzZXRZIiwic2V0WiIsInNldFciLCJzb3VyY2VJbmRleCIsInNvdXJjZURlZiIsInNhbXBsZXIiLCJwcm9taXNlIiwibG9hZEltYWdlU291cmNlIiwiZmxpcFkiLCJzdGFydHNXaXRoIiwic2FtcGxlcnMiLCJtYWdGaWx0ZXIiLCJtaW5GaWx0ZXIiLCJ3cmFwUyIsIndyYXBUIiwiVVJMIiwic2VsZiIsIndlYmtpdFVSTCIsInNvdXJjZVVSSSIsImlzT2JqZWN0VVJMIiwiYmxvYiIsIkJsb2IiLCJtaW1lVHlwZSIsImNyZWF0ZU9iamVjdFVSTCIsInNvdXJjZVVSSTIiLCJpc0ltYWdlQml0bWFwTG9hZGVyIiwiaW1hZ2VCaXRtYXAiLCJyZXZva2VPYmplY3RVUkwiLCJtYXBOYW1lIiwibWFwRGVmIiwiY29sb3JTcGFjZSIsImdsdGZSZWZlcmVuY2UiLCJlbmNvZGluZyIsInVzZURlcml2YXRpdmVUYW5nZW50cyIsInRhbmdlbnQiLCJ1c2VWZXJ0ZXhDb2xvcnMiLCJ1c2VGbGF0U2hhZGluZyIsImlzUG9pbnRzIiwidXVpZCIsInBvaW50c01hdGVyaWFsIiwic2l6ZUF0dGVudWF0aW9uIiwiaXNMaW5lIiwibGluZU1hdGVyaWFsIiwiY2FjaGVkTWF0ZXJpYWwiLCJ2ZXJ0ZXhDb2xvcnMiLCJmbGF0U2hhZGluZyIsIm5vcm1hbFNjYWxlIiwieSIsIm1hdGVyaWFsVHlwZSIsIm1hdGVyaWFsRXh0ZW5zaW9ucyIsImttdUV4dGVuc2lvbiIsIm1ldGFsbGljRmFjdG9yIiwicm91Z2huZXNzRmFjdG9yIiwibWV0YWxsaWNSb3VnaG5lc3NUZXh0dXJlIiwiZG91YmxlU2lkZWQiLCJhbHBoYU1vZGUiLCJkZXB0aFdyaXRlIiwiYWxwaGFUZXN0IiwiYWxwaGFDdXRvZmYiLCJub3JtYWxUZXh0dXJlIiwib2NjbHVzaW9uVGV4dHVyZSIsInN0cmVuZ3RoIiwiYW9NYXBJbnRlbnNpdHkiLCJlbWlzc2l2ZUZhY3RvciIsImVtaXNzaXZlVGV4dHVyZSIsIm9yaWdpbmFsTmFtZSIsInNhbml0aXplZE5hbWUiLCJzYW5pdGl6ZU5vZGVOYW1lIiwibG9hZEdlb21ldHJpZXMiLCJjcmVhdGVEcmFjb1ByaW1pdGl2ZSIsImFkZFByaW1pdGl2ZUF0dHJpYnV0ZXMiLCJjYWNoZWQiLCJnZW9tZXRyeVByb21pc2UiLCJtZXNoSW5kZXgiLCJnZW9tZXRyaWVzIiwibm9ybWFsaXplU2tpbldlaWdodHMiLCJncm91cCIsImNhbWVyYUluZGV4IiwiY2FtZXJhRGVmIiwicGFyYW1zIiwicmFkVG9EZWciLCJ5Zm92IiwiYXNwZWN0UmF0aW8iLCJ6bmVhciIsInpmYXIiLCJ4bWFnIiwieW1hZyIsInNraW5EZWYiLCJfbG9hZE5vZGVTaGFsbG93IiwiaW52ZXJzZUJpbmRNYXRyaWNlcyIsImpvaW50Tm9kZXMiLCJib25lcyIsImJvbmVJbnZlcnNlcyIsImpvaW50Tm9kZSIsIm1hdCIsImFuaW1hdGlvbkluZGV4IiwiYW5pbWF0aW9uRGVmIiwiYW5pbWF0aW9uTmFtZSIsInBlbmRpbmdOb2RlcyIsInBlbmRpbmdJbnB1dEFjY2Vzc29ycyIsInBlbmRpbmdPdXRwdXRBY2Nlc3NvcnMiLCJwZW5kaW5nU2FtcGxlcnMiLCJwZW5kaW5nVGFyZ2V0cyIsImNoYW5uZWxzIiwibm9kZSIsImlucHV0IiwicGFyYW1ldGVycyIsIm91dHB1dCIsImlucHV0QWNjZXNzb3JzIiwib3V0cHV0QWNjZXNzb3JzIiwidHJhY2tzIiwiaW5wdXRBY2Nlc3NvciIsIm91dHB1dEFjY2Vzc29yIiwidXBkYXRlTWF0cml4IiwiY3JlYXRlZFRyYWNrcyIsIl9jcmVhdGVBbmltYXRpb25UcmFja3MiLCJrIiwidHJhdmVyc2UiLCJvIiwiaXNNZXNoIiwibm9kZVBlbmRpbmciLCJjaGlsZFBlbmRpbmciLCJjaGlsZHJlbkRlZiIsInNrZWxldG9uUGVuZGluZyIsInNrZWxldG9uIiwiYmluZCIsIm5vZGVOYW1lIiwibWVzaFByb21pc2UiLCJmb3JFYWNoIiwibWF0cml4IiwiYXBwbHlNYXRyaXg0IiwicXVhdGVybmlvbiIsImhhcyIsInNjZW5lSW5kZXgiLCJzY2VuZURlZiIsIm5vZGVJZHMiLCJyZWR1Y2VBc3NvY2lhdGlvbnMiLCJyZWR1Y2VkQXNzb2NpYXRpb25zIiwidmFsdWUiLCJub2RlMiIsInRhcmdldE5hbWUiLCJUeXBlZEtleWZyYW1lVHJhY2siLCJpbnRlcnBvbGF0aW9uIiwib3V0cHV0QXJyYXkiLCJfZ2V0QXJyYXlGcm9tQWNjZXNzb3IiLCJqIiwiamwiLCJ0cmFjayIsIl9jcmVhdGVDdWJpY1NwbGluZVRyYWNrSW50ZXJwb2xhbnQiLCJzY2FsZWQiLCJjcmVhdGVJbnRlcnBvbGFudCIsIkludGVycG9sYW50RmFjdG9yeU1ldGhvZEdMVEZDdWJpY1NwbGluZSIsImludGVycG9sYW50VHlwZSIsInRpbWVzIiwiZ2V0VmFsdWVTaXplIiwiaXNJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RHTFRGQ3ViaWNTcGxpbmUiLCJjb21wdXRlQm91bmRzIiwiYm94IiwibWluIiwibWF4IiwiYm94U2NhbGUiLCJtdWx0aXBseVNjYWxhciIsIm1heERpc3BsYWNlbWVudCIsInZlY3RvciIsImFicyIsImV4cGFuZEJ5VmVjdG9yIiwiYm91bmRpbmdCb3giLCJzcGhlcmUiLCJnZXRDZW50ZXIiLCJjZW50ZXIiLCJyYWRpdXMiLCJkaXN0YW5jZVRvIiwiYm91bmRpbmdTcGhlcmUiLCJhc3NpZ25BdHRyaWJ1dGVBY2Nlc3NvciIsImdsdGZBdHRyaWJ1dGVOYW1lIiwiYWNjZXNzb3IyIiwic2V0SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n            const scanline_width = w2;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w2 * h2);\n            if (!data_rgba.length) {\n                rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h2;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                }\n                data = floatArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                }\n                data = halfArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RjtBQUM3RixNQUFNSyxtQkFBbUJMLG9EQUFpQkE7SUFDeENNLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdQLGdEQUFhQTtJQUMzQjtJQUNBLDhEQUE4RDtJQUM5RFEsTUFBTUMsTUFBTSxFQUFFO1FBQ1osTUFBTUMsa0JBQWtCLEdBQUdDLG1CQUFtQixHQUFHQyxvQkFBb0IsR0FBR0Msb0JBQW9CLEdBQUdDLGFBQWEsU0FBU0MsZUFBZSxFQUFFQyxHQUFHO1lBQ3ZJLE9BQVFEO2dCQUNOLEtBQUtMO29CQUNILE1BQU0sSUFBSU8sTUFBTSxtQ0FBb0NELENBQUFBLE9BQU8sRUFBQztnQkFDOUQsS0FBS0w7b0JBQ0gsTUFBTSxJQUFJTSxNQUFNLG9DQUFxQ0QsQ0FBQUEsT0FBTyxFQUFDO2dCQUMvRCxLQUFLSjtvQkFDSCxNQUFNLElBQUlLLE1BQU0sd0NBQXlDRCxDQUFBQSxPQUFPLEVBQUM7Z0JBQ25FO2dCQUNBLEtBQUtIO29CQUNILE1BQU0sSUFBSUksTUFBTSxxQ0FBc0NELENBQUFBLE9BQU8sRUFBQztZQUNsRTtRQUNGLEdBQUdFLHlCQUF5QixHQUFHQyxvQkFBb0IsR0FBR0Msd0JBQXdCLEdBQUdDLFVBQVUsTUFBTUMsUUFBUSxTQUFTQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsT0FBTztZQUMzSSxNQUFNQyxZQUFZO1lBQ2xCRixZQUFZLENBQUNBLFlBQVksT0FBT0E7WUFDaEMsSUFBSUcsSUFBSUosUUFBUUssR0FBRyxFQUFFQyxJQUFJLENBQUMsR0FBR0MsTUFBTSxHQUFHQyxJQUFJLElBQUlDLFFBQVFDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0sSUFBSUMsWUFBWWIsUUFBUWMsUUFBUSxDQUFDVixHQUFHQSxJQUFJRDtZQUM5SCxNQUFP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QUNBLE9BQU87WUFDTGlELE9BQU91QztZQUNQdEMsUUFBUXVDO1lBQ1JFO1lBQ0FsRCxRQUFROEMsaUJBQWlCNUMsTUFBTTtZQUMvQkksT0FBT3dDLGlCQUFpQnhDLEtBQUs7WUFDN0JDLFVBQVV1QyxpQkFBaUJ2QyxRQUFRO1lBQ25DaEQ7UUFDRjtJQUNGO0lBQ0FpRyxZQUFZQyxLQUFLLEVBQUU7UUFDakIsSUFBSSxDQUFDbEcsSUFBSSxHQUFHa0c7UUFDWixPQUFPLElBQUk7SUFDYjtJQUNBQyxLQUFLQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUU7UUFDckMsU0FBU0MsZUFBZUMsT0FBTyxFQUFFQyxPQUFPO1lBQ3RDLE9BQVFELFFBQVF6RyxJQUFJO2dCQUNsQixLQUFLTiw0Q0FBU0E7Z0JBQ2QsS0FBS0QsZ0RBQWFBO29CQUNoQixJQUFJLGdCQUFnQmdILFNBQ2xCQSxRQUFRRSxVQUFVLEdBQUc7eUJBRXJCRixRQUFRRyxRQUFRLEdBQUc7b0JBQ3JCSCxRQUFRSSxTQUFTLEdBQUdqSCwrQ0FBWUE7b0JBQ2hDNkcsUUFBUUssU0FBUyxHQUFHbEgsK0NBQVlBO29CQUNoQzZHLFFBQVFNLGVBQWUsR0FBRztvQkFDMUJOLFFBQVFPLEtBQUssR0FBRztvQkFDaEI7WUFDSjtZQUNBLElBQUlYLFFBQ0ZBLE9BQU9JLFNBQVNDO1FBQ3BCO1FBQ0EsT0FBTyxLQUFLLENBQUNQLEtBQUtDLEtBQUtJLGdCQUFnQkYsWUFBWUM7SUFDckQ7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvbG9hZGVycy9SR0JFTG9hZGVyLmpzPzdhYjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVRleHR1cmVMb2FkZXIsIEhhbGZGbG9hdFR5cGUsIEZsb2F0VHlwZSwgRGF0YVV0aWxzLCBMaW5lYXJGaWx0ZXIgfSBmcm9tIFwidGhyZWVcIjtcbmNsYXNzIFJHQkVMb2FkZXIgZXh0ZW5kcyBEYXRhVGV4dHVyZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIpIHtcbiAgICBzdXBlcihtYW5hZ2VyKTtcbiAgICB0aGlzLnR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICB9XG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LmdyYXBoaWNzLmNvcm5lbGwuZWR1L35iancvcmdiZS5odG1sXG4gIHBhcnNlKGJ1ZmZlcikge1xuICAgIGNvbnN0IHJnYmVfcmVhZF9lcnJvciA9IDEsIHJnYmVfd3JpdGVfZXJyb3IgPSAyLCByZ2JlX2Zvcm1hdF9lcnJvciA9IDMsIHJnYmVfbWVtb3J5X2Vycm9yID0gNCwgcmdiZV9lcnJvciA9IGZ1bmN0aW9uKHJnYmVfZXJyb3JfY29kZSwgbXNnKSB7XG4gICAgICBzd2l0Y2ggKHJnYmVfZXJyb3JfY29kZSkge1xuICAgICAgICBjYXNlIHJnYmVfcmVhZF9lcnJvcjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiBSZWFkIEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICBjYXNlIHJnYmVfd3JpdGVfZXJyb3I6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogV3JpdGUgRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICAgIGNhc2UgcmdiZV9mb3JtYXRfZXJyb3I6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogQmFkIEZpbGUgRm9ybWF0OiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlIHJnYmVfbWVtb3J5X2Vycm9yOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IE1lbW9yeSBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgIH1cbiAgICB9LCBSR0JFX1ZBTElEX1BST0dSQU1UWVBFID0gMSwgUkdCRV9WQUxJRF9GT1JNQVQgPSAyLCBSR0JFX1ZBTElEX0RJTUVOU0lPTlMgPSA0LCBORVdMSU5FID0gXCJcXG5cIiwgZmdldHMgPSBmdW5jdGlvbihidWZmZXIyLCBsaW5lTGltaXQsIGNvbnN1bWUpIHtcbiAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IDEyODtcbiAgICAgIGxpbmVMaW1pdCA9ICFsaW5lTGltaXQgPyAxMDI0IDogbGluZUxpbWl0O1xuICAgICAgbGV0IHAgPSBidWZmZXIyLnBvcywgaSA9IC0xLCBsZW4gPSAwLCBzID0gXCJcIiwgY2h1bmsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShidWZmZXIyLnN1YmFycmF5KHAsIHAgKyBjaHVua1NpemUpKSk7XG4gICAgICB3aGlsZSAoMCA+IChpID0gY2h1bmsuaW5kZXhPZihORVdMSU5FKSkgJiYgbGVuIDwgbGluZUxpbWl0ICYmIHAgPCBidWZmZXIyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcyArPSBjaHVuaztcbiAgICAgICAgbGVuICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgcCArPSBjaHVua1NpemU7XG4gICAgICAgIGNodW5rICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcjIuc3ViYXJyYXkocCwgcCArIGNodW5rU2l6ZSkpKTtcbiAgICAgIH1cbiAgICAgIGlmICgtMSA8IGkpIHtcbiAgICAgICAgaWYgKGZhbHNlICE9PSBjb25zdW1lKVxuICAgICAgICAgIGJ1ZmZlcjIucG9zICs9IGxlbiArIGkgKyAxO1xuICAgICAgICByZXR1cm4gcyArIGNodW5rLnNsaWNlKDAsIGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFJHQkVfUmVhZEhlYWRlciA9IGZ1bmN0aW9uKGJ1ZmZlcjIpIHtcbiAgICAgIGNvbnN0IG1hZ2ljX3Rva2VuX3JlID0gL14jXFw/KFxcUyspLywgZ2FtbWFfcmUgPSAvXlxccypHQU1NQVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8sIGV4cG9zdXJlX3JlID0gL15cXHMqRVhQT1NVUkVcXHMqPVxccyooXFxkKyhcXC5cXGQrKT8pXFxzKiQvLCBmb3JtYXRfcmUgPSAvXlxccypGT1JNQVQ9KFxcUyspXFxzKiQvLCBkaW1lbnNpb25zX3JlID0gL15cXHMqXFwtWVxccysoXFxkKylcXHMrXFwrWFxccysoXFxkKylcXHMqJC8sIGhlYWRlciA9IHtcbiAgICAgICAgdmFsaWQ6IDAsXG4gICAgICAgIHN0cmluZzogXCJcIixcbiAgICAgICAgY29tbWVudHM6IFwiXCIsXG4gICAgICAgIHByb2dyYW10eXBlOiBcIlJHQkVcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBnYW1tYTogMSxcbiAgICAgICAgZXhwb3N1cmU6IDEsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH07XG4gICAgICBsZXQgbGluZSwgbWF0Y2g7XG4gICAgICBpZiAoYnVmZmVyMi5wb3MgPj0gYnVmZmVyMi5ieXRlTGVuZ3RoIHx8ICEobGluZSA9IGZnZXRzKGJ1ZmZlcjIpKSkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfcmVhZF9lcnJvciwgXCJubyBoZWFkZXIgZm91bmRcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShtYXRjaCA9IGxpbmUubWF0Y2gobWFnaWNfdG9rZW5fcmUpKSkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcImJhZCBpbml0aWFsIHRva2VuXCIpO1xuICAgICAgfVxuICAgICAgaGVhZGVyLnZhbGlkIHw9IFJHQkVfVkFMSURfUFJPR1JBTVRZUEU7XG4gICAgICBoZWFkZXIucHJvZ3JhbXR5cGUgPSBtYXRjaFsxXTtcbiAgICAgIGhlYWRlci5zdHJpbmcgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsaW5lID0gZmdldHMoYnVmZmVyMik7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gbGluZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaGVhZGVyLnN0cmluZyArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgICAgaWYgKFwiI1wiID09PSBsaW5lLmNoYXJBdCgwKSkge1xuICAgICAgICAgIGhlYWRlci5jb21tZW50cyArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGdhbW1hX3JlKSkge1xuICAgICAgICAgIGhlYWRlci5nYW1tYSA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZXhwb3N1cmVfcmUpKSB7XG4gICAgICAgICAgaGVhZGVyLmV4cG9zdXJlID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChmb3JtYXRfcmUpKSB7XG4gICAgICAgICAgaGVhZGVyLnZhbGlkIHw9IFJHQkVfVkFMSURfRk9STUFUO1xuICAgICAgICAgIGhlYWRlci5mb3JtYXQgPSBtYXRjaFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGRpbWVuc2lvbnNfcmUpKSB7XG4gICAgICAgICAgaGVhZGVyLnZhbGlkIHw9IFJHQkVfVkFMSURfRElNRU5TSU9OUztcbiAgICAgICAgICBoZWFkZXIuaGVpZ2h0ID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICBoZWFkZXIud2lkdGggPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0ZPUk1BVCAmJiBoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0RJTUVOU0lPTlMpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoIShoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0ZPUk1BVCkpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJtaXNzaW5nIGZvcm1hdCBzcGVjaWZpZXJcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShoZWFkZXIudmFsaWQgJiBSR0JFX1ZBTElEX0RJTUVOU0lPTlMpKSB7XG4gICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwibWlzc2luZyBpbWFnZSBzaXplIHNwZWNpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZWFkZXI7XG4gICAgfSwgUkdCRV9SZWFkUGl4ZWxzX1JMRSA9IGZ1bmN0aW9uKGJ1ZmZlcjIsIHcyLCBoMikge1xuICAgICAgY29uc3Qgc2NhbmxpbmVfd2lkdGggPSB3MjtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gcnVuIGxlbmd0aCBlbmNvZGluZyBpcyBub3QgYWxsb3dlZCBzbyByZWFkIGZsYXRcbiAgICAgICAgc2NhbmxpbmVfd2lkdGggPCA4IHx8IHNjYW5saW5lX3dpZHRoID4gMzI3NjcgfHwgLy8gdGhpcyBmaWxlIGlzIG5vdCBydW4gbGVuZ3RoIGVuY29kZWRcbiAgICAgICAgMiAhPT0gYnVmZmVyMlswXSB8fCAyICE9PSBidWZmZXIyWzFdIHx8IGJ1ZmZlcjJbMl0gJiAxMjhcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMik7XG4gICAgICB9XG4gICAgICBpZiAoc2NhbmxpbmVfd2lkdGggIT09IChidWZmZXIyWzJdIDw8IDggfCBidWZmZXIyWzNdKSkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIndyb25nIHNjYW5saW5lIHdpZHRoXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0YV9yZ2JhID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHcyICogaDIpO1xuICAgICAgaWYgKCFkYXRhX3JnYmEubGVuZ3RoKSB7XG4gICAgICAgIHJnYmVfZXJyb3IocmdiZV9tZW1vcnlfZXJyb3IsIFwidW5hYmxlIHRvIGFsbG9jYXRlIGJ1ZmZlciBzcGFjZVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBvZmZzZXQgPSAwLCBwb3MgPSAwO1xuICAgICAgY29uc3QgcHRyX2VuZCA9IDQgKiBzY2FubGluZV93aWR0aDtcbiAgICAgIGNvbnN0IHJnYmVTdGFydCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgY29uc3Qgc2NhbmxpbmVfYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocHRyX2VuZCk7XG4gICAgICBsZXQgbnVtX3NjYW5saW5lcyA9IGgyO1xuICAgICAgd2hpbGUgKG51bV9zY2FubGluZXMgPiAwICYmIHBvcyA8IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBpZiAocG9zICsgNCA+IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9yZWFkX2Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZ2JlU3RhcnRbMF0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzFdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFsyXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbM10gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgaWYgKDIgIT0gcmdiZVN0YXJ0WzBdIHx8IDIgIT0gcmdiZVN0YXJ0WzFdIHx8IChyZ2JlU3RhcnRbMl0gPDwgOCB8IHJnYmVTdGFydFszXSkgIT0gc2NhbmxpbmVfd2lkdGgpIHtcbiAgICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcImJhZCByZ2JlIHNjYW5saW5lIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHRyID0gMCwgY291bnQ7XG4gICAgICAgIHdoaWxlIChwdHIgPCBwdHJfZW5kICYmIHBvcyA8IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIGNvdW50ID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgICAgY29uc3QgaXNFbmNvZGVkUnVuID0gY291bnQgPiAxMjg7XG4gICAgICAgICAgaWYgKGlzRW5jb2RlZFJ1bilcbiAgICAgICAgICAgIGNvdW50IC09IDEyODtcbiAgICAgICAgICBpZiAoMCA9PT0gY291bnQgfHwgcHRyICsgY291bnQgPiBwdHJfZW5kKSB7XG4gICAgICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcImJhZCBzY2FubGluZSBkYXRhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKSB7XG4gICAgICAgICAgICBjb25zdCBieXRlVmFsdWUgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBzY2FubGluZV9idWZmZXJbcHRyKytdID0gYnl0ZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FubGluZV9idWZmZXIuc2V0KGJ1ZmZlcjIuc3ViYXJyYXkocG9zLCBwb3MgKyBjb3VudCksIHB0cik7XG4gICAgICAgICAgICBwdHIgKz0gY291bnQ7XG4gICAgICAgICAgICBwb3MgKz0gY291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGwgPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBsZXQgb2ZmID0gMDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0XSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDFdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgMl0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAzXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBudW1fc2NhbmxpbmVzLS07XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YV9yZ2JhO1xuICAgIH07XG4gICAgY29uc3QgUkdCRUJ5dGVUb1JHQkZsb2F0ID0gZnVuY3Rpb24oc291cmNlQXJyYXksIHNvdXJjZU9mZnNldCwgZGVzdEFycmF5LCBkZXN0T2Zmc2V0KSB7XG4gICAgICBjb25zdCBlID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgM107XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIGUgLSAxMjgpIC8gMjU1O1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAwXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDBdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDFdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAyXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAzXSA9IDE7XG4gICAgfTtcbiAgICBjb25zdCBSR0JFQnl0ZVRvUkdCSGFsZiA9IGZ1bmN0aW9uKHNvdXJjZUFycmF5LCBzb3VyY2VPZmZzZXQsIGRlc3RBcnJheSwgZGVzdE9mZnNldCkge1xuICAgICAgY29uc3QgZSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDNdO1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLnBvdygyLCBlIC0gMTI4KSAvIDI1NTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMF0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMV0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMV0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMl0gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoTWF0aC5taW4oc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMl0gKiBzY2FsZSwgNjU1MDQpKTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgM10gPSBEYXRhVXRpbHMudG9IYWxmRmxvYXQoMSk7XG4gICAgfTtcbiAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGJ5dGVBcnJheS5wb3MgPSAwO1xuICAgIGNvbnN0IHJnYmVfaGVhZGVyX2luZm8gPSBSR0JFX1JlYWRIZWFkZXIoYnl0ZUFycmF5KTtcbiAgICBjb25zdCB3ID0gcmdiZV9oZWFkZXJfaW5mby53aWR0aCwgaCA9IHJnYmVfaGVhZGVyX2luZm8uaGVpZ2h0LCBpbWFnZV9yZ2JhX2RhdGEgPSBSR0JFX1JlYWRQaXhlbHNfUkxFKGJ5dGVBcnJheS5zdWJhcnJheShieXRlQXJyYXkucG9zKSwgdywgaCk7XG4gICAgbGV0IGRhdGEsIHR5cGU7XG4gICAgbGV0IG51bUVsZW1lbnRzO1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgbnVtRWxlbWVudHMgPSBpbWFnZV9yZ2JhX2RhdGEubGVuZ3RoIC8gNDtcbiAgICAgICAgY29uc3QgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkobnVtRWxlbWVudHMgKiA0KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1FbGVtZW50czsgaisrKSB7XG4gICAgICAgICAgUkdCRUJ5dGVUb1JHQkZsb2F0KGltYWdlX3JnYmFfZGF0YSwgaiAqIDQsIGZsb2F0QXJyYXksIGogKiA0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gZmxvYXRBcnJheTtcbiAgICAgICAgdHlwZSA9IEZsb2F0VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgIG51bUVsZW1lbnRzID0gaW1hZ2VfcmdiYV9kYXRhLmxlbmd0aCAvIDQ7XG4gICAgICAgIGNvbnN0IGhhbGZBcnJheSA9IG5ldyBVaW50MTZBcnJheShudW1FbGVtZW50cyAqIDQpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyBqKyspIHtcbiAgICAgICAgICBSR0JFQnl0ZVRvUkdCSGFsZihpbWFnZV9yZ2JhX2RhdGEsIGogKiA0LCBoYWxmQXJyYXksIGogKiA0KTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gaGFsZkFycmF5O1xuICAgICAgICB0eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiBVbnN1cHBvcnRlZCB0eXBlOiBcIiArIHRoaXMudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdyxcbiAgICAgIGhlaWdodDogaCxcbiAgICAgIGRhdGEsXG4gICAgICBoZWFkZXI6IHJnYmVfaGVhZGVyX2luZm8uc3RyaW5nLFxuICAgICAgZ2FtbWE6IHJnYmVfaGVhZGVyX2luZm8uZ2FtbWEsXG4gICAgICBleHBvc3VyZTogcmdiZV9oZWFkZXJfaW5mby5leHBvc3VyZSxcbiAgICAgIHR5cGVcbiAgICB9O1xuICB9XG4gIHNldERhdGFUeXBlKHZhbHVlKSB7XG4gICAgdGhpcy50eXBlID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbG9hZCh1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgIGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHRleHR1cmUsIHRleERhdGEpIHtcbiAgICAgIHN3aXRjaCAodGV4dHVyZS50eXBlKSB7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICBjYXNlIEhhbGZGbG9hdFR5cGU6XG4gICAgICAgICAgaWYgKFwiY29sb3JTcGFjZVwiIGluIHRleHR1cmUpXG4gICAgICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBcInNyZ2ItbGluZWFyXCI7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGV4dHVyZS5lbmNvZGluZyA9IDNlMztcbiAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgICAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IExpbmVhckZpbHRlcjtcbiAgICAgICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgICAgIHRleHR1cmUuZmxpcFkgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG9uTG9hZClcbiAgICAgICAgb25Mb2FkKHRleHR1cmUsIHRleERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubG9hZCh1cmwsIG9uTG9hZENhbGxiYWNrLCBvblByb2dyZXNzLCBvbkVycm9yKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgUkdCRUxvYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJHQkVMb2FkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiRGF0YVRleHR1cmVMb2FkZXIiLCJIYWxmRmxvYXRUeXBlIiwiRmxvYXRUeXBlIiwiRGF0YVV0aWxzIiwiTGluZWFyRmlsdGVyIiwiUkdCRUxvYWRlciIsImNvbnN0cnVjdG9yIiwibWFuYWdlciIsInR5cGUiLCJwYXJzZSIsImJ1ZmZlciIsInJnYmVfcmVhZF9lcnJvciIsInJnYmVfd3JpdGVfZXJyb3IiLCJyZ2JlX2Zvcm1hdF9lcnJvciIsInJnYmVfbWVtb3J5X2Vycm9yIiwicmdiZV9lcnJvciIsInJnYmVfZXJyb3JfY29kZSIsIm1zZyIsIkVycm9yIiwiUkdCRV9WQUxJRF9QUk9HUkFNVFlQRSIsIlJHQkVfVkFMSURfRk9STUFUIiwiUkdCRV9WQUxJRF9ESU1FTlNJT05TIiwiTkVXTElORSIsImZnZXRzIiwiYnVmZmVyMiIsImxpbmVMaW1pdCIsImNvbnN1bWUiLCJjaHVua1NpemUiLCJwIiwicG9zIiwiaSIsImxlbiIsInMiLCJjaHVuayIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiVWludDE2QXJyYXkiLCJzdWJhcnJheSIsImluZGV4T2YiLCJieXRlTGVuZ3RoIiwibGVuZ3RoIiwic2xpY2UiLCJSR0JFX1JlYWRIZWFkZXIiLCJtYWdpY190b2tlbl9yZSIsImdhbW1hX3JlIiwiZXhwb3N1cmVfcmUiLCJmb3JtYXRfcmUiLCJkaW1lbnNpb25zX3JlIiwiaGVhZGVyIiwidmFsaWQiLCJzdHJpbmciLCJjb21tZW50cyIsInByb2dyYW10eXBlIiwiZm9ybWF0IiwiZ2FtbWEiLCJleHBvc3VyZSIsIndpZHRoIiwiaGVpZ2h0IiwibGluZSIsIm1hdGNoIiwiY2hhckF0IiwicGFyc2VGbG9hdCIsInBhcnNlSW50IiwiUkdCRV9SZWFkUGl4ZWxzX1JMRSIsIncyIiwiaDIiLCJzY2FubGluZV93aWR0aCIsIlVpbnQ4QXJyYXkiLCJkYXRhX3JnYmEiLCJvZmZzZXQiLCJwdHJfZW5kIiwicmdiZVN0YXJ0Iiwic2NhbmxpbmVfYnVmZmVyIiwibnVtX3NjYW5saW5lcyIsInB0ciIsImNvdW50IiwiaXNFbmNvZGVkUnVuIiwiYnl0ZVZhbHVlIiwic2V0IiwibCIsIm9mZiIsIlJHQkVCeXRlVG9SR0JGbG9hdCIsInNvdXJjZUFycmF5Iiwic291cmNlT2Zmc2V0IiwiZGVzdEFycmF5IiwiZGVzdE9mZnNldCIsImUiLCJzY2FsZSIsIk1hdGgiLCJwb3ciLCJSR0JFQnl0ZVRvUkdCSGFsZiIsInRvSGFsZkZsb2F0IiwibWluIiwiYnl0ZUFycmF5IiwicmdiZV9oZWFkZXJfaW5mbyIsInciLCJoIiwiaW1hZ2VfcmdiYV9kYXRhIiwiZGF0YSIsIm51bUVsZW1lbnRzIiwiZmxvYXRBcnJheSIsIkZsb2F0MzJBcnJheSIsImoiLCJoYWxmQXJyYXkiLCJzZXREYXRhVHlwZSIsInZhbHVlIiwibG9hZCIsInVybCIsIm9uTG9hZCIsIm9uUHJvZ3Jlc3MiLCJvbkVycm9yIiwib25Mb2FkQ2FsbGJhY2siLCJ0ZXh0dXJlIiwidGV4RGF0YSIsImNvbG9yU3BhY2UiLCJlbmNvZGluZyIsIm1pbkZpbHRlciIsIm1hZ0ZpbHRlciIsImdlbmVyYXRlTWlwbWFwcyIsImZsaXBZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCompress: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncDecompress: () => (/* binding */ AsyncDecompress),\n/* harmony export */   AsyncDeflate: () => (/* binding */ AsyncDeflate),\n/* harmony export */   AsyncGunzip: () => (/* binding */ AsyncGunzip),\n/* harmony export */   AsyncGzip: () => (/* binding */ AsyncGzip),\n/* harmony export */   AsyncInflate: () => (/* binding */ AsyncInflate),\n/* harmony export */   AsyncUnzipInflate: () => (/* binding */ AsyncUnzipInflate),\n/* harmony export */   AsyncUnzlib: () => (/* binding */ AsyncUnzlib),\n/* harmony export */   AsyncZipDeflate: () => (/* binding */ AsyncZipDeflate),\n/* harmony export */   AsyncZlib: () => (/* binding */ AsyncZlib),\n/* harmony export */   Compress: () => (/* binding */ Gzip),\n/* harmony export */   DecodeUTF8: () => (/* binding */ DecodeUTF8),\n/* harmony export */   Decompress: () => (/* binding */ Decompress),\n/* harmony export */   Deflate: () => (/* binding */ Deflate),\n/* harmony export */   EncodeUTF8: () => (/* binding */ EncodeUTF8),\n/* harmony export */   Gunzip: () => (/* binding */ Gunzip),\n/* harmony export */   Gzip: () => (/* binding */ Gzip),\n/* harmony export */   Inflate: () => (/* binding */ Inflate),\n/* harmony export */   Unzip: () => (/* binding */ Unzip),\n/* harmony export */   UnzipInflate: () => (/* binding */ UnzipInflate),\n/* harmony export */   UnzipPassThrough: () => (/* binding */ UnzipPassThrough),\n/* harmony export */   Unzlib: () => (/* binding */ Unzlib),\n/* harmony export */   Zip: () => (/* binding */ Zip),\n/* harmony export */   ZipDeflate: () => (/* binding */ ZipDeflate),\n/* harmony export */   ZipPassThrough: () => (/* binding */ ZipPassThrough),\n/* harmony export */   Zlib: () => (/* binding */ Zlib),\n/* harmony export */   compress: () => (/* binding */ gzip),\n/* harmony export */   compressSync: () => (/* binding */ gzipSync),\n/* harmony export */   decompress: () => (/* binding */ decompress),\n/* harmony export */   decompressSync: () => (/* binding */ decompressSync),\n/* harmony export */   deflate: () => (/* binding */ deflate),\n/* harmony export */   deflateSync: () => (/* binding */ deflateSync),\n/* harmony export */   gunzip: () => (/* binding */ gunzip),\n/* harmony export */   gunzipSync: () => (/* binding */ gunzipSync),\n/* harmony export */   gzip: () => (/* binding */ gzip),\n/* harmony export */   gzipSync: () => (/* binding */ gzipSync),\n/* harmony export */   inflate: () => (/* binding */ inflate),\n/* harmony export */   inflateSync: () => (/* binding */ inflateSync),\n/* harmony export */   strFromU8: () => (/* binding */ strFromU8),\n/* harmony export */   strToU8: () => (/* binding */ strToU8),\n/* harmony export */   unzip: () => (/* binding */ unzip),\n/* harmony export */   unzipSync: () => (/* binding */ unzipSync),\n/* harmony export */   unzlib: () => (/* binding */ unzlib),\n/* harmony export */   unzlibSync: () => (/* binding */ unzlibSync),\n/* harmony export */   zip: () => (/* binding */ zip),\n/* harmony export */   zipSync: () => (/* binding */ zipSync),\n/* harmony export */   zlib: () => (/* binding */ zlib),\n/* harmony export */   zlibSync: () => (/* binding */ zlibSync)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n\nvar require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"/\");\n// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\n// Mediocre shim\nvar Worker;\nvar workerAdd = \";var __w=require('worker_threads');__w.parentPort.on('message',function(m){onmessage({data:m})}),postMessage=function(m,t){__w.parentPort.postMessage(m,t)},close=process.exit;self=global\";\ntry {\n    Worker = require(\"worker_threads\").Worker;\n} catch (e) {}\nvar wk = Worker ? function(c, _, msg, transfer, cb) {\n    var done = false;\n    var w = new Worker(c + workerAdd, {\n        eval: true\n    }).on(\"error\", function(e) {\n        return cb(e, null);\n    }).on(\"message\", function(m) {\n        return cb(null, m);\n    }).on(\"exit\", function(c) {\n        if (c && !done) cb(new Error(\"exited with code \" + c), null);\n    });\n    w.postMessage(msg, transfer);\n    w.terminate = function() {\n        done = true;\n        return Worker.prototype.terminate.call(w);\n    };\n    return w;\n} : function(_, __, ___, ____, cb) {\n    setImmediate(function() {\n        return cb(new Error(\"async operations unsupported - update to Node 12+ (or Node 10-11 with the --experimental-worker CLI flag)\"), null);\n    });\n    var NOP = function() {};\n    return {\n        terminate: NOP,\n        postMessage: NOP\n    };\n};\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */ 0,\n    0,\n    /* impossible */ 0\n]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */ 0,\n    0\n]);\n// code length index map\nvar clim = new u8([\n    16,\n    17,\n    18,\n    0,\n    8,\n    7,\n    9,\n    6,\n    10,\n    5,\n    11,\n    4,\n    12,\n    3,\n    13,\n    2,\n    14,\n    1,\n    15\n]);\n// get base, reverse index map from extra bits\nvar freb = function(eb, start) {\n    var b = new u16(31);\n    for(var i = 0; i < 31; ++i){\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for(var i = 1; i < 30; ++i){\n        for(var j = b[i]; j < b[i + 1]; ++j){\n            r[j] = j - b[i] << 5 | i;\n        }\n    }\n    return [\n        b,\n        r\n    ];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor(var i = 0; i < 32768; ++i){\n    // reverse table algorithm from SO\n    var x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;\n    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;\n    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;\n    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = function(cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for(; i < s; ++i)++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for(i = 0; i < mb; ++i){\n        le[i] = le[i - 1] + l[i - 1] << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for(i = 0; i < s; ++i){\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = i << 4 | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for(var m = v | (1 << r_1) - 1; v <= m; ++v){\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    } else {\n        co = new u16(s);\n        for(i = 0; i < s; ++i){\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];\n            }\n        }\n    }\n    return co;\n};\n// fixed length tree\nvar flt = new u8(288);\nfor(var i = 0; i < 144; ++i)flt[i] = 8;\nfor(var i = 144; i < 256; ++i)flt[i] = 9;\nfor(var i = 256; i < 280; ++i)flt[i] = 7;\nfor(var i = 280; i < 288; ++i)flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor(var i = 0; i < 32; ++i)fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function(a) {\n    var m = a[0];\n    for(var i = 1; i < a.length; ++i){\n        if (a[i] > m) m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\n// get end of byte\nvar shft = function(p) {\n    return (p / 8 | 0) + (p & 7 && 1);\n};\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function(v, s, e) {\n    if (s == null || s < 0) s = 0;\n    if (e == null || e > v.length) e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function(dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || st && !st.l && sl < 5) return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st) st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf) buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function(l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n                if (t > sl) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                // ensure size\n                if (noBuf) cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for(var i = 0; i < hcLen; ++i){\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for(var i = 0; i < tl;){\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    } else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;\n                        while(n--)ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            } else throw \"invalid block type\";\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf) cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for(;; lpos = pos){\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt) throw \"unexpected EOF\";\n                break;\n            }\n            if (!c) throw \"invalid length/literal\";\n            if (sym < 256) buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            } else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d) throw \"invalid distance\";\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt) throw \"unexpected EOF\";\n                    break;\n                }\n                if (noBuf) cbuf(bt + 131072);\n                var end = bt + add;\n                for(; bt < end; bt += 4){\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    }while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function(d, p, v) {\n    v <<= p & 7;\n    var o = p / 8 | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function(d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for(var i = 0; i < d.length; ++i){\n        if (d[i]) t.push({\n            s: i,\n            f: d[i]\n        });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s) return [\n        et,\n        0\n    ];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [\n            v,\n            1\n        ];\n    }\n    t.sort(function(a, b) {\n        return a.f - b.f;\n    });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({\n        s: -1,\n        f: 25001\n    });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = {\n        s: -1,\n        f: l.f + r.f,\n        l: l,\n        r: r\n    };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while(i1 != s - 1){\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = {\n            s: -1,\n            f: l.f + r.f,\n            l: l,\n            r: r\n        };\n    }\n    var maxSym = t2[0].s;\n    for(var i = 1; i < s; ++i){\n        if (t2[i].s > maxSym) maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function(a, b) {\n            return tr[b.s] - tr[a.s] || a.f - b.f;\n        });\n        for(; i < s; ++i){\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << mbt - tr[i2_1]);\n                tr[i2_1] = mb;\n            } else break;\n        }\n        dt >>>= lft;\n        while(dt > 0){\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;\n            else ++i;\n        }\n        for(; i >= 0 && dt; --i){\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [\n        new u8(tr),\n        mbt\n    ];\n};\n// get the max length and assign length codes\nvar ln = function(n, l, d) {\n    return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;\n};\n// length codes generation\nvar lc = function(c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while(s && !c[--s]);\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function(v) {\n        cl[cli++] = v;\n    };\n    for(var i = 1; i <= s; ++i){\n        if (c[i] == cln && i != s) ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for(; cls > 138; cls -= 138)w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);\n                    cls = 0;\n                }\n            } else if (cls > 3) {\n                w(cln), --cls;\n                for(; cls > 6; cls -= 6)w(8304);\n                if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;\n            }\n            while(cls--)w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [\n        cl.subarray(0, cli),\n        s\n    ];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function(cf, cl) {\n    var l = 0;\n    for(var i = 0; i < cl.length; ++i)l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function(out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for(var i = 0; i < s; ++i)out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for(var i = 0; i < lclt.length; ++i)lcfreq[lclt[i] & 31]++;\n    for(var i = 0; i < lcdt.length; ++i)lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for(; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc);\n    var flen = bl + 5 << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for(var i = 0; i < nlcc; ++i)wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [\n            lclt,\n            lcdt\n        ];\n        for(var it = 0; it < 2; ++it){\n            var clct = lcts[it];\n            for(var i = 0; i < clct.length; ++i){\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;\n            }\n        }\n    } else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for(var i = 0; i < li; ++i){\n        if (syms[i] > 255) {\n            var len = syms[i] >>> 18 & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];\n        } else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([\n    65540,\n    131080,\n    131088,\n    131104,\n    262176,\n    1048704,\n    1048832,\n    2114560,\n    2117632\n]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function(dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for(var i = 0; i <= s; i += 65535){\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            } else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    } else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function(i) {\n            return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;\n        };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for(; i < s; ++i){\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for(var j = 0; j < 286; ++j)lf[j] = 0;\n                    for(var j = 0; j < 30; ++j)df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while(dif <= maxd && --ch_1 && imod != pimod){\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for(; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl);\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn) break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for(var j = 0; j < mmd; ++j){\n                                    var ti = i - dif + j + 32768 & 32767;\n                                    var pti = prev[ti];\n                                    var cd = ti - pti + 32768 & 32767;\n                                    if (cd > md) md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += imod - pimod + 32768 & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                } else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ function() {\n    var t = new Int32Array(256);\n    for(var i = 0; i < 256; ++i){\n        var c = i, k = 9;\n        while(--k)c = (c & 1 && -306674912) ^ c >>> 1;\n        t[i] = c;\n    }\n    return t;\n}();\n// CRC32\nvar crc = function() {\n    var c = -1;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var cr = c;\n            for(var i = 0; i < d.length; ++i)cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;\n            c = cr;\n        },\n        d: function() {\n            return ~c;\n        }\n    };\n};\n// Alder32\nvar adler = function() {\n    var a = 1, b = 0;\n    return {\n        p: function(d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for(var i = 0; i != l;){\n                var e = Math.min(i + 2655, l);\n                for(; i < e; ++i)m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function() {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function(dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function(a, b) {\n    var o = {};\n    for(var k in a)o[k] = a[k];\n    for(var k in b)o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function(fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf(\"[\") + 1, st.lastIndexOf(\"]\")).replace(/ /g, \"\").split(\",\");\n    for(var i = 0; i < dt.length; ++i){\n        var v = dt[i], k = ks[i];\n        if (typeof v == \"function\") {\n            fnStr += \";\" + k + \"=\";\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf(\"[native code]\") != -1) {\n                    var spInd = st_1.indexOf(\" \", 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf(\"(\", spInd));\n                } else {\n                    fnStr += st_1;\n                    for(var t in v.prototype)fnStr += \";\" + k + \".prototype.\" + t + \"=\" + v.prototype[t].toString();\n                }\n            } else fnStr += st_1;\n        } else td[k] = v;\n    }\n    return [\n        fnStr,\n        td\n    ];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function(v) {\n    var tl = [];\n    for(var k in v){\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function(fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = \"\", td_1 = {}, m = fns.length - 1;\n        for(var i = 0; i < m; ++i)_a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + \";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=\" + init.toString() + \"}\", id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        fl,\n        fd,\n        flrm,\n        fdrm,\n        rev,\n        hMap,\n        max,\n        bits,\n        bits16,\n        shft,\n        slc,\n        inflt,\n        inflateSync,\n        pbf,\n        gu8\n    ];\n};\nvar bDflt = function() {\n    return [\n        u8,\n        u16,\n        u32,\n        fleb,\n        fdeb,\n        clim,\n        revfl,\n        revfd,\n        flm,\n        flt,\n        fdm,\n        fdt,\n        rev,\n        deo,\n        et,\n        hMap,\n        wbits,\n        wbits16,\n        hTree,\n        ln,\n        lc,\n        clen,\n        wfblk,\n        wblk,\n        shft,\n        slc,\n        dflt,\n        dopt,\n        deflateSync,\n        pbf\n    ];\n};\n// gzip extra\nvar gze = function() {\n    return [\n        gzh,\n        gzhl,\n        wbytes,\n        crc,\n        crct\n    ];\n};\n// gunzip extra\nvar guze = function() {\n    return [\n        gzs,\n        gzl\n    ];\n};\n// zlib extra\nvar zle = function() {\n    return [\n        zlh,\n        wbytes,\n        adler\n    ];\n};\n// unzlib extra\nvar zule = function() {\n    return [\n        zlv\n    ];\n};\n// post buf\nvar pbf = function(msg) {\n    return postMessage(msg, [\n        msg.buffer\n    ]);\n};\n// get u8\nvar gu8 = function(o) {\n    return o && o.size && new u8(o.size);\n};\n// async helper\nvar cbify = function(dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function(err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([\n        dat,\n        opts\n    ], opts.consume ? [\n        dat.buffer\n    ] : []);\n    return function() {\n        w.terminate();\n    };\n};\n// auto stream\nvar astrm = function(strm) {\n    strm.ondata = function(dat, final) {\n        return postMessage([\n            dat,\n            final\n        ], [\n            dat.buffer\n        ]);\n    };\n    return function(ev) {\n        return strm.push(ev.data[0], ev.data[1]);\n    };\n};\n// async stream attach\nvar astrmify = function(fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function(err, dat) {\n        if (err) w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1]) w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function(d, f) {\n        if (t) throw \"stream finished\";\n        if (!strm.ondata) throw \"no stream handler\";\n        w.postMessage([\n            d,\n            t = f\n        ], [\n            d.buffer\n        ]);\n    };\n    strm.terminate = function() {\n        w.terminate();\n    };\n};\n// read 2 bytes\nvar b2 = function(d, b) {\n    return d[b] | d[b + 1] << 8;\n};\n// read 4 bytes\nvar b4 = function(d, b) {\n    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;\n};\nvar b8 = function(d, b) {\n    return b4(d, b) + b4(d, b + 4) * 4294967296;\n};\n// write bytes\nvar wbytes = function(d, b, v) {\n    for(; v; ++b)d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function(c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for(var i = 0; i <= fn.length; ++i)c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw \"invalid gzip data\";\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4) st += d[10] | (d[11] << 8) + 2;\n    for(var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]);\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function(d) {\n    var l = d.length;\n    return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\n// gzip header length\nvar gzhl = function(o) {\n    return 10 + (o.filename && o.filename.length + 1 || 0);\n};\n// zlib header\nvar zlh = function(c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);\n};\n// zlib valid\nvar zlv = function(d) {\n    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw \"invalid zlib data\";\n    if (d[1] & 32) throw \"invalid zlib data: preset dictionaries not supported\";\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */ var Deflate = /*#__PURE__*/ function() {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == \"function\") cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function(c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Deflate.prototype.push = function(chunk, final) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression\n */ var AsyncDeflate = /*#__PURE__*/ function() {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function() {\n                return [\n                    astrm,\n                    Deflate\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}();\n\nfunction deflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt\n    ], function(ev) {\n        return pbf(deflateSync(ev.data[0], ev.data[1]));\n    }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */ function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */ var Inflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function(c) {\n        if (this.d) throw \"stream finished\";\n        if (!this.ondata) throw \"no stream handler\";\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function(final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */ Inflate.prototype.push = function(chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression\n */ var AsyncInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function() {\n                return [\n                    astrm,\n                    Inflate\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}();\n\nfunction inflate(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt\n    ], function(ev) {\n        return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));\n    }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */ var Gzip = /*#__PURE__*/ function() {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gzip.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function(c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v) gzh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}();\n\n/**\n * Asynchronous streaming GZIP compression\n */ var AsyncGzip = /*#__PURE__*/ function() {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Gzip\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}();\n\nfunction gzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function() {\n            return [\n                gzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gzipSync(ev.data[0], ev.data[1]));\n    }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */ function gzipSync(data, opts) {\n    if (!opts) opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */ var Gunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Gunzip.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final) return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8) throw \"invalid gzip stream\";\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}();\n\n/**\n * Asynchronous streaming GZIP decompression\n */ var AsyncGunzip = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Gunzip\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}();\n\nfunction gunzip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function() {\n            return [\n                gunzipSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(gunzipSync(ev.data[0]));\n    }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */ function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */ var Zlib = /*#__PURE__*/ function() {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Zlib.prototype.push = function(chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function(c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v) zlh(raw, this.o), this.v = 0;\n        if (f) wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}();\n\n/**\n * Asynchronous streaming Zlib compression\n */ var AsyncZlib = /*#__PURE__*/ function() {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function() {\n                return [\n                    astrm,\n                    Deflate,\n                    Zlib\n                ];\n            }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function(ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}();\n\nfunction zlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function() {\n            return [\n                zlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(zlibSync(ev.data[0], ev.data[1]));\n    }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */ function zlibSync(data, opts) {\n    if (!opts) opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */ var Unzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */ function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzlib.prototype.push = function(chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final) return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4) throw \"invalid zlib stream\";\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}();\n\n/**\n * Asynchronous streaming Zlib decompression\n */ var AsyncUnzlib = /*#__PURE__*/ function() {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */ function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function() {\n                return [\n                    astrm,\n                    Inflate,\n                    Unzlib\n                ];\n            }\n        ], this, 0, function() {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}();\n\nfunction unzlib(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function() {\n            return [\n                unzlibSync\n            ];\n        }\n    ], function(ev) {\n        return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));\n    }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n// Default algorithm for compression (used because having a known output size allows faster decompression)\n\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var Decompress = /*#__PURE__*/ function() {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */ function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Decompress.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no stream handler\";\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            } else this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function() {\n                    _this_1.ondata.apply(_this_1, arguments);\n                };\n                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        } else this.s.push(chunk, final);\n    };\n    return Decompress;\n}();\n\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */ var AsyncDecompress = /*#__PURE__*/ function() {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */ function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncDecompress.prototype.push = function(chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}();\n\nfunction decompress(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */ function decompressSync(data, out) {\n    return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function(d, p, t, o) {\n    for(var k in d){\n        var val = d[k], n = p + k;\n        if (val instanceof u8) t[n] = [\n            val,\n            o\n        ];\n        else if (Array.isArray(val)) t[n] = [\n            val[0],\n            mrg(o, val[1])\n        ];\n        else fltn(val, n + \"/\", t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != \"undefined\" && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != \"undefined\" && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, {\n        stream: true\n    });\n    tds = 1;\n} catch (e) {}\n// decode UTF8\nvar dutf8 = function(d) {\n    for(var r = \"\", i = 0;;){\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length) return [\n            r,\n            slc(d, i - 1)\n        ];\n        if (!eb) r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);\n        } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);\n        else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */ var DecodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */ function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds) this.t = new TextDecoder();\n        else this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ DecodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, {\n                stream: true\n            }), final);\n            if (final) {\n                if (this.t.decode().length) throw \"invalid utf-8 data\";\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p) throw \"stream finished\";\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length) throw \"invalid utf-8 data\";\n            this.p = null;\n        } else this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}();\n\n/**\n * Streaming UTF-8 encoding\n */ var EncodeUTF8 = /*#__PURE__*/ function() {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */ function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */ EncodeUTF8.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback\";\n        if (this.d) throw \"stream finished\";\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}();\n\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */ function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for(var i = 0; i < str.length; ++i)ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te) return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function(v) {\n        ar[ai++] = v;\n    };\n    for(var i = 0; i < l; ++i){\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + (l - i << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1) w(c);\n        else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);\n        else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);\n        else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */ function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = \"\";\n        for(var i = 0; i < dat.length; i += 16384)r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    } else if (td) return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length) throw \"invalid utf-8 data\";\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function(l) {\n    return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;\n};\n// skip local zip header\nvar slzh = function(d, b) {\n    return b + 30 + b2(d, b + 26) + b2(d, b + 28);\n};\n// read zip header\nvar zh = function(d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [\n        bs,\n        b4(d, b + 24),\n        b4(d, b + 42)\n    ], sc = _a[0], su = _a[1], off = _a[2];\n    return [\n        b2(d, b + 10),\n        sc,\n        su,\n        fn,\n        es + b2(d, b + 30) + b2(d, b + 32),\n        off\n    ];\n};\n// read zip64 extra field\nvar z64e = function(d, b) {\n    for(; b2(d, b) != 1; b += 4 + b2(d, b + 2));\n    return [\n        b8(d, b + 12),\n        b8(d, b + 4),\n        b8(d, b + 20)\n    ];\n};\n// extra field length\nvar exfl = function(ex) {\n    var le = 0;\n    if (ex) {\n        for(var k in ex){\n            var l = ex[k].length;\n            if (l > 65535) throw \"extra field too long\";\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function(d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null) d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119) throw \"date not in range 1980-2099\";\n    wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for(var k in ex){\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col) d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function(o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */ var ZipPassThrough = /*#__PURE__*/ function() {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */ function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.process = function(chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipPassThrough.prototype.push = function(chunk, final) {\n        if (!this.ondata) throw \"no callback - add to ZIP archive before pushing\";\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final) this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}();\n\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */ var ZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function(chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        } catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ ZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */ var AsyncZipDeflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */ function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts) opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function(err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function(chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ AsyncZipDeflate.prototype.push = function(chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}();\n\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */ var Zip = /*#__PURE__*/ function() {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */ function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */ Zip.prototype.add = function(file) {\n        var _this_1 = this;\n        if (this.d & 2) throw \"stream finished\";\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || o && com.length != o.length;\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535) throw \"filename too long\";\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [\n            header\n        ];\n        var pAll = function() {\n            for(var _i = 0, chks_1 = chks; _i < chks_1.length; _i++){\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function() {\n                if (file.terminate) file.terminate();\n            },\n            r: function() {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt) nxt.r();\n                    else _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function(err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            } else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr) uf.r();\n                    tr = 1;\n                } else if (tr) pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */ Zip.prototype.end = function() {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1) throw \"stream finishing\";\n            throw \"stream finished\";\n        }\n        if (this.d) this.e();\n        else this.u.push({\n            r: function() {\n                if (!(_this_1.d & 1)) return;\n                _this_1.u.splice(-1, 1);\n                _this_1.e();\n            },\n            t: function() {}\n        });\n        this.d = 3;\n    };\n    Zip.prototype.e = function() {\n        var bt = 0, l = 0, tl = 0;\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for(var _b = 0, _c = this.u; _b < _c.length; _b++){\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */ Zip.prototype.terminate = function() {\n        for(var _i = 0, _a = this.u; _i < _a.length; _i++){\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}();\n\nfunction zip(data, opts, cb) {\n    if (!cb) cb = opts, opts = {};\n    if (typeof cb != \"function\") throw \"no callback\";\n    var r = {};\n    fltn(data, \"\", r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var cbf = function() {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for(var i = 0; i < slft; ++i){\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            } catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft) cbf();\n    var _loop_1 = function(i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || m && com.length != ms,\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft) cbf();\n            }\n        };\n        if (s > 65535) cbl(\"filename too long\", null);\n        if (!compression) cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            } catch (e) {\n                cbl(e, null);\n            }\n        } else term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for(var i = 0; i < slft; ++i){\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */ function zipSync(data, opts) {\n    if (!opts) opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, \"\", r, opts);\n    var o = 0;\n    var tot = 0;\n    for(var fn in r){\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535) throw \"filename too long\";\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || m && com.length != ms,\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for(var i = 0; i < files.length; ++i){\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */ var UnzipPassThrough = /*#__PURE__*/ function() {\n    function UnzipPassThrough() {}\n    UnzipPassThrough.prototype.push = function(data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}();\n\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */ var UnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function(dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function(data, final) {\n        try {\n            this.i.push(data, final);\n        } catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}();\n\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */ var AsyncUnzipInflate = /*#__PURE__*/ function() {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */ function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function(dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        } else {\n            this.i = new AsyncInflate(function(err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function(data, final) {\n        if (this.i.terminate) data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}();\n\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */ var Unzip = /*#__PURE__*/ function() {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */ function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */ Unzip.prototype.push = function(chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile) throw \"no callback\";\n        if (!this.p) throw \"stream finished\";\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d) this.d.push(toAdd, !this.c);\n            else this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length) return this.push(chunk, final);\n        } else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length) buf = chunk;\n            else if (!chunk.length) buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function() {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [\n                                -2\n                            ] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        } else if (dd) sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function() {\n                                if (!file_1.ondata) throw \"no callback\";\n                                if (!sc_1) file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr) throw \"unknown compression type \" + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function(err, dat, final) {\n                                        file_1.ondata(err, dat, final);\n                                    };\n                                    for(var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++){\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;\n                                    else d_1.push(et, true);\n                                }\n                            },\n                            terminate: function() {\n                                if (d_1 && d_1.terminate) d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                } else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    } else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for(; i < l - 4; ++i){\n                var state_1 = _loop_2();\n                if (state_1 === \"break\") break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add) add.push(dat, !!f);\n                else this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2) return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c) throw \"invalid zip file\";\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */ Unzip.prototype.register = function(decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}();\n\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */ function unzip(data, cb) {\n    if (typeof cb != \"function\") throw \"no callback\";\n    var term = [];\n    var tAll = function() {\n        for(var i = 0; i < term.length; ++i)term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft) cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb(\"invalid zip file\", null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function(i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function(e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            } else {\n                files[fn] = d;\n                if (!--lft) cb(null, files);\n            }\n        };\n        if (!c_1) cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                } catch (e) {\n                    cbl(e, null);\n                }\n            } else term.push(inflate(infl, {\n                size: su\n            }, cbl));\n        } else cbl(\"unknown compression type \" + c_1, null);\n    };\n    for(var i = 0; i < c; ++i){\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */ function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for(; b4(data, e) != 0x6054B50; --e){\n        if (!e || data.length - e > 65558) throw \"invalid zip file\";\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c) return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) throw \"invalid zip file\";\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for(var i = 0; i < c; ++i){\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2) files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else throw \"unknown compression type \" + c_2;\n    }\n    return files;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL25vZGVfbW9kdWxlcy9mZmxhdGUvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ3ZDLElBQUlDLFVBQVVELHFEQUFhQSxDQUFDO0FBQzVCLDJGQUEyRjtBQUMzRixzQ0FBc0M7QUFDdEMsMkVBQTJFO0FBQzNFLHFFQUFxRTtBQUNyRSw0REFBNEQ7QUFDNUQsc0NBQXNDO0FBQ3RDLHVIQUF1SDtBQUN2SCwyRkFBMkY7QUFDM0Ysb0RBQW9EO0FBQ3BELGdCQUFnQjtBQUNoQixJQUFJRTtBQUNKLElBQUlDLFlBQVk7QUFDaEIsSUFBSTtJQUNBRCxTQUFTRCxRQUFRLGtCQUFrQkMsTUFBTTtBQUM3QyxFQUNBLE9BQU9FLEdBQUcsQ0FDVjtBQUNBLElBQUlDLEtBQUtILFNBQVMsU0FBVUksQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEdBQUcsRUFBRUMsUUFBUSxFQUFFQyxFQUFFO0lBQy9DLElBQUlDLE9BQU87SUFDWCxJQUFJQyxJQUFJLElBQUlWLE9BQU9JLElBQUlILFdBQVc7UUFBRVUsTUFBTTtJQUFLLEdBQzFDQyxFQUFFLENBQUMsU0FBUyxTQUFVVixDQUFDO1FBQUksT0FBT00sR0FBR04sR0FBRztJQUFPLEdBQy9DVSxFQUFFLENBQUMsV0FBVyxTQUFVQyxDQUFDO1FBQUksT0FBT0wsR0FBRyxNQUFNSztJQUFJLEdBQ2pERCxFQUFFLENBQUMsUUFBUSxTQUFVUixDQUFDO1FBQ3ZCLElBQUlBLEtBQUssQ0FBQ0ssTUFDTkQsR0FBRyxJQUFJTSxNQUFNLHNCQUFzQlYsSUFBSTtJQUMvQztJQUNBTSxFQUFFSyxXQUFXLENBQUNULEtBQUtDO0lBQ25CRyxFQUFFTSxTQUFTLEdBQUc7UUFDVlAsT0FBTztRQUNQLE9BQU9ULE9BQU9pQixTQUFTLENBQUNELFNBQVMsQ0FBQ0UsSUFBSSxDQUFDUjtJQUMz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UUFDeEIsSUFBSUcsS0FBS3dULEdBQUdsRixNQUFNdk0sR0FBRzBSLElBQUltRyxNQUFNNVosRUFBRSxDQUFDLEVBQUUsRUFBRTZULEtBQUs3VCxFQUFFLENBQUMsRUFBRSxFQUFFOFQsS0FBSzlULEVBQUUsQ0FBQyxFQUFFLEVBQUV3TCxLQUFLeEwsRUFBRSxDQUFDLEVBQUUsRUFBRXlaLEtBQUt6WixFQUFFLENBQUMsRUFBRSxFQUFFK1QsTUFBTS9ULEVBQUUsQ0FBQyxFQUFFLEVBQUVKLElBQUkyVCxLQUFLakYsTUFBTXlGO1FBQ2xIaFMsSUFBSTBYO1FBQ0osSUFBSSxDQUFDRyxLQUNEOUMsS0FBSyxDQUFDdEwsR0FBRyxHQUFHdEosSUFBSW9NLE1BQU0xTyxHQUFHQSxJQUFJaVU7YUFDNUIsSUFBSStGLE9BQU8sR0FDWjlDLEtBQUssQ0FBQ3RMLEdBQUcsR0FBR3FCLFlBQVl5QixLQUFLak0sUUFBUSxDQUFDekMsR0FBR0EsSUFBSWlVLEtBQUssSUFBSTdVLEdBQUc4VTthQUV6RCxNQUFNLDhCQUE4QjhGO0lBQzVDO0lBQ0EsT0FBTzlDO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9ub2RlX21vZHVsZXMvZmZsYXRlL2VzbS9pbmRleC5tanM/Y2M2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbW9kdWxlJztcbnZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZSgnLycpO1xuLy8gREVGTEFURSBpcyBhIGNvbXBsZXggZm9ybWF0OyB0byByZWFkIHRoaXMgY29kZSwgeW91IHNob3VsZCBwcm9iYWJseSBjaGVjayB0aGUgUkZDIGZpcnN0OlxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE5NTFcbi8vIFlvdSBtYXkgYWxzbyB3aXNoIHRvIHRha2UgYSBsb29rIGF0IHRoZSBndWlkZSBJIG1hZGUgYWJvdXQgdGhpcyBwcm9ncmFtOlxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAxYXJyb3d6LzI1M2YzMWViNWFiYzNkOTI3NWFiOTQzMDAzZmZlY2FkXG4vLyBTb21lIG9mIHRoZSBmb2xsb3dpbmcgY29kZSBpcyBzaW1pbGFyIHRvIHRoYXQgb2YgVVpJUC5qczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b3BlYS9VWklQLmpzXG4vLyBIb3dldmVyLCB0aGUgdmFzdCBtYWpvcml0eSBvZiB0aGUgY29kZWJhc2UgaGFzIGRpdmVyZ2VkIGZyb20gVVpJUC5qcyB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZSBhbmQgcmVkdWNlIGJ1bmRsZSBzaXplLlxuLy8gU29tZXRpbWVzIDAgd2lsbCBhcHBlYXIgd2hlcmUgLTEgd291bGQgYmUgbW9yZSBhcHByb3ByaWF0ZS4gVGhpcyBpcyBiZWNhdXNlIHVzaW5nIGEgdWludFxuLy8gaXMgYmV0dGVyIGZvciBtZW1vcnkgaW4gbW9zdCBlbmdpbmVzIChJICp0aGluayopLlxuLy8gTWVkaW9jcmUgc2hpbVxudmFyIFdvcmtlcjtcbnZhciB3b3JrZXJBZGQgPSBcIjt2YXIgX193PXJlcXVpcmUoJ3dvcmtlcl90aHJlYWRzJyk7X193LnBhcmVudFBvcnQub24oJ21lc3NhZ2UnLGZ1bmN0aW9uKG0pe29ubWVzc2FnZSh7ZGF0YTptfSl9KSxwb3N0TWVzc2FnZT1mdW5jdGlvbihtLHQpe19fdy5wYXJlbnRQb3J0LnBvc3RNZXNzYWdlKG0sdCl9LGNsb3NlPXByb2Nlc3MuZXhpdDtzZWxmPWdsb2JhbFwiO1xudHJ5IHtcbiAgICBXb3JrZXIgPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpLldvcmtlcjtcbn1cbmNhdGNoIChlKSB7XG59XG52YXIgd2sgPSBXb3JrZXIgPyBmdW5jdGlvbiAoYywgXywgbXNnLCB0cmFuc2ZlciwgY2IpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHZhciB3ID0gbmV3IFdvcmtlcihjICsgd29ya2VyQWRkLCB7IGV2YWw6IHRydWUgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBjYihlLCBudWxsKTsgfSlcbiAgICAgICAgLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGNiKG51bGwsIG0pOyB9KVxuICAgICAgICAub24oJ2V4aXQnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyAmJiAhZG9uZSlcbiAgICAgICAgICAgIGNiKG5ldyBFcnJvcignZXhpdGVkIHdpdGggY29kZSAnICsgYyksIG51bGwpO1xuICAgIH0pO1xuICAgIHcucG9zdE1lc3NhZ2UobXNnLCB0cmFuc2Zlcik7XG4gICAgdy50ZXJtaW5hdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gV29ya2VyLnByb3RvdHlwZS50ZXJtaW5hdGUuY2FsbCh3KTtcbiAgICB9O1xuICAgIHJldHVybiB3O1xufSA6IGZ1bmN0aW9uIChfLCBfXywgX19fLCBfX19fLCBjYikge1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBjYihuZXcgRXJyb3IoJ2FzeW5jIG9wZXJhdGlvbnMgdW5zdXBwb3J0ZWQgLSB1cGRhdGUgdG8gTm9kZSAxMisgKG9yIE5vZGUgMTAtMTEgd2l0aCB0aGUgLS1leHBlcmltZW50YWwtd29ya2VyIENMSSBmbGFnKScpLCBudWxsKTsgfSk7XG4gICAgdmFyIE5PUCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXJtaW5hdGU6IE5PUCxcbiAgICAgICAgcG9zdE1lc3NhZ2U6IE5PUFxuICAgIH07XG59O1xuXG4vLyBhbGlhc2VzIGZvciBzaG9ydGVyIGNvbXByZXNzZWQgY29kZSAobW9zdCBtaW5pZmVycyBkb24ndCBkbyB0aGlzKVxudmFyIHU4ID0gVWludDhBcnJheSwgdTE2ID0gVWludDE2QXJyYXksIHUzMiA9IFVpbnQzMkFycmF5O1xuLy8gZml4ZWQgbGVuZ3RoIGV4dHJhIGJpdHNcbnZhciBmbGViID0gbmV3IHU4KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCAzLCAzLCAzLCAzLCA0LCA0LCA0LCA0LCA1LCA1LCA1LCA1LCAwLCAvKiB1bnVzZWQgKi8gMCwgMCwgLyogaW1wb3NzaWJsZSAqLyAwXSk7XG4vLyBmaXhlZCBkaXN0YW5jZSBleHRyYSBiaXRzXG4vLyBzZWUgZmxlYiBub3RlXG52YXIgZmRlYiA9IG5ldyB1OChbMCwgMCwgMCwgMCwgMSwgMSwgMiwgMiwgMywgMywgNCwgNCwgNSwgNSwgNiwgNiwgNywgNywgOCwgOCwgOSwgOSwgMTAsIDEwLCAxMSwgMTEsIDEyLCAxMiwgMTMsIDEzLCAvKiB1bnVzZWQgKi8gMCwgMF0pO1xuLy8gY29kZSBsZW5ndGggaW5kZXggbWFwXG52YXIgY2xpbSA9IG5ldyB1OChbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV0pO1xuLy8gZ2V0IGJhc2UsIHJldmVyc2UgaW5kZXggbWFwIGZyb20gZXh0cmEgYml0c1xudmFyIGZyZWIgPSBmdW5jdGlvbiAoZWIsIHN0YXJ0KSB7XG4gICAgdmFyIGIgPSBuZXcgdTE2KDMxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMxOyArK2kpIHtcbiAgICAgICAgYltpXSA9IHN0YXJ0ICs9IDEgPDwgZWJbaSAtIDFdO1xuICAgIH1cbiAgICAvLyBudW1iZXJzIGhlcmUgYXJlIGF0IG1heCAxOCBiaXRzXG4gICAgdmFyIHIgPSBuZXcgdTMyKGJbMzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IDMwOyArK2kpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGJbaV07IGogPCBiW2kgKyAxXTsgKytqKSB7XG4gICAgICAgICAgICByW2pdID0gKChqIC0gYltpXSkgPDwgNSkgfCBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbYiwgcl07XG59O1xudmFyIF9hID0gZnJlYihmbGViLCAyKSwgZmwgPSBfYVswXSwgcmV2ZmwgPSBfYVsxXTtcbi8vIHdlIGNhbiBpZ25vcmUgdGhlIGZhY3QgdGhhdCB0aGUgb3RoZXIgbnVtYmVycyBhcmUgd3Jvbmc7IHRoZXkgbmV2ZXIgaGFwcGVuIGFueXdheVxuZmxbMjhdID0gMjU4LCByZXZmbFsyNThdID0gMjg7XG52YXIgX2IgPSBmcmViKGZkZWIsIDApLCBmZCA9IF9iWzBdLCByZXZmZCA9IF9iWzFdO1xuLy8gbWFwIG9mIHZhbHVlIHRvIHJldmVyc2UgKGFzc3VtaW5nIDE2IGJpdHMpXG52YXIgcmV2ID0gbmV3IHUxNigzMjc2OCk7XG5mb3IgKHZhciBpID0gMDsgaSA8IDMyNzY4OyArK2kpIHtcbiAgICAvLyByZXZlcnNlIHRhYmxlIGFsZ29yaXRobSBmcm9tIFNPXG4gICAgdmFyIHggPSAoKGkgJiAweEFBQUEpID4+PiAxKSB8ICgoaSAmIDB4NTU1NSkgPDwgMSk7XG4gICAgeCA9ICgoeCAmIDB4Q0NDQykgPj4+IDIpIHwgKCh4ICYgMHgzMzMzKSA8PCAyKTtcbiAgICB4ID0gKCh4ICYgMHhGMEYwKSA+Pj4gNCkgfCAoKHggJiAweDBGMEYpIDw8IDQpO1xuICAgIHJldltpXSA9ICgoKHggJiAweEZGMDApID4+PiA4KSB8ICgoeCAmIDB4MDBGRikgPDwgOCkpID4+PiAxO1xufVxuLy8gY3JlYXRlIGh1ZmZtYW4gdHJlZSBmcm9tIHU4IFwibWFwXCI6IGluZGV4IC0+IGNvZGUgbGVuZ3RoIGZvciBjb2RlIGluZGV4XG4vLyBtYiAobWF4IGJpdHMpIG11c3QgYmUgYXQgbW9zdCAxNVxuLy8gVE9ETzogb3B0aW1pemUvc3BsaXQgdXA/XG52YXIgaE1hcCA9IChmdW5jdGlvbiAoY2QsIG1iLCByKSB7XG4gICAgdmFyIHMgPSBjZC5sZW5ndGg7XG4gICAgLy8gaW5kZXhcbiAgICB2YXIgaSA9IDA7XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+ICMgb2YgY29kZXMgd2l0aCBiaXQgbGVuZ3RoID0gaW5kZXhcbiAgICB2YXIgbCA9IG5ldyB1MTYobWIpO1xuICAgIC8vIGxlbmd0aCBvZiBjZCBtdXN0IGJlIDI4OCAodG90YWwgIyBvZiBjb2RlcylcbiAgICBmb3IgKDsgaSA8IHM7ICsraSlcbiAgICAgICAgKytsW2NkW2ldIC0gMV07XG4gICAgLy8gdTE2IFwibWFwXCI6IGluZGV4IC0+IG1pbmltdW0gY29kZSBmb3IgYml0IGxlbmd0aCA9IGluZGV4XG4gICAgdmFyIGxlID0gbmV3IHUxNihtYik7XG4gICAgZm9yIChpID0gMDsgaSA8IG1iOyArK2kpIHtcbiAgICAgICAgbGVbaV0gPSAobGVbaSAtIDFdICsgbFtpIC0gMV0pIDw8IDE7XG4gICAgfVxuICAgIHZhciBjbztcbiAgICBpZiAocikge1xuICAgICAgICAvLyB1MTYgXCJtYXBcIjogaW5kZXggLT4gbnVtYmVyIG9mIGFjdHVhbCBiaXRzLCBzeW1ib2wgZm9yIGNvZGVcbiAgICAgICAgY28gPSBuZXcgdTE2KDEgPDwgbWIpO1xuICAgICAgICAvLyBiaXRzIHRvIHJlbW92ZSBmb3IgcmV2ZXJzZXJcbiAgICAgICAgdmFyIHJ2YiA9IDE1IC0gbWI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSAwIGxlbmd0aHNcbiAgICAgICAgICAgIGlmIChjZFtpXSkge1xuICAgICAgICAgICAgICAgIC8vIG51bSBlbmNvZGluZyBib3RoIHN5bWJvbCBhbmQgYml0cyByZWFkXG4gICAgICAgICAgICAgICAgdmFyIHN2ID0gKGkgPDwgNCkgfCBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBmcmVlIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgcl8xID0gbWIgLSBjZFtpXTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCB2YWx1ZVxuICAgICAgICAgICAgICAgIHZhciB2ID0gbGVbY2RbaV0gLSAxXSsrIDw8IHJfMTtcbiAgICAgICAgICAgICAgICAvLyBtIGlzIGVuZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSB2IHwgKCgxIDw8IHJfMSkgLSAxKTsgdiA8PSBtOyArK3YpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlcnkgMTYgYml0IHZhbHVlIHN0YXJ0aW5nIHdpdGggdGhlIGNvZGUgeWllbGRzIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBjb1tyZXZbdl0gPj4+IHJ2Yl0gPSBzdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvID0gbmV3IHUxNihzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgaWYgKGNkW2ldKSB7XG4gICAgICAgICAgICAgICAgY29baV0gPSByZXZbbGVbY2RbaV0gLSAxXSsrXSA+Pj4gKDE1IC0gY2RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbztcbn0pO1xuLy8gZml4ZWQgbGVuZ3RoIHRyZWVcbnZhciBmbHQgPSBuZXcgdTgoMjg4KTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMTQ0OyArK2kpXG4gICAgZmx0W2ldID0gODtcbmZvciAodmFyIGkgPSAxNDQ7IGkgPCAyNTY7ICsraSlcbiAgICBmbHRbaV0gPSA5O1xuZm9yICh2YXIgaSA9IDI1NjsgaSA8IDI4MDsgKytpKVxuICAgIGZsdFtpXSA9IDc7XG5mb3IgKHZhciBpID0gMjgwOyBpIDwgMjg4OyArK2kpXG4gICAgZmx0W2ldID0gODtcbi8vIGZpeGVkIGRpc3RhbmNlIHRyZWVcbnZhciBmZHQgPSBuZXcgdTgoMzIpO1xuZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgKytpKVxuICAgIGZkdFtpXSA9IDU7XG4vLyBmaXhlZCBsZW5ndGggbWFwXG52YXIgZmxtID0gLyojX19QVVJFX18qLyBoTWFwKGZsdCwgOSwgMCksIGZscm0gPSAvKiNfX1BVUkVfXyovIGhNYXAoZmx0LCA5LCAxKTtcbi8vIGZpeGVkIGRpc3RhbmNlIG1hcFxudmFyIGZkbSA9IC8qI19fUFVSRV9fKi8gaE1hcChmZHQsIDUsIDApLCBmZHJtID0gLyojX19QVVJFX18qLyBoTWFwKGZkdCwgNSwgMSk7XG4vLyBmaW5kIG1heCBvZiBhcnJheVxudmFyIG1heCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIG0gPSBhWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA+IG0pXG4gICAgICAgICAgICBtID0gYVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59O1xuLy8gcmVhZCBkLCBzdGFydGluZyBhdCBiaXQgcCBhbmQgbWFzayB3aXRoIG1cbnZhciBiaXRzID0gZnVuY3Rpb24gKGQsIHAsIG0pIHtcbiAgICB2YXIgbyA9IChwIC8gOCkgfCAwO1xuICAgIHJldHVybiAoKGRbb10gfCAoZFtvICsgMV0gPDwgOCkpID4+IChwICYgNykpICYgbTtcbn07XG4vLyByZWFkIGQsIHN0YXJ0aW5nIGF0IGJpdCBwIGNvbnRpbnVpbmcgZm9yIGF0IGxlYXN0IDE2IGJpdHNcbnZhciBiaXRzMTYgPSBmdW5jdGlvbiAoZCwgcCkge1xuICAgIHZhciBvID0gKHAgLyA4KSB8IDA7XG4gICAgcmV0dXJuICgoZFtvXSB8IChkW28gKyAxXSA8PCA4KSB8IChkW28gKyAyXSA8PCAxNikpID4+IChwICYgNykpO1xufTtcbi8vIGdldCBlbmQgb2YgYnl0ZVxudmFyIHNoZnQgPSBmdW5jdGlvbiAocCkgeyByZXR1cm4gKChwIC8gOCkgfCAwKSArIChwICYgNyAmJiAxKTsgfTtcbi8vIHR5cGVkIGFycmF5IHNsaWNlIC0gYWxsb3dzIGdhcmJhZ2UgY29sbGVjdG9yIHRvIGZyZWUgb3JpZ2luYWwgcmVmZXJlbmNlLFxuLy8gd2hpbGUgYmVpbmcgbW9yZSBjb21wYXRpYmxlIHRoYW4gLnNsaWNlXG52YXIgc2xjID0gZnVuY3Rpb24gKHYsIHMsIGUpIHtcbiAgICBpZiAocyA9PSBudWxsIHx8IHMgPCAwKVxuICAgICAgICBzID0gMDtcbiAgICBpZiAoZSA9PSBudWxsIHx8IGUgPiB2Lmxlbmd0aClcbiAgICAgICAgZSA9IHYubGVuZ3RoO1xuICAgIC8vIGNhbid0IHVzZSAuY29uc3RydWN0b3IgaW4gY2FzZSB1c2VyLXN1cHBsaWVkXG4gICAgdmFyIG4gPSBuZXcgKHYgaW5zdGFuY2VvZiB1MTYgPyB1MTYgOiB2IGluc3RhbmNlb2YgdTMyID8gdTMyIDogdTgpKGUgLSBzKTtcbiAgICBuLnNldCh2LnN1YmFycmF5KHMsIGUpKTtcbiAgICByZXR1cm4gbjtcbn07XG4vLyBleHBhbmRzIHJhdyBERUZMQVRFIGRhdGFcbnZhciBpbmZsdCA9IGZ1bmN0aW9uIChkYXQsIGJ1Ziwgc3QpIHtcbiAgICAvLyBzb3VyY2UgbGVuZ3RoXG4gICAgdmFyIHNsID0gZGF0Lmxlbmd0aDtcbiAgICBpZiAoIXNsIHx8IChzdCAmJiAhc3QubCAmJiBzbCA8IDUpKVxuICAgICAgICByZXR1cm4gYnVmIHx8IG5ldyB1OCgwKTtcbiAgICAvLyBoYXZlIHRvIGVzdGltYXRlIHNpemVcbiAgICB2YXIgbm9CdWYgPSAhYnVmIHx8IHN0O1xuICAgIC8vIG5vIHN0YXRlXG4gICAgdmFyIG5vU3QgPSAhc3QgfHwgc3QuaTtcbiAgICBpZiAoIXN0KVxuICAgICAgICBzdCA9IHt9O1xuICAgIC8vIEFzc3VtZXMgcm91Z2hseSAzMyUgY29tcHJlc3Npb24gcmF0aW8gYXZlcmFnZVxuICAgIGlmICghYnVmKVxuICAgICAgICBidWYgPSBuZXcgdTgoc2wgKiAzKTtcbiAgICAvLyBlbnN1cmUgYnVmZmVyIGNhbiBmaXQgYXQgbGVhc3QgbCBlbGVtZW50c1xuICAgIHZhciBjYnVmID0gZnVuY3Rpb24gKGwpIHtcbiAgICAgICAgdmFyIGJsID0gYnVmLmxlbmd0aDtcbiAgICAgICAgLy8gbmVlZCB0byBpbmNyZWFzZSBzaXplIHRvIGZpdFxuICAgICAgICBpZiAobCA+IGJsKSB7XG4gICAgICAgICAgICAvLyBEb3VibGUgb3Igc2V0IHRvIG5lY2Vzc2FyeSwgd2hpY2hldmVyIGlzIGdyZWF0ZXJcbiAgICAgICAgICAgIHZhciBuYnVmID0gbmV3IHU4KE1hdGgubWF4KGJsICogMiwgbCkpO1xuICAgICAgICAgICAgbmJ1Zi5zZXQoYnVmKTtcbiAgICAgICAgICAgIGJ1ZiA9IG5idWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vICBsYXN0IGNodW5rICAgICAgICAgYml0cG9zICAgICAgICAgICBieXRlc1xuICAgIHZhciBmaW5hbCA9IHN0LmYgfHwgMCwgcG9zID0gc3QucCB8fCAwLCBidCA9IHN0LmIgfHwgMCwgbG0gPSBzdC5sLCBkbSA9IHN0LmQsIGxidCA9IHN0Lm0sIGRidCA9IHN0Lm47XG4gICAgLy8gdG90YWwgYml0c1xuICAgIHZhciB0YnRzID0gc2wgKiA4O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCFsbSkge1xuICAgICAgICAgICAgLy8gQkZJTkFMIC0gdGhpcyBpcyBvbmx5IDEgd2hlbiBsYXN0IGNodW5rIGlzIG5leHRcbiAgICAgICAgICAgIHN0LmYgPSBmaW5hbCA9IGJpdHMoZGF0LCBwb3MsIDEpO1xuICAgICAgICAgICAgLy8gdHlwZTogMCA9IG5vIGNvbXByZXNzaW9uLCAxID0gZml4ZWQgaHVmZm1hbiwgMiA9IGR5bmFtaWMgaHVmZm1hblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBiaXRzKGRhdCwgcG9zICsgMSwgMyk7XG4gICAgICAgICAgICBwb3MgKz0gMztcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIHRvIGVuZCBvZiBieXRlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBzaGZ0KHBvcykgKyA0LCBsID0gZGF0W3MgLSA0XSB8IChkYXRbcyAtIDNdIDw8IDgpLCB0ID0gcyArIGw7XG4gICAgICAgICAgICAgICAgaWYgKHQgPiBzbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9TdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIGwpO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB1bmNvbXByZXNzZWQgZGF0YVxuICAgICAgICAgICAgICAgIGJ1Zi5zZXQoZGF0LnN1YmFycmF5KHMsIHQpLCBidCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBiaXRwb3MsIHVwZGF0ZSBieXRlIGNvdW50XG4gICAgICAgICAgICAgICAgc3QuYiA9IGJ0ICs9IGwsIHN0LnAgPSBwb3MgPSB0ICogODtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBsbSA9IGZscm0sIGRtID0gZmRybSwgbGJ0ID0gOSwgZGJ0ID0gNTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikge1xuICAgICAgICAgICAgICAgIC8vICBsaXRlcmFsICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aHNcbiAgICAgICAgICAgICAgICB2YXIgaExpdCA9IGJpdHMoZGF0LCBwb3MsIDMxKSArIDI1NywgaGNMZW4gPSBiaXRzKGRhdCwgcG9zICsgMTAsIDE1KSArIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHRsID0gaExpdCArIGJpdHMoZGF0LCBwb3MgKyA1LCAzMSkgKyAxO1xuICAgICAgICAgICAgICAgIHBvcyArPSAxNDtcbiAgICAgICAgICAgICAgICAvLyBsZW5ndGgrZGlzdGFuY2UgdHJlZVxuICAgICAgICAgICAgICAgIHZhciBsZHQgPSBuZXcgdTgodGwpO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RoIHRyZWVcbiAgICAgICAgICAgICAgICB2YXIgY2x0ID0gbmV3IHU4KDE5KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhjTGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGluZGV4IG1hcCB0byBnZXQgcmVhbCBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGNsdFtjbGltW2ldXSA9IGJpdHMoZGF0LCBwb3MgKyBpICogMywgNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvcyArPSBoY0xlbiAqIDM7XG4gICAgICAgICAgICAgICAgLy8gY29kZSBsZW5ndGhzIGJpdHNcbiAgICAgICAgICAgICAgICB2YXIgY2xiID0gbWF4KGNsdCksIGNsYm1zayA9ICgxIDw8IGNsYikgLSAxO1xuICAgICAgICAgICAgICAgIC8vIGNvZGUgbGVuZ3RocyBtYXBcbiAgICAgICAgICAgICAgICB2YXIgY2xtID0gaE1hcChjbHQsIGNsYiwgMSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0bDspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBjbG1bYml0cyhkYXQsIHBvcywgY2xibXNrKV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcmVhZFxuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gciAmIDE1O1xuICAgICAgICAgICAgICAgICAgICAvLyBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSByID4+PiA0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIGxlbmd0aCB0byBjb3B5XG4gICAgICAgICAgICAgICAgICAgIGlmIChzIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxkdFtpKytdID0gcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBjb3B5ICAgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjID0gMCwgbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMyArIGJpdHMoZGF0LCBwb3MsIDMpLCBwb3MgKz0gMiwgYyA9IGxkdFtpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzID09IDE3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAzICsgYml0cyhkYXQsIHBvcywgNyksIHBvcyArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAxOClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gMTEgKyBiaXRzKGRhdCwgcG9zLCAxMjcpLCBwb3MgKz0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChuLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGR0W2krK10gPSBjO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgIGxlbmd0aCB0cmVlICAgICAgICAgICAgICAgICBkaXN0YW5jZSB0cmVlXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0gbGR0LnN1YmFycmF5KDAsIGhMaXQpLCBkdCA9IGxkdC5zdWJhcnJheShoTGl0KTtcbiAgICAgICAgICAgICAgICAvLyBtYXggbGVuZ3RoIGJpdHNcbiAgICAgICAgICAgICAgICBsYnQgPSBtYXgobHQpO1xuICAgICAgICAgICAgICAgIC8vIG1heCBkaXN0IGJpdHNcbiAgICAgICAgICAgICAgICBkYnQgPSBtYXgoZHQpO1xuICAgICAgICAgICAgICAgIGxtID0gaE1hcChsdCwgbGJ0LCAxKTtcbiAgICAgICAgICAgICAgICBkbSA9IGhNYXAoZHQsIGRidCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgICAgICBpZiAocG9zID4gdGJ0cykge1xuICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyAndW5leHBlY3RlZCBFT0YnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnVmZmVyIGNhbiBob2xkIHRoaXMgKyB0aGUgbGFyZ2VzdCBwb3NzaWJsZSBhZGRpdGlvblxuICAgICAgICAvLyBNYXhpbXVtIGNodW5rIHNpemUgKHByYWN0aWNhbGx5LCB0aGVvcmV0aWNhbGx5IGluZmluaXRlKSBpcyAyXjE3O1xuICAgICAgICBpZiAobm9CdWYpXG4gICAgICAgICAgICBjYnVmKGJ0ICsgMTMxMDcyKTtcbiAgICAgICAgdmFyIGxtcyA9ICgxIDw8IGxidCkgLSAxLCBkbXMgPSAoMSA8PCBkYnQpIC0gMTtcbiAgICAgICAgdmFyIGxwb3MgPSBwb3M7XG4gICAgICAgIGZvciAoOzsgbHBvcyA9IHBvcykge1xuICAgICAgICAgICAgLy8gYml0cyByZWFkLCBjb2RlXG4gICAgICAgICAgICB2YXIgYyA9IGxtW2JpdHMxNihkYXQsIHBvcykgJiBsbXNdLCBzeW0gPSBjID4+PiA0O1xuICAgICAgICAgICAgcG9zICs9IGMgJiAxNTtcbiAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vU3QpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICd1bmV4cGVjdGVkIEVPRic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWMpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgbGVuZ3RoL2xpdGVyYWwnO1xuICAgICAgICAgICAgaWYgKHN5bSA8IDI1NilcbiAgICAgICAgICAgICAgICBidWZbYnQrK10gPSBzeW07XG4gICAgICAgICAgICBlbHNlIGlmIChzeW0gPT0gMjU2KSB7XG4gICAgICAgICAgICAgICAgbHBvcyA9IHBvcywgbG0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IHN5bSAtIDI1NDtcbiAgICAgICAgICAgICAgICAvLyBubyBleHRyYSBiaXRzIG5lZWRlZCBpZiBsZXNzXG4gICAgICAgICAgICAgICAgaWYgKHN5bSA+IDI2NCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHN5bSAtIDI1NywgYiA9IGZsZWJbaV07XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9IGJpdHMoZGF0LCBwb3MsICgxIDw8IGIpIC0gMSkgKyBmbFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRpc3RcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGRtW2JpdHMxNihkYXQsIHBvcykgJiBkbXNdLCBkc3ltID0gZCA+Pj4gNDtcbiAgICAgICAgICAgICAgICBpZiAoIWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIGRpc3RhbmNlJztcbiAgICAgICAgICAgICAgICBwb3MgKz0gZCAmIDE1O1xuICAgICAgICAgICAgICAgIHZhciBkdCA9IGZkW2RzeW1dO1xuICAgICAgICAgICAgICAgIGlmIChkc3ltID4gMykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGZkZWJbZHN5bV07XG4gICAgICAgICAgICAgICAgICAgIGR0ICs9IGJpdHMxNihkYXQsIHBvcykgJiAoKDEgPDwgYikgLSAxKSwgcG9zICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3MgPiB0YnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub1N0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgRU9GJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub0J1ZilcbiAgICAgICAgICAgICAgICAgICAgY2J1ZihidCArIDEzMTA3Mik7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGJ0ICsgYWRkO1xuICAgICAgICAgICAgICAgIGZvciAoOyBidCA8IGVuZDsgYnQgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbYnRdID0gYnVmW2J0IC0gZHRdO1xuICAgICAgICAgICAgICAgICAgICBidWZbYnQgKyAxXSA9IGJ1ZltidCArIDEgLSBkdF07XG4gICAgICAgICAgICAgICAgICAgIGJ1ZltidCArIDJdID0gYnVmW2J0ICsgMiAtIGR0XTtcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J0ICsgM10gPSBidWZbYnQgKyAzIC0gZHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidCA9IGVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdC5sID0gbG0sIHN0LnAgPSBscG9zLCBzdC5iID0gYnQ7XG4gICAgICAgIGlmIChsbSlcbiAgICAgICAgICAgIGZpbmFsID0gMSwgc3QubSA9IGxidCwgc3QuZCA9IGRtLCBzdC5uID0gZGJ0O1xuICAgIH0gd2hpbGUgKCFmaW5hbCk7XG4gICAgcmV0dXJuIGJ0ID09IGJ1Zi5sZW5ndGggPyBidWYgOiBzbGMoYnVmLCAwLCBidCk7XG59O1xuLy8gc3RhcnRpbmcgYXQgcCwgd3JpdGUgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gaG9sZCB2IHRvIGRcbnZhciB3Yml0cyA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbn07XG4vLyBzdGFydGluZyBhdCBwLCB3cml0ZSB0aGUgbWluaW11bSBudW1iZXIgb2YgYml0cyAoPjgpIHRoYXQgY2FuIGhvbGQgdiB0byBkXG52YXIgd2JpdHMxNiA9IGZ1bmN0aW9uIChkLCBwLCB2KSB7XG4gICAgdiA8PD0gcCAmIDc7XG4gICAgdmFyIG8gPSAocCAvIDgpIHwgMDtcbiAgICBkW29dIHw9IHY7XG4gICAgZFtvICsgMV0gfD0gdiA+Pj4gODtcbiAgICBkW28gKyAyXSB8PSB2ID4+PiAxNjtcbn07XG4vLyBjcmVhdGVzIGNvZGUgbGVuZ3RocyBmcm9tIGEgZnJlcXVlbmN5IHRhYmxlXG52YXIgaFRyZWUgPSBmdW5jdGlvbiAoZCwgbWIpIHtcbiAgICAvLyBOZWVkIGV4dHJhIGluZm8gdG8gbWFrZSBhIHRyZWVcbiAgICB2YXIgdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoZFtpXSlcbiAgICAgICAgICAgIHQucHVzaCh7IHM6IGksIGY6IGRbaV0gfSk7XG4gICAgfVxuICAgIHZhciBzID0gdC5sZW5ndGg7XG4gICAgdmFyIHQyID0gdC5zbGljZSgpO1xuICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIFtldCwgMF07XG4gICAgaWYgKHMgPT0gMSkge1xuICAgICAgICB2YXIgdiA9IG5ldyB1OCh0WzBdLnMgKyAxKTtcbiAgICAgICAgdlt0WzBdLnNdID0gMTtcbiAgICAgICAgcmV0dXJuIFt2LCAxXTtcbiAgICB9XG4gICAgdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmYgLSBiLmY7IH0pO1xuICAgIC8vIGFmdGVyIGkyIHJlYWNoZXMgbGFzdCBpbmQsIHdpbGwgYmUgc3RvcHBlZFxuICAgIC8vIGZyZXEgbXVzdCBiZSBncmVhdGVyIHRoYW4gbGFyZ2VzdCBwb3NzaWJsZSBudW1iZXIgb2Ygc3ltYm9sc1xuICAgIHQucHVzaCh7IHM6IC0xLCBmOiAyNTAwMSB9KTtcbiAgICB2YXIgbCA9IHRbMF0sIHIgPSB0WzFdLCBpMCA9IDAsIGkxID0gMSwgaTIgPSAyO1xuICAgIHRbMF0gPSB7IHM6IC0xLCBmOiBsLmYgKyByLmYsIGw6IGwsIHI6IHIgfTtcbiAgICAvLyBlZmZpY2llbnQgYWxnb3JpdGhtIGZyb20gVVpJUC5qc1xuICAgIC8vIGkwIGlzIGxvb2tiZWhpbmQsIGkyIGlzIGxvb2thaGVhZCAtIGFmdGVyIHByb2Nlc3NpbmcgdHdvIGxvdy1mcmVxXG4gICAgLy8gc3ltYm9scyB0aGF0IGNvbWJpbmVkIGhhdmUgaGlnaCBmcmVxLCB3aWxsIHN0YXJ0IHByb2Nlc3NpbmcgaTIgKGhpZ2gtZnJlcSxcbiAgICAvLyBub24tY29tcG9zaXRlKSBzeW1ib2xzIGluc3RlYWRcbiAgICAvLyBzZWUgaHR0cHM6Ly9yZWRkaXQuY29tL3IvcGhvdG9wZWEvY29tbWVudHMvaWtla2h0L3V6aXBqc19xdWVzdGlvbnMvXG4gICAgd2hpbGUgKGkxICE9IHMgLSAxKSB7XG4gICAgICAgIGwgPSB0W3RbaTBdLmYgPCB0W2kyXS5mID8gaTArKyA6IGkyKytdO1xuICAgICAgICByID0gdFtpMCAhPSBpMSAmJiB0W2kwXS5mIDwgdFtpMl0uZiA/IGkwKysgOiBpMisrXTtcbiAgICAgICAgdFtpMSsrXSA9IHsgczogLTEsIGY6IGwuZiArIHIuZiwgbDogbCwgcjogciB9O1xuICAgIH1cbiAgICB2YXIgbWF4U3ltID0gdDJbMF0ucztcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHM7ICsraSkge1xuICAgICAgICBpZiAodDJbaV0ucyA+IG1heFN5bSlcbiAgICAgICAgICAgIG1heFN5bSA9IHQyW2ldLnM7XG4gICAgfVxuICAgIC8vIGNvZGUgbGVuZ3Roc1xuICAgIHZhciB0ciA9IG5ldyB1MTYobWF4U3ltICsgMSk7XG4gICAgLy8gbWF4IGJpdHMgaW4gdHJlZVxuICAgIHZhciBtYnQgPSBsbih0W2kxIC0gMV0sIHRyLCAwKTtcbiAgICBpZiAobWJ0ID4gbWIpIHtcbiAgICAgICAgLy8gbW9yZSBhbGdvcml0aG1zIGZyb20gVVpJUC5qc1xuICAgICAgICAvLyBUT0RPOiBmaW5kIG91dCBob3cgdGhpcyBjb2RlIHdvcmtzIChkZWJ0KVxuICAgICAgICAvLyAgaW5kICAgIGRlYnRcbiAgICAgICAgdmFyIGkgPSAwLCBkdCA9IDA7XG4gICAgICAgIC8vICAgIGxlZnQgICAgICAgICAgICBjb3N0XG4gICAgICAgIHZhciBsZnQgPSBtYnQgLSBtYiwgY3N0ID0gMSA8PCBsZnQ7XG4gICAgICAgIHQyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIHRyW2Iuc10gLSB0clthLnNdIHx8IGEuZiAtIGIuZjsgfSk7XG4gICAgICAgIGZvciAoOyBpIDwgczsgKytpKSB7XG4gICAgICAgICAgICB2YXIgaTJfMSA9IHQyW2ldLnM7XG4gICAgICAgICAgICBpZiAodHJbaTJfMV0gPiBtYikge1xuICAgICAgICAgICAgICAgIGR0ICs9IGNzdCAtICgxIDw8IChtYnQgLSB0cltpMl8xXSkpO1xuICAgICAgICAgICAgICAgIHRyW2kyXzFdID0gbWI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZHQgPj4+PSBsZnQ7XG4gICAgICAgIHdoaWxlIChkdCA+IDApIHtcbiAgICAgICAgICAgIHZhciBpMl8yID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8yXSA8IG1iKVxuICAgICAgICAgICAgICAgIGR0IC09IDEgPDwgKG1iIC0gdHJbaTJfMl0rKyAtIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA+PSAwICYmIGR0OyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBpMl8zID0gdDJbaV0ucztcbiAgICAgICAgICAgIGlmICh0cltpMl8zXSA9PSBtYikge1xuICAgICAgICAgICAgICAgIC0tdHJbaTJfM107XG4gICAgICAgICAgICAgICAgKytkdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYnQgPSBtYjtcbiAgICB9XG4gICAgcmV0dXJuIFtuZXcgdTgodHIpLCBtYnRdO1xufTtcbi8vIGdldCB0aGUgbWF4IGxlbmd0aCBhbmQgYXNzaWduIGxlbmd0aCBjb2Rlc1xudmFyIGxuID0gZnVuY3Rpb24gKG4sIGwsIGQpIHtcbiAgICByZXR1cm4gbi5zID09IC0xXG4gICAgICAgID8gTWF0aC5tYXgobG4obi5sLCBsLCBkICsgMSksIGxuKG4uciwgbCwgZCArIDEpKVxuICAgICAgICA6IChsW24uc10gPSBkKTtcbn07XG4vLyBsZW5ndGggY29kZXMgZ2VuZXJhdGlvblxudmFyIGxjID0gZnVuY3Rpb24gKGMpIHtcbiAgICB2YXIgcyA9IGMubGVuZ3RoO1xuICAgIC8vIE5vdGUgdGhhdCB0aGUgc2VtaWNvbG9uIHdhcyBpbnRlbnRpb25hbFxuICAgIHdoaWxlIChzICYmICFjWy0tc10pXG4gICAgICAgIDtcbiAgICB2YXIgY2wgPSBuZXcgdTE2KCsrcyk7XG4gICAgLy8gIGluZCAgICAgIG51bSAgICAgICAgIHN0cmVha1xuICAgIHZhciBjbGkgPSAwLCBjbG4gPSBjWzBdLCBjbHMgPSAxO1xuICAgIHZhciB3ID0gZnVuY3Rpb24gKHYpIHsgY2xbY2xpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzOyArK2kpIHtcbiAgICAgICAgaWYgKGNbaV0gPT0gY2xuICYmIGkgIT0gcylcbiAgICAgICAgICAgICsrY2xzO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY2xuICYmIGNscyA+IDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgY2xzID4gMTM4OyBjbHMgLT0gMTM4KVxuICAgICAgICAgICAgICAgICAgICB3KDMyNzU0KTtcbiAgICAgICAgICAgICAgICBpZiAoY2xzID4gMikge1xuICAgICAgICAgICAgICAgICAgICB3KGNscyA+IDEwID8gKChjbHMgLSAxMSkgPDwgNSkgfCAyODY5MCA6ICgoY2xzIC0gMykgPDwgNSkgfCAxMjMwNSk7XG4gICAgICAgICAgICAgICAgICAgIGNscyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xzID4gMykge1xuICAgICAgICAgICAgICAgIHcoY2xuKSwgLS1jbHM7XG4gICAgICAgICAgICAgICAgZm9yICg7IGNscyA+IDY7IGNscyAtPSA2KVxuICAgICAgICAgICAgICAgICAgICB3KDgzMDQpO1xuICAgICAgICAgICAgICAgIGlmIChjbHMgPiAyKVxuICAgICAgICAgICAgICAgICAgICB3KCgoY2xzIC0gMykgPDwgNSkgfCA4MjA4KSwgY2xzID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjbHMtLSlcbiAgICAgICAgICAgICAgICB3KGNsbik7XG4gICAgICAgICAgICBjbHMgPSAxO1xuICAgICAgICAgICAgY2xuID0gY1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2NsLnN1YmFycmF5KDAsIGNsaSksIHNdO1xufTtcbi8vIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIG91dHB1dCBmcm9tIHRyZWUsIGNvZGUgbGVuZ3Roc1xudmFyIGNsZW4gPSBmdW5jdGlvbiAoY2YsIGNsKSB7XG4gICAgdmFyIGwgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2wubGVuZ3RoOyArK2kpXG4gICAgICAgIGwgKz0gY2ZbaV0gKiBjbFtpXTtcbiAgICByZXR1cm4gbDtcbn07XG4vLyB3cml0ZXMgYSBmaXhlZCBibG9ja1xuLy8gcmV0dXJucyB0aGUgbmV3IGJpdCBwb3NcbnZhciB3ZmJsayA9IGZ1bmN0aW9uIChvdXQsIHBvcywgZGF0KSB7XG4gICAgLy8gbm8gbmVlZCB0byB3cml0ZSAwMCBhcyB0eXBlOiBUeXBlZEFycmF5IGRlZmF1bHRzIHRvIDBcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBzaGZ0KHBvcyArIDIpO1xuICAgIG91dFtvXSA9IHMgJiAyNTU7XG4gICAgb3V0W28gKyAxXSA9IHMgPj4+IDg7XG4gICAgb3V0W28gKyAyXSA9IG91dFtvXSBeIDI1NTtcbiAgICBvdXRbbyArIDNdID0gb3V0W28gKyAxXSBeIDI1NTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7ICsraSlcbiAgICAgICAgb3V0W28gKyBpICsgNF0gPSBkYXRbaV07XG4gICAgcmV0dXJuIChvICsgNCArIHMpICogODtcbn07XG4vLyB3cml0ZXMgYSBibG9ja1xudmFyIHdibGsgPSBmdW5jdGlvbiAoZGF0LCBvdXQsIGZpbmFsLCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGJsLCBwKSB7XG4gICAgd2JpdHMob3V0LCBwKyssIGZpbmFsKTtcbiAgICArK2xmWzI1Nl07XG4gICAgdmFyIF9hID0gaFRyZWUobGYsIDE1KSwgZGx0ID0gX2FbMF0sIG1sYiA9IF9hWzFdO1xuICAgIHZhciBfYiA9IGhUcmVlKGRmLCAxNSksIGRkdCA9IF9iWzBdLCBtZGIgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBsYyhkbHQpLCBsY2x0ID0gX2NbMF0sIG5sYyA9IF9jWzFdO1xuICAgIHZhciBfZCA9IGxjKGRkdCksIGxjZHQgPSBfZFswXSwgbmRjID0gX2RbMV07XG4gICAgdmFyIGxjZnJlcSA9IG5ldyB1MTYoMTkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGNsdC5sZW5ndGg7ICsraSlcbiAgICAgICAgbGNmcmVxW2xjbHRbaV0gJiAzMV0rKztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxjZHQubGVuZ3RoOyArK2kpXG4gICAgICAgIGxjZnJlcVtsY2R0W2ldICYgMzFdKys7XG4gICAgdmFyIF9lID0gaFRyZWUobGNmcmVxLCA3KSwgbGN0ID0gX2VbMF0sIG1sY2IgPSBfZVsxXTtcbiAgICB2YXIgbmxjYyA9IDE5O1xuICAgIGZvciAoOyBubGNjID4gNCAmJiAhbGN0W2NsaW1bbmxjYyAtIDFdXTsgLS1ubGNjKVxuICAgICAgICA7XG4gICAgdmFyIGZsZW4gPSAoYmwgKyA1KSA8PCAzO1xuICAgIHZhciBmdGxlbiA9IGNsZW4obGYsIGZsdCkgKyBjbGVuKGRmLCBmZHQpICsgZWI7XG4gICAgdmFyIGR0bGVuID0gY2xlbihsZiwgZGx0KSArIGNsZW4oZGYsIGRkdCkgKyBlYiArIDE0ICsgMyAqIG5sY2MgKyBjbGVuKGxjZnJlcSwgbGN0KSArICgyICogbGNmcmVxWzE2XSArIDMgKiBsY2ZyZXFbMTddICsgNyAqIGxjZnJlcVsxOF0pO1xuICAgIGlmIChmbGVuIDw9IGZ0bGVuICYmIGZsZW4gPD0gZHRsZW4pXG4gICAgICAgIHJldHVybiB3ZmJsayhvdXQsIHAsIGRhdC5zdWJhcnJheShicywgYnMgKyBibCkpO1xuICAgIHZhciBsbSwgbGwsIGRtLCBkbDtcbiAgICB3Yml0cyhvdXQsIHAsIDEgKyAoZHRsZW4gPCBmdGxlbikpLCBwICs9IDI7XG4gICAgaWYgKGR0bGVuIDwgZnRsZW4pIHtcbiAgICAgICAgbG0gPSBoTWFwKGRsdCwgbWxiLCAwKSwgbGwgPSBkbHQsIGRtID0gaE1hcChkZHQsIG1kYiwgMCksIGRsID0gZGR0O1xuICAgICAgICB2YXIgbGxtID0gaE1hcChsY3QsIG1sY2IsIDApO1xuICAgICAgICB3Yml0cyhvdXQsIHAsIG5sYyAtIDI1Nyk7XG4gICAgICAgIHdiaXRzKG91dCwgcCArIDUsIG5kYyAtIDEpO1xuICAgICAgICB3Yml0cyhvdXQsIHAgKyAxMCwgbmxjYyAtIDQpO1xuICAgICAgICBwICs9IDE0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5sY2M7ICsraSlcbiAgICAgICAgICAgIHdiaXRzKG91dCwgcCArIDMgKiBpLCBsY3RbY2xpbVtpXV0pO1xuICAgICAgICBwICs9IDMgKiBubGNjO1xuICAgICAgICB2YXIgbGN0cyA9IFtsY2x0LCBsY2R0XTtcbiAgICAgICAgZm9yICh2YXIgaXQgPSAwOyBpdCA8IDI7ICsraXQpIHtcbiAgICAgICAgICAgIHZhciBjbGN0ID0gbGN0c1tpdF07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gY2xjdFtpXSAmIDMxO1xuICAgICAgICAgICAgICAgIHdiaXRzKG91dCwgcCwgbGxtW2xlbl0pLCBwICs9IGxjdFtsZW5dO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxNSlcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMob3V0LCBwLCAoY2xjdFtpXSA+Pj4gNSkgJiAxMjcpLCBwICs9IGNsY3RbaV0gPj4+IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsbSA9IGZsbSwgbGwgPSBmbHQsIGRtID0gZmRtLCBkbCA9IGZkdDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaTsgKytpKSB7XG4gICAgICAgIGlmIChzeW1zW2ldID4gMjU1KSB7XG4gICAgICAgICAgICB2YXIgbGVuID0gKHN5bXNbaV0gPj4+IDE4KSAmIDMxO1xuICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIGxtW2xlbiArIDI1N10pLCBwICs9IGxsW2xlbiArIDI1N107XG4gICAgICAgICAgICBpZiAobGVuID4gNylcbiAgICAgICAgICAgICAgICB3Yml0cyhvdXQsIHAsIChzeW1zW2ldID4+PiAyMykgJiAzMSksIHAgKz0gZmxlYltsZW5dO1xuICAgICAgICAgICAgdmFyIGRzdCA9IHN5bXNbaV0gJiAzMTtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBkbVtkc3RdKSwgcCArPSBkbFtkc3RdO1xuICAgICAgICAgICAgaWYgKGRzdCA+IDMpXG4gICAgICAgICAgICAgICAgd2JpdHMxNihvdXQsIHAsIChzeW1zW2ldID4+PiA1KSAmIDgxOTEpLCBwICs9IGZkZWJbZHN0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdiaXRzMTYob3V0LCBwLCBsbVtzeW1zW2ldXSksIHAgKz0gbGxbc3ltc1tpXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2JpdHMxNihvdXQsIHAsIGxtWzI1Nl0pO1xuICAgIHJldHVybiBwICsgbGxbMjU2XTtcbn07XG4vLyBkZWZsYXRlIG9wdGlvbnMgKG5pY2UgPDwgMTMpIHwgY2hhaW5cbnZhciBkZW8gPSAvKiNfX1BVUkVfXyovIG5ldyB1MzIoWzY1NTQwLCAxMzEwODAsIDEzMTA4OCwgMTMxMTA0LCAyNjIxNzYsIDEwNDg3MDQsIDEwNDg4MzIsIDIxMTQ1NjAsIDIxMTc2MzJdKTtcbi8vIGVtcHR5XG52YXIgZXQgPSAvKiNfX1BVUkVfXyovIG5ldyB1OCgwKTtcbi8vIGNvbXByZXNzZXMgZGF0YSBpbnRvIGEgcmF3IERFRkxBVEUgYnVmZmVyXG52YXIgZGZsdCA9IGZ1bmN0aW9uIChkYXQsIGx2bCwgcGx2bCwgcHJlLCBwb3N0LCBsc3QpIHtcbiAgICB2YXIgcyA9IGRhdC5sZW5ndGg7XG4gICAgdmFyIG8gPSBuZXcgdTgocHJlICsgcyArIDUgKiAoMSArIE1hdGguY2VpbChzIC8gNzAwMCkpICsgcG9zdCk7XG4gICAgLy8gd3JpdGluZyB0byB0aGlzIHdyaXRlcyB0byB0aGUgb3V0cHV0IGJ1ZmZlclxuICAgIHZhciB3ID0gby5zdWJhcnJheShwcmUsIG8ubGVuZ3RoIC0gcG9zdCk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgaWYgKCFsdmwgfHwgcyA8IDgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gczsgaSArPSA2NTUzNSkge1xuICAgICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgICB2YXIgZSA9IGkgKyA2NTUzNTtcbiAgICAgICAgICAgIGlmIChlIDwgcykge1xuICAgICAgICAgICAgICAgIC8vIHdyaXRlIGZ1bGwgYmxvY2tcbiAgICAgICAgICAgICAgICBwb3MgPSB3ZmJsayh3LCBwb3MsIGRhdC5zdWJhcnJheShpLCBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3cml0ZSBmaW5hbCBibG9ja1xuICAgICAgICAgICAgICAgIHdbaV0gPSBsc3Q7XG4gICAgICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zLCBkYXQuc3ViYXJyYXkoaSwgcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgb3B0ID0gZGVvW2x2bCAtIDFdO1xuICAgICAgICB2YXIgbiA9IG9wdCA+Pj4gMTMsIGMgPSBvcHQgJiA4MTkxO1xuICAgICAgICB2YXIgbXNrXzEgPSAoMSA8PCBwbHZsKSAtIDE7XG4gICAgICAgIC8vICAgIHByZXYgMi1ieXRlIHZhbCBtYXAgICAgY3VyciAyLWJ5dGUgdmFsIG1hcFxuICAgICAgICB2YXIgcHJldiA9IG5ldyB1MTYoMzI3NjgpLCBoZWFkID0gbmV3IHUxNihtc2tfMSArIDEpO1xuICAgICAgICB2YXIgYnMxXzEgPSBNYXRoLmNlaWwocGx2bCAvIDMpLCBiczJfMSA9IDIgKiBiczFfMTtcbiAgICAgICAgdmFyIGhzaCA9IGZ1bmN0aW9uIChpKSB7IHJldHVybiAoZGF0W2ldIF4gKGRhdFtpICsgMV0gPDwgYnMxXzEpIF4gKGRhdFtpICsgMl0gPDwgYnMyXzEpKSAmIG1za18xOyB9O1xuICAgICAgICAvLyAyNDU3NiBpcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIG1heGltdW0gc3ltYm9scyBwZXIgYmxvY2tcbiAgICAgICAgLy8gNDI0IGJ1ZmZlciBmb3IgbGFzdCBibG9ja1xuICAgICAgICB2YXIgc3ltcyA9IG5ldyB1MzIoMjUwMDApO1xuICAgICAgICAvLyBsZW5ndGgvbGl0ZXJhbCBmcmVxICAgZGlzdGFuY2UgZnJlcVxuICAgICAgICB2YXIgbGYgPSBuZXcgdTE2KDI4OCksIGRmID0gbmV3IHUxNigzMik7XG4gICAgICAgIC8vICBsL2xjbnQgIGV4Yml0cyAgaW5kZXggIGwvbGluZCAgd2FpdGR4ICBiaXRwb3NcbiAgICAgICAgdmFyIGxjXzEgPSAwLCBlYiA9IDAsIGkgPSAwLCBsaSA9IDAsIHdpID0gMCwgYnMgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IHM7ICsraSkge1xuICAgICAgICAgICAgLy8gaGFzaCB2YWx1ZVxuICAgICAgICAgICAgLy8gZGVvcHQgd2hlbiBpID4gcyAtIDMgLSBhdCBlbmQsIGRlb3B0IGFjY2VwdGFibGVcbiAgICAgICAgICAgIHZhciBodiA9IGhzaChpKTtcbiAgICAgICAgICAgIC8vIGluZGV4IG1vZCAzMjc2OCAgICBwcmV2aW91cyBpbmRleCBtb2RcbiAgICAgICAgICAgIHZhciBpbW9kID0gaSAmIDMyNzY3LCBwaW1vZCA9IGhlYWRbaHZdO1xuICAgICAgICAgICAgcHJldltpbW9kXSA9IHBpbW9kO1xuICAgICAgICAgICAgaGVhZFtodl0gPSBpbW9kO1xuICAgICAgICAgICAgLy8gV2UgYWx3YXlzIHNob3VsZCBtb2RpZnkgaGVhZCBhbmQgcHJldiwgYnV0IG9ubHkgYWRkIHN5bWJvbHMgaWZcbiAgICAgICAgICAgIC8vIHRoaXMgZGF0YSBpcyBub3QgeWV0IHByb2Nlc3NlZCAoXCJ3YWl0XCIgZm9yIHdhaXQgaW5kZXgpXG4gICAgICAgICAgICBpZiAod2kgPD0gaSkge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgIHZhciByZW0gPSBzIC0gaTtcbiAgICAgICAgICAgICAgICBpZiAoKGxjXzEgPiA3MDAwIHx8IGxpID4gMjQ1NzYpICYmIHJlbSA+IDQyMykge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgMCwgc3ltcywgbGYsIGRmLCBlYiwgbGksIGJzLCBpIC0gYnMsIHBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGxpID0gbGNfMSA9IGViID0gMCwgYnMgPSBpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI4NjsgKytqKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGZbal0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDMwOyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICBkZltqXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBsZW4gICAgZGlzdCAgIGNoYWluXG4gICAgICAgICAgICAgICAgdmFyIGwgPSAyLCBkID0gMCwgY2hfMSA9IGMsIGRpZiA9IChpbW9kIC0gcGltb2QpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgaWYgKHJlbSA+IDIgJiYgaHYgPT0gaHNoKGkgLSBkaWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhuID0gTWF0aC5taW4obiwgcmVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhkID0gTWF0aC5taW4oMzI3NjcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXggcG9zc2libGUgbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBjYXBwZWQgYXQgZGlmIGJlY2F1c2UgZGVjb21wcmVzc29ycyBpbXBsZW1lbnQgXCJyb2xsaW5nXCIgaW5kZXggcG9wdWxhdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWwgPSBNYXRoLm1pbigyNTgsIHJlbSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChkaWYgPD0gbWF4ZCAmJiAtLWNoXzEgJiYgaW1vZCAhPSBwaW1vZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdFtpICsgbF0gPT0gZGF0W2kgKyBsIC0gZGlmXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBubCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IG5sIDwgbWwgJiYgZGF0W2kgKyBubF0gPT0gZGF0W2kgKyBubCAtIGRpZl07ICsrbmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBubCwgZCA9IGRpZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgb3V0IGVhcmx5IHdoZW4gd2UgcmVhY2ggXCJuaWNlXCIgKHdlIGFyZSBzYXRpc2ZpZWQgZW5vdWdoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmwgPiBtYXhuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdywgZmluZCB0aGUgcmFyZXN0IDItYnl0ZSBzZXF1ZW5jZSB3aXRoaW4gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZW5ndGggb2YgbGl0ZXJhbHMgYW5kIHNlYXJjaCBmb3IgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNdWNoIGZhc3RlciB0aGFuIGp1c3QgdXNpbmcgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtbWQgPSBNYXRoLm1pbihkaWYsIG5sIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbW1kOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aSA9IChpIC0gZGlmICsgaiArIDMyNzY4KSAmIDMyNzY3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB0aSA9IHByZXZbdGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNkID0gKHRpIC0gcHRpICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2QgPiBtZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZCA9IGNkLCBwaW1vZCA9IHRpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIHByZXZpb3VzIG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW9kID0gcGltb2QsIHBpbW9kID0gcHJldltpbW9kXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZiArPSAoaW1vZCAtIHBpbW9kICsgMzI3NjgpICYgMzI3Njc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZCB3aWxsIGJlIG5vbnplcm8gb25seSB3aGVuIGEgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmUgYm90aCBkaXN0IGFuZCBsZW4gZGF0YSBpbiBvbmUgVWludDMyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGlzIGlzIHJlY29nbml6ZWQgYXMgYSBsZW4vZGlzdCB3aXRoIDI4dGggYml0ICgyXjI4KVxuICAgICAgICAgICAgICAgICAgICBzeW1zW2xpKytdID0gMjY4NDM1NDU2IHwgKHJldmZsW2xdIDw8IDE4KSB8IHJldmZkW2RdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluID0gcmV2ZmxbbF0gJiAzMSwgZGluID0gcmV2ZmRbZF0gJiAzMTtcbiAgICAgICAgICAgICAgICAgICAgZWIgKz0gZmxlYltsaW5dICsgZmRlYltkaW5dO1xuICAgICAgICAgICAgICAgICAgICArK2xmWzI1NyArIGxpbl07XG4gICAgICAgICAgICAgICAgICAgICsrZGZbZGluXTtcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBpICsgbDtcbiAgICAgICAgICAgICAgICAgICAgKytsY18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ltc1tsaSsrXSA9IGRhdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgKytsZltkYXRbaV1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MgPSB3YmxrKGRhdCwgdywgbHN0LCBzeW1zLCBsZiwgZGYsIGViLCBsaSwgYnMsIGkgLSBicywgcG9zKTtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgZWFzaWVzdCB3YXkgdG8gYXZvaWQgbmVlZGluZyB0byBtYWludGFpbiBzdGF0ZVxuICAgICAgICBpZiAoIWxzdCAmJiBwb3MgJiA3KVxuICAgICAgICAgICAgcG9zID0gd2ZibGsodywgcG9zICsgMSwgZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2xjKG8sIDAsIHByZSArIHNoZnQocG9zKSArIHBvc3QpO1xufTtcbi8vIENSQzMyIHRhYmxlXG52YXIgY3JjdCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdCA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICAgICAgICB2YXIgYyA9IGksIGsgPSA5O1xuICAgICAgICB3aGlsZSAoLS1rKVxuICAgICAgICAgICAgYyA9ICgoYyAmIDEpICYmIC0zMDY2NzQ5MTIpIF4gKGMgPj4+IDEpO1xuICAgICAgICB0W2ldID0gYztcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59KSgpO1xuLy8gQ1JDMzJcbnZhciBjcmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGMgPSAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgLy8gY2xvc3VyZXMgaGF2ZSBhd2Z1bCBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgdmFyIGNyID0gYztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjciA9IGNyY3RbKGNyICYgMjU1KSBeIGRbaV1dIF4gKGNyID4+PiA4KTtcbiAgICAgICAgICAgIGMgPSBjcjtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gfmM7IH1cbiAgICB9O1xufTtcbi8vIEFsZGVyMzJcbnZhciBhZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYSA9IDEsIGIgPSAwO1xuICAgIHJldHVybiB7XG4gICAgICAgIHA6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBjbG9zdXJlcyBoYXZlIGF3ZnVsIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICB2YXIgbiA9IGEsIG0gPSBiO1xuICAgICAgICAgICAgdmFyIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9IGw7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1pbihpICsgMjY1NSwgbCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBlOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIG0gKz0gbiArPSBkW2ldO1xuICAgICAgICAgICAgICAgIG4gPSAobiAmIDY1NTM1KSArIDE1ICogKG4gPj4gMTYpLCBtID0gKG0gJiA2NTUzNSkgKyAxNSAqIChtID4+IDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSBuLCBiID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYSAlPSA2NTUyMSwgYiAlPSA2NTUyMTtcbiAgICAgICAgICAgIHJldHVybiAoYSAmIDI1NSkgPDwgMjQgfCAoYSA+Pj4gOCkgPDwgMTYgfCAoYiAmIDI1NSkgPDwgOCB8IChiID4+PiA4KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuO1xuLy8gZGVmbGF0ZSB3aXRoIG9wdHNcbnZhciBkb3B0ID0gZnVuY3Rpb24gKGRhdCwgb3B0LCBwcmUsIHBvc3QsIHN0KSB7XG4gICAgcmV0dXJuIGRmbHQoZGF0LCBvcHQubGV2ZWwgPT0gbnVsbCA/IDYgOiBvcHQubGV2ZWwsIG9wdC5tZW0gPT0gbnVsbCA/IE1hdGguY2VpbChNYXRoLm1heCg4LCBNYXRoLm1pbigxMywgTWF0aC5sb2coZGF0Lmxlbmd0aCkpKSAqIDEuNSkgOiAoMTIgKyBvcHQubWVtKSwgcHJlLCBwb3N0LCAhc3QpO1xufTtcbi8vIFdhbG1hcnQgb2JqZWN0IHNwcmVhZFxudmFyIG1yZyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBrIGluIGEpXG4gICAgICAgIG9ba10gPSBhW2tdO1xuICAgIGZvciAodmFyIGsgaW4gYilcbiAgICAgICAgb1trXSA9IGJba107XG4gICAgcmV0dXJuIG87XG59O1xuLy8gd29ya2VyIGNsb25lXG4vLyBUaGlzIGlzIHBvc3NpYmx5IHRoZSBjcmF6aWVzdCBwYXJ0IG9mIHRoZSBlbnRpcmUgY29kZWJhc2UsIGRlc3BpdGUgaG93IHNpbXBsZSBpdCBtYXkgc2VlbS5cbi8vIFRoZSBvbmx5IHBhcmFtZXRlciB0byB0aGlzIGZ1bmN0aW9uIGlzIGEgY2xvc3VyZSB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2YgdmFyaWFibGVzIG91dHNpZGUgb2YgdGhlIGZ1bmN0aW9uIHNjb3BlLlxuLy8gV2UncmUgZ29pbmcgdG8gdHJ5IHRvIGZpZ3VyZSBvdXQgdGhlIHZhcmlhYmxlIG5hbWVzIHVzZWQgaW4gdGhlIGNsb3N1cmUgYXMgc3RyaW5ncyBiZWNhdXNlIHRoYXQgaXMgY3J1Y2lhbCBmb3Igd29ya2VyaXphdGlvbi5cbi8vIFdlIHdpbGwgcmV0dXJuIGFuIG9iamVjdCBtYXBwaW5nIG9mIHRydWUgdmFyaWFibGUgbmFtZSB0byB2YWx1ZSAoYmFzaWNhbGx5LCB0aGUgY3VycmVudCBzY29wZSBhcyBhIEpTIG9iamVjdCkuXG4vLyBUaGUgcmVhc29uIHdlIGNhbid0IGp1c3QgdXNlIHRoZSBvcmlnaW5hbCB2YXJpYWJsZSBuYW1lcyBpcyBtaW5pZmllcnMgbWFuZ2xpbmcgdGhlIHRvcGxldmVsIHNjb3BlLlxuLy8gVGhpcyB0b29rIG1lIHRocmVlIHdlZWtzIHRvIGZpZ3VyZSBvdXQgaG93IHRvIGRvLlxudmFyIHdjbG4gPSBmdW5jdGlvbiAoZm4sIGZuU3RyLCB0ZCkge1xuICAgIHZhciBkdCA9IGZuKCk7XG4gICAgdmFyIHN0ID0gZm4udG9TdHJpbmcoKTtcbiAgICB2YXIga3MgPSBzdC5zbGljZShzdC5pbmRleE9mKCdbJykgKyAxLCBzdC5sYXN0SW5kZXhPZignXScpKS5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSBkdFtpXSwgayA9IGtzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm5TdHIgKz0gJzsnICsgayArICc9JztcbiAgICAgICAgICAgIHZhciBzdF8xID0gdi50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKHYucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGdsb2JhbCBvYmplY3RzXG4gICAgICAgICAgICAgICAgaWYgKHN0XzEuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcEluZCA9IHN0XzEuaW5kZXhPZignICcsIDgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZm5TdHIgKz0gc3RfMS5zbGljZShzcEluZCwgc3RfMS5pbmRleE9mKCcoJywgc3BJbmQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZuU3RyICs9IHN0XzE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gdi5wcm90b3R5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmblN0ciArPSAnOycgKyBrICsgJy5wcm90b3R5cGUuJyArIHQgKyAnPScgKyB2LnByb3RvdHlwZVt0XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmblN0ciArPSBzdF8xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRkW2tdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIFtmblN0ciwgdGRdO1xufTtcbnZhciBjaCA9IFtdO1xuLy8gY2xvbmUgYnVmc1xudmFyIGNiZnMgPSBmdW5jdGlvbiAodikge1xuICAgIHZhciB0bCA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gdikge1xuICAgICAgICBpZiAodltrXSBpbnN0YW5jZW9mIHU4IHx8IHZba10gaW5zdGFuY2VvZiB1MTYgfHwgdltrXSBpbnN0YW5jZW9mIHUzMilcbiAgICAgICAgICAgIHRsLnB1c2goKHZba10gPSBuZXcgdltrXS5jb25zdHJ1Y3Rvcih2W2tdKSkuYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRsO1xufTtcbi8vIHVzZSBhIHdvcmtlciB0byBleGVjdXRlIGNvZGVcbnZhciB3cmtyID0gZnVuY3Rpb24gKGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghY2hbaWRdKSB7XG4gICAgICAgIHZhciBmblN0ciA9ICcnLCB0ZF8xID0ge30sIG0gPSBmbnMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtOyArK2kpXG4gICAgICAgICAgICBfYSA9IHdjbG4oZm5zW2ldLCBmblN0ciwgdGRfMSksIGZuU3RyID0gX2FbMF0sIHRkXzEgPSBfYVsxXTtcbiAgICAgICAgY2hbaWRdID0gd2NsbihmbnNbbV0sIGZuU3RyLCB0ZF8xKTtcbiAgICB9XG4gICAgdmFyIHRkID0gbXJnKHt9LCBjaFtpZF1bMV0pO1xuICAgIHJldHVybiB3ayhjaFtpZF1bMF0gKyAnO29ubWVzc2FnZT1mdW5jdGlvbihlKXtmb3IodmFyIGsgaW4gZS5kYXRhKXNlbGZba109ZS5kYXRhW2tdO29ubWVzc2FnZT0nICsgaW5pdC50b1N0cmluZygpICsgJ30nLCBpZCwgdGQsIGNiZnModGQpLCBjYik7XG59O1xuLy8gYmFzZSBhc3luYyBpbmZsYXRlIGZuXG52YXIgYkluZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgZmwsIGZkLCBmbHJtLCBmZHJtLCByZXYsIGhNYXAsIG1heCwgYml0cywgYml0czE2LCBzaGZ0LCBzbGMsIGluZmx0LCBpbmZsYXRlU3luYywgcGJmLCBndThdOyB9O1xudmFyIGJEZmx0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW3U4LCB1MTYsIHUzMiwgZmxlYiwgZmRlYiwgY2xpbSwgcmV2ZmwsIHJldmZkLCBmbG0sIGZsdCwgZmRtLCBmZHQsIHJldiwgZGVvLCBldCwgaE1hcCwgd2JpdHMsIHdiaXRzMTYsIGhUcmVlLCBsbiwgbGMsIGNsZW4sIHdmYmxrLCB3YmxrLCBzaGZ0LCBzbGMsIGRmbHQsIGRvcHQsIGRlZmxhdGVTeW5jLCBwYmZdOyB9O1xuLy8gZ3ppcCBleHRyYVxudmFyIGd6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtnemgsIGd6aGwsIHdieXRlcywgY3JjLCBjcmN0XTsgfTtcbi8vIGd1bnppcCBleHRyYVxudmFyIGd1emUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3pzLCBnemxdOyB9O1xuLy8gemxpYiBleHRyYVxudmFyIHpsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bGgsIHdieXRlcywgYWRsZXJdOyB9O1xuLy8gdW56bGliIGV4dHJhXG52YXIgenVsZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt6bHZdOyB9O1xuLy8gcG9zdCBidWZcbnZhciBwYmYgPSBmdW5jdGlvbiAobXNnKSB7IHJldHVybiBwb3N0TWVzc2FnZShtc2csIFttc2cuYnVmZmVyXSk7IH07XG4vLyBnZXQgdThcbnZhciBndTggPSBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBvLnNpemUgJiYgbmV3IHU4KG8uc2l6ZSk7IH07XG4vLyBhc3luYyBoZWxwZXJcbnZhciBjYmlmeSA9IGZ1bmN0aW9uIChkYXQsIG9wdHMsIGZucywgaW5pdCwgaWQsIGNiKSB7XG4gICAgdmFyIHcgPSB3cmtyKGZucywgaW5pdCwgaWQsIGZ1bmN0aW9uIChlcnIsIGRhdCkge1xuICAgICAgICB3LnRlcm1pbmF0ZSgpO1xuICAgICAgICBjYihlcnIsIGRhdCk7XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShbZGF0LCBvcHRzXSwgb3B0cy5jb25zdW1lID8gW2RhdC5idWZmZXJdIDogW10pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHcudGVybWluYXRlKCk7IH07XG59O1xuLy8gYXV0byBzdHJlYW1cbnZhciBhc3RybSA9IGZ1bmN0aW9uIChzdHJtKSB7XG4gICAgc3RybS5vbmRhdGEgPSBmdW5jdGlvbiAoZGF0LCBmaW5hbCkgeyByZXR1cm4gcG9zdE1lc3NhZ2UoW2RhdCwgZmluYWxdLCBbZGF0LmJ1ZmZlcl0pOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHN0cm0ucHVzaChldi5kYXRhWzBdLCBldi5kYXRhWzFdKTsgfTtcbn07XG4vLyBhc3luYyBzdHJlYW0gYXR0YWNoXG52YXIgYXN0cm1pZnkgPSBmdW5jdGlvbiAoZm5zLCBzdHJtLCBvcHRzLCBpbml0LCBpZCkge1xuICAgIHZhciB0O1xuICAgIHZhciB3ID0gd3JrcihmbnMsIGluaXQsIGlkLCBmdW5jdGlvbiAoZXJyLCBkYXQpIHtcbiAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgIHcudGVybWluYXRlKCksIHN0cm0ub25kYXRhLmNhbGwoc3RybSwgZXJyKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZGF0WzFdKVxuICAgICAgICAgICAgICAgIHcudGVybWluYXRlKCk7XG4gICAgICAgICAgICBzdHJtLm9uZGF0YS5jYWxsKHN0cm0sIGVyciwgZGF0WzBdLCBkYXRbMV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdy5wb3N0TWVzc2FnZShvcHRzKTtcbiAgICBzdHJtLnB1c2ggPSBmdW5jdGlvbiAoZCwgZikge1xuICAgICAgICBpZiAodClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICBpZiAoIXN0cm0ub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIHN0cmVhbSBoYW5kbGVyJztcbiAgICAgICAgdy5wb3N0TWVzc2FnZShbZCwgdCA9IGZdLCBbZC5idWZmZXJdKTtcbiAgICB9O1xuICAgIHN0cm0udGVybWluYXRlID0gZnVuY3Rpb24gKCkgeyB3LnRlcm1pbmF0ZSgpOyB9O1xufTtcbi8vIHJlYWQgMiBieXRlc1xudmFyIGIyID0gZnVuY3Rpb24gKGQsIGIpIHsgcmV0dXJuIGRbYl0gfCAoZFtiICsgMV0gPDwgOCk7IH07XG4vLyByZWFkIDQgYnl0ZXNcbnZhciBiNCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiAoZFtiXSB8IChkW2IgKyAxXSA8PCA4KSB8IChkW2IgKyAyXSA8PCAxNikgfCAoZFtiICsgM10gPDwgMjQpKSA+Pj4gMDsgfTtcbnZhciBiOCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiNChkLCBiKSArIChiNChkLCBiICsgNCkgKiA0Mjk0OTY3Mjk2KTsgfTtcbi8vIHdyaXRlIGJ5dGVzXG52YXIgd2J5dGVzID0gZnVuY3Rpb24gKGQsIGIsIHYpIHtcbiAgICBmb3IgKDsgdjsgKytiKVxuICAgICAgICBkW2JdID0gdiwgdiA+Pj49IDg7XG59O1xuLy8gZ3ppcCBoZWFkZXJcbnZhciBnemggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBmbiA9IG8uZmlsZW5hbWU7XG4gICAgY1swXSA9IDMxLCBjWzFdID0gMTM5LCBjWzJdID0gOCwgY1s4XSA9IG8ubGV2ZWwgPCAyID8gNCA6IG8ubGV2ZWwgPT0gOSA/IDIgOiAwLCBjWzldID0gMzsgLy8gYXNzdW1lIFVuaXhcbiAgICBpZiAoby5tdGltZSAhPSAwKVxuICAgICAgICB3Ynl0ZXMoYywgNCwgTWF0aC5mbG9vcihuZXcgRGF0ZShvLm10aW1lIHx8IERhdGUubm93KCkpIC8gMTAwMCkpO1xuICAgIGlmIChmbikge1xuICAgICAgICBjWzNdID0gODtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZm4ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBjW2kgKyAxMF0gPSBmbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbn07XG4vLyBnemlwIGZvb3RlcjogLTggdG8gLTQgPSBDUkMsIC00IHRvIC0wIGlzIGxlbmd0aFxuLy8gZ3ppcCBzdGFydFxudmFyIGd6cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKGRbMF0gIT0gMzEgfHwgZFsxXSAhPSAxMzkgfHwgZFsyXSAhPSA4KVxuICAgICAgICB0aHJvdyAnaW52YWxpZCBnemlwIGRhdGEnO1xuICAgIHZhciBmbGcgPSBkWzNdO1xuICAgIHZhciBzdCA9IDEwO1xuICAgIGlmIChmbGcgJiA0KVxuICAgICAgICBzdCArPSBkWzEwXSB8IChkWzExXSA8PCA4KSArIDI7XG4gICAgZm9yICh2YXIgenMgPSAoZmxnID4+IDMgJiAxKSArIChmbGcgPj4gNCAmIDEpOyB6cyA+IDA7IHpzIC09ICFkW3N0KytdKVxuICAgICAgICA7XG4gICAgcmV0dXJuIHN0ICsgKGZsZyAmIDIpO1xufTtcbi8vIGd6aXAgbGVuZ3RoXG52YXIgZ3psID0gZnVuY3Rpb24gKGQpIHtcbiAgICB2YXIgbCA9IGQubGVuZ3RoO1xuICAgIHJldHVybiAoKGRbbCAtIDRdIHwgZFtsIC0gM10gPDwgOCB8IGRbbCAtIDJdIDw8IDE2KSB8IChkW2wgLSAxXSA8PCAyNCkpID4+PiAwO1xufTtcbi8vIGd6aXAgaGVhZGVyIGxlbmd0aFxudmFyIGd6aGwgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gMTAgKyAoKG8uZmlsZW5hbWUgJiYgKG8uZmlsZW5hbWUubGVuZ3RoICsgMSkpIHx8IDApOyB9O1xuLy8gemxpYiBoZWFkZXJcbnZhciB6bGggPSBmdW5jdGlvbiAoYywgbykge1xuICAgIHZhciBsdiA9IG8ubGV2ZWwsIGZsID0gbHYgPT0gMCA/IDAgOiBsdiA8IDYgPyAxIDogbHYgPT0gOSA/IDMgOiAyO1xuICAgIGNbMF0gPSAxMjAsIGNbMV0gPSAoZmwgPDwgNikgfCAoZmwgPyAoMzIgLSAyICogZmwpIDogMSk7XG59O1xuLy8gemxpYiB2YWxpZFxudmFyIHpsdiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKChkWzBdICYgMTUpICE9IDggfHwgKGRbMF0gPj4+IDQpID4gNyB8fCAoKGRbMF0gPDwgOCB8IGRbMV0pICUgMzEpKVxuICAgICAgICB0aHJvdyAnaW52YWxpZCB6bGliIGRhdGEnO1xuICAgIGlmIChkWzFdICYgMzIpXG4gICAgICAgIHRocm93ICdpbnZhbGlkIHpsaWIgZGF0YTogcHJlc2V0IGRpY3Rpb25hcmllcyBub3Qgc3VwcG9ydGVkJztcbn07XG5mdW5jdGlvbiBBc3luY0NtcFN0cm0ob3B0cywgY2IpIHtcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgcmV0dXJuIG9wdHM7XG59XG4vLyB6bGliIGZvb3RlcjogLTQgdG8gLTAgaXMgQWRsZXIzMlxuLyoqXG4gKiBTdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZsYXRlKG9wdHMsIGNiKSB7XG4gICAgICAgIGlmICghY2IgJiYgdHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLm8gPSBvcHRzIHx8IHt9O1xuICAgIH1cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wID0gZnVuY3Rpb24gKGMsIGYpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEoZG9wdChjLCB0aGlzLm8sIDAsIDAsICFmKSwgZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB0aGlzLmQgPSBmaW5hbDtcbiAgICAgICAgdGhpcy5wKGNodW5rLCBmaW5hbCB8fCBmYWxzZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmbGF0ZTtcbn0oKSk7XG5leHBvcnQgeyBEZWZsYXRlIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgREVGTEFURSBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jRGVmbGF0ZShvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZV07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IERlZmxhdGUoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNik7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0RlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gZGVmbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihkZWZsYXRlU3luYyhldi5kYXRhWzBdLCBldi5kYXRhWzFdKSk7IH0sIDAsIGNiKTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBkYXRhIHdpdGggREVGTEFURSB3aXRob3V0IGFueSB3cmFwcGVyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBkZWZsYXRlZCB2ZXJzaW9uIG9mIHRoZSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZsYXRlU3luYyhkYXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIGRvcHQoZGF0YSwgb3B0cyB8fCB7fSwgMCwgMCk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEluZmxhdGUgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbmZsYXRlKGNiKSB7XG4gICAgICAgIHRoaXMucyA9IHt9O1xuICAgICAgICB0aGlzLnAgPSBuZXcgdTgoMCk7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIEluZmxhdGUucHJvdG90eXBlLmUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhyb3cgJ3N0cmVhbSBmaW5pc2hlZCc7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICB2YXIgbCA9IHRoaXMucC5sZW5ndGg7XG4gICAgICAgIHZhciBuID0gbmV3IHU4KGwgKyBjLmxlbmd0aCk7XG4gICAgICAgIG4uc2V0KHRoaXMucCksIG4uc2V0KGMsIGwpLCB0aGlzLnAgPSBuO1xuICAgIH07XG4gICAgSW5mbGF0ZS5wcm90b3R5cGUuYyA9IGZ1bmN0aW9uIChmaW5hbCkge1xuICAgICAgICB0aGlzLmQgPSB0aGlzLnMuaSA9IGZpbmFsIHx8IGZhbHNlO1xuICAgICAgICB2YXIgYnRzID0gdGhpcy5zLmI7XG4gICAgICAgIHZhciBkdCA9IGluZmx0KHRoaXMucCwgdGhpcy5vLCB0aGlzLnMpO1xuICAgICAgICB0aGlzLm9uZGF0YShzbGMoZHQsIGJ0cywgdGhpcy5zLmIpLCB0aGlzLmQpO1xuICAgICAgICB0aGlzLm8gPSBzbGMoZHQsIHRoaXMucy5iIC0gMzI3NjgpLCB0aGlzLnMuYiA9IHRoaXMuby5sZW5ndGg7XG4gICAgICAgIHRoaXMucCA9IHNsYyh0aGlzLnAsICh0aGlzLnMucCAvIDgpIHwgMCksIHRoaXMucy5wICY9IDc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBpbmZsYXRlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGZpbmFsIGNodW5rXG4gICAgICovXG4gICAgSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdGhpcy5lKGNodW5rKSwgdGhpcy5jKGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEluZmxhdGUgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBpbmZsYXRpb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVmbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBBc3luY0luZmxhdGUoY2IpIHtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICAgICAgYXN0cm1pZnkoW1xuICAgICAgICAgICAgYkluZmx0LFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBJbmZsYXRlXTsgfVxuICAgICAgICBdLCB0aGlzLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RybSA9IG5ldyBJbmZsYXRlKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgNyk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0luZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNJbmZsYXRlIH07XG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHRcbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZihpbmZsYXRlU3luYyhldi5kYXRhWzBdLCBndTgoZXYuZGF0YVsxXSkpKTsgfSwgMSwgY2IpO1xufVxuLyoqXG4gKiBFeHBhbmRzIERFRkxBVEUgZGF0YSB3aXRoIG5vIHdyYXBwZXJcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEsIG91dCk7XG59XG4vLyBiZWZvcmUgeW91IHllbGwgYXQgbWUgZm9yIG5vdCBqdXN0IHVzaW5nIGV4dGVuZHMsIG15IHJlYXNvbiBpcyB0aGF0IFRTIGluaGVyaXRhbmNlIGlzIGhhcmQgdG8gd29ya2VyaXplLlxuLyoqXG4gKiBTdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgR3ppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHemlwKG9wdHMsIGNiKSB7XG4gICAgICAgIHRoaXMuYyA9IGNyYygpO1xuICAgICAgICB0aGlzLmwgPSAwO1xuICAgICAgICB0aGlzLnYgPSAxO1xuICAgICAgICBEZWZsYXRlLmNhbGwodGhpcywgb3B0cywgY2IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBHWklQcGVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIEd6aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIERlZmxhdGUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgR3ppcC5wcm90b3R5cGUucCA9IGZ1bmN0aW9uIChjLCBmKSB7XG4gICAgICAgIHRoaXMuYy5wKGMpO1xuICAgICAgICB0aGlzLmwgKz0gYy5sZW5ndGg7XG4gICAgICAgIHZhciByYXcgPSBkb3B0KGMsIHRoaXMubywgdGhpcy52ICYmIGd6aGwodGhpcy5vKSwgZiAmJiA4LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICBnemgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA4LCB0aGlzLmMuZCgpKSwgd2J5dGVzKHJhdywgcmF3Lmxlbmd0aCAtIDQsIHRoaXMubCk7XG4gICAgICAgIHRoaXMub25kYXRhKHJhdywgZik7XG4gICAgfTtcbiAgICByZXR1cm4gR3ppcDtcbn0oKSk7XG5leHBvcnQgeyBHemlwIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCBjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNHemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFzeW5jR3ppcChvcHRzLCBjYikge1xuICAgICAgICBhc3RybWlmeShbXG4gICAgICAgICAgICBiRGZsdCxcbiAgICAgICAgICAgIGd6ZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFthc3RybSwgRGVmbGF0ZSwgR3ppcF07IH1cbiAgICAgICAgXSwgdGhpcywgQXN5bmNDbXBTdHJtLmNhbGwodGhpcywgb3B0cywgY2IpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzdHJtID0gbmV3IEd6aXAoZXYuZGF0YSk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d6aXA7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNHemlwIH07XG5leHBvcnQgZnVuY3Rpb24gZ3ppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgZ3plLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbZ3ppcFN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoZ3ppcFN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCAyLCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzZXMgZGF0YSB3aXRoIEdaSVBcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGNvbXByZXNzXG4gKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICogQHJldHVybnMgVGhlIGd6aXBwZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ3ppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBjID0gY3JjKCksIGwgPSBkYXRhLmxlbmd0aDtcbiAgICBjLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIGd6aGwob3B0cyksIDgpLCBzID0gZC5sZW5ndGg7XG4gICAgcmV0dXJuIGd6aChkLCBvcHRzKSwgd2J5dGVzKGQsIHMgLSA4LCBjLmQoKSksIHdieXRlcyhkLCBzIC0gNCwgbCksIGQ7XG59XG4vKipcbiAqIFN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEd1bnppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR1VOWklQIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGluZmxhdGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMudiA9IDE7XG4gICAgICAgIEluZmxhdGUuY2FsbCh0aGlzLCBjYik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIEdVTlpJUHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBHdW56aXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIEluZmxhdGUucHJvdG90eXBlLmUuY2FsbCh0aGlzLCBjaHVuayk7XG4gICAgICAgIGlmICh0aGlzLnYpIHtcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5wLmxlbmd0aCA+IDMgPyBnenModGhpcy5wKSA6IDQ7XG4gICAgICAgICAgICBpZiAocyA+PSB0aGlzLnAubGVuZ3RoICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkocyksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgZ3ppcCBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC04KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIEd1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBHdW56aXAgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBHWklQIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jR3VuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIEdVTlpJUCBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jR3VuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIGd1emUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIEd1bnppcF07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgR3VuemlwKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgOSk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY0d1bnppcDtcbn0oKSk7XG5leHBvcnQgeyBBc3luY0d1bnppcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcChkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiSW5mbHQsXG4gICAgICAgIGd1emUsXG4gICAgICAgIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtndW56aXBTeW5jXTsgfVxuICAgIF0sIGZ1bmN0aW9uIChldikgeyByZXR1cm4gcGJmKGd1bnppcFN5bmMoZXYuZGF0YVswXSkpOyB9LCAzLCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgR1pJUCBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBHWklQIGFscmVhZHkgZW5jb2RlcyB0aGUgb3V0cHV0IHNpemUsIHNvIHByb3ZpZGluZyB0aGlzIGRvZXNuJ3Qgc2F2ZSBtZW1vcnkuXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGd1bnppcFN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KGRhdGEuc3ViYXJyYXkoZ3pzKGRhdGEpLCAtOCksIG91dCB8fCBuZXcgdTgoZ3psKGRhdGEpKSk7XG59XG4vKipcbiAqIFN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBabGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFpsaWIob3B0cywgY2IpIHtcbiAgICAgICAgdGhpcy5jID0gYWRsZXIoKTtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgRGVmbGF0ZS5jYWxsKHRoaXMsIG9wdHMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgemxpYmJlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBabGliLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWZsYXRlLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIFpsaWIucHJvdG90eXBlLnAgPSBmdW5jdGlvbiAoYywgZikge1xuICAgICAgICB0aGlzLmMucChjKTtcbiAgICAgICAgdmFyIHJhdyA9IGRvcHQoYywgdGhpcy5vLCB0aGlzLnYgJiYgMiwgZiAmJiA0LCAhZik7XG4gICAgICAgIGlmICh0aGlzLnYpXG4gICAgICAgICAgICB6bGgocmF3LCB0aGlzLm8pLCB0aGlzLnYgPSAwO1xuICAgICAgICBpZiAoZilcbiAgICAgICAgICAgIHdieXRlcyhyYXcsIHJhdy5sZW5ndGggLSA0LCB0aGlzLmMuZCgpKTtcbiAgICAgICAgdGhpcy5vbmRhdGEocmF3LCBmKTtcbiAgICB9O1xuICAgIHJldHVybiBabGliO1xufSgpKTtcbmV4cG9ydCB7IFpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGNvbXByZXNzaW9uXG4gKi9cbnZhciBBc3luY1psaWIgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNabGliKG9wdHMsIGNiKSB7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJEZmx0LFxuICAgICAgICAgICAgemxlLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gW2FzdHJtLCBEZWZsYXRlLCBabGliXTsgfVxuICAgICAgICBdLCB0aGlzLCBBc3luY0NtcFN0cm0uY2FsbCh0aGlzLCBvcHRzLCBjYiksIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgWmxpYihldi5kYXRhKTtcbiAgICAgICAgICAgIG9ubWVzc2FnZSA9IGFzdHJtKHN0cm0pO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBBc3luY1psaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNabGliIH07XG5leHBvcnQgZnVuY3Rpb24gemxpYihkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gY2JpZnkoZGF0YSwgb3B0cywgW1xuICAgICAgICBiRGZsdCxcbiAgICAgICAgemxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbemxpYlN5bmNdOyB9XG4gICAgXSwgZnVuY3Rpb24gKGV2KSB7IHJldHVybiBwYmYoemxpYlN5bmMoZXYuZGF0YVswXSwgZXYuZGF0YVsxXSkpOyB9LCA0LCBjYik7XG59XG4vKipcbiAqIENvbXByZXNzIGRhdGEgd2l0aCBabGliXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBjb21wcmVzc1xuICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSB6bGliLWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gemxpYlN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciBhID0gYWRsZXIoKTtcbiAgICBhLnAoZGF0YSk7XG4gICAgdmFyIGQgPSBkb3B0KGRhdGEsIG9wdHMsIDIsIDQpO1xuICAgIHJldHVybiB6bGgoZCwgb3B0cyksIHdieXRlcyhkLCBkLmxlbmd0aCAtIDQsIGEuZCgpKSwgZDtcbn1cbi8qKlxuICogU3RyZWFtaW5nIFpsaWIgZGVjb21wcmVzc2lvblxuICovXG52YXIgVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBabGliIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgaW5mbGF0ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnpsaWIoY2IpIHtcbiAgICAgICAgdGhpcy52ID0gMTtcbiAgICAgICAgSW5mbGF0ZS5jYWxsKHRoaXMsIGNiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgdW56bGliYmVkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFVuemxpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgSW5mbGF0ZS5wcm90b3R5cGUuZS5jYWxsKHRoaXMsIGNodW5rKTtcbiAgICAgICAgaWYgKHRoaXMudikge1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPCAyICYmICFmaW5hbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnAgPSB0aGlzLnAuc3ViYXJyYXkoMiksIHRoaXMudiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLmxlbmd0aCA8IDQpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgemxpYiBzdHJlYW0nO1xuICAgICAgICAgICAgdGhpcy5wID0gdGhpcy5wLnN1YmFycmF5KDAsIC00KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZWNlc3NhcnkgdG8gcHJldmVudCBUUyBmcm9tIHVzaW5nIHRoZSBjbG9zdXJlIHZhbHVlXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIGZvciB3b3JrZXJpemF0aW9uIHRvIGZ1bmN0aW9uIGNvcnJlY3RseVxuICAgICAgICBJbmZsYXRlLnByb3RvdHlwZS5jLmNhbGwodGhpcywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFVuemxpYjtcbn0oKSk7XG5leHBvcnQgeyBVbnpsaWIgfTtcbi8qKlxuICogQXN5bmNocm9ub3VzIHN0cmVhbWluZyBabGliIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIEFzeW5jVW56bGliID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXN5bmNocm9ub3VzIFpsaWIgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWZsYXRlZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jVW56bGliKGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgICAgIGFzdHJtaWZ5KFtcbiAgICAgICAgICAgIGJJbmZsdCxcbiAgICAgICAgICAgIHp1bGUsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbYXN0cm0sIEluZmxhdGUsIFVuemxpYl07IH1cbiAgICAgICAgXSwgdGhpcywgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cm0gPSBuZXcgVW56bGliKCk7XG4gICAgICAgICAgICBvbm1lc3NhZ2UgPSBhc3RybShzdHJtKTtcbiAgICAgICAgfSwgMTEpO1xuICAgIH1cbiAgICByZXR1cm4gQXN5bmNVbnpsaWI7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnpsaWIgfTtcbmV4cG9ydCBmdW5jdGlvbiB1bnpsaWIoZGF0YSwgb3B0cywgY2IpIHtcbiAgICBpZiAoIWNiKVxuICAgICAgICBjYiA9IG9wdHMsIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGNiICE9ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgcmV0dXJuIGNiaWZ5KGRhdGEsIG9wdHMsIFtcbiAgICAgICAgYkluZmx0LFxuICAgICAgICB6dWxlLFxuICAgICAgICBmdW5jdGlvbiAoKSB7IHJldHVybiBbdW56bGliU3luY107IH1cbiAgICBdLCBmdW5jdGlvbiAoZXYpIHsgcmV0dXJuIHBiZih1bnpsaWJTeW5jKGV2LmRhdGFbMF0sIGd1OChldi5kYXRhWzFdKSkpOyB9LCA1LCBjYik7XG59XG4vKipcbiAqIEV4cGFuZHMgWmxpYiBkYXRhXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBkZWNvbXByZXNzXG4gKiBAcGFyYW0gb3V0IFdoZXJlIHRvIHdyaXRlIHRoZSBkYXRhLiBTYXZlcyBtZW1vcnkgaWYgeW91IGtub3cgdGhlIGRlY29tcHJlc3NlZCBzaXplIGFuZCBwcm92aWRlIGFuIG91dHB1dCBidWZmZXIgb2YgdGhhdCBsZW5ndGguXG4gKiBAcmV0dXJucyBUaGUgZGVjb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemxpYlN5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIGluZmx0KCh6bHYoZGF0YSksIGRhdGEuc3ViYXJyYXkoMiwgLTQpKSwgb3V0KTtcbn1cbi8vIERlZmF1bHQgYWxnb3JpdGhtIGZvciBjb21wcmVzc2lvbiAodXNlZCBiZWNhdXNlIGhhdmluZyBhIGtub3duIG91dHB1dCBzaXplIGFsbG93cyBmYXN0ZXIgZGVjb21wcmVzc2lvbilcbmV4cG9ydCB7IGd6aXAgYXMgY29tcHJlc3MsIEFzeW5jR3ppcCBhcyBBc3luY0NvbXByZXNzIH07XG4vLyBEZWZhdWx0IGFsZ29yaXRobSBmb3IgY29tcHJlc3Npb24gKHVzZWQgYmVjYXVzZSBoYXZpbmcgYSBrbm93biBvdXRwdXQgc2l6ZSBhbGxvd3MgZmFzdGVyIGRlY29tcHJlc3Npb24pXG5leHBvcnQgeyBnemlwU3luYyBhcyBjb21wcmVzc1N5bmMsIEd6aXAgYXMgQ29tcHJlc3MgfTtcbi8qKlxuICogU3RyZWFtaW5nIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRlY29tcHJlc3Npb25cbiAqL1xudmFyIERlY29tcHJlc3MgPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlY29tcHJlc3Npb24gc3RyZWFtXG4gICAgICogQHBhcmFtIGNiIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW5ldmVyIGRhdGEgaXMgZGVjb21wcmVzc2VkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb21wcmVzcyhjYikge1xuICAgICAgICB0aGlzLkcgPSBHdW56aXA7XG4gICAgICAgIHRoaXMuSSA9IEluZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IFVuemxpYjtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSBjYjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVjb21wcmVzc2VkXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29tcHJlc3MucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gc3RyZWFtIGhhbmRsZXInO1xuICAgICAgICBpZiAoIXRoaXMucykge1xuICAgICAgICAgICAgaWYgKHRoaXMucCAmJiB0aGlzLnAubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBuZXcgdTgodGhpcy5wLmxlbmd0aCArIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbi5zZXQodGhpcy5wKSwgbi5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMucCA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKHRoaXMucC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHsgX3RoaXNfMS5vbmRhdGEuYXBwbHkoX3RoaXNfMSwgYXJndW1lbnRzKTsgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnMgPSAodGhpcy5wWzBdID09IDMxICYmIHRoaXMucFsxXSA9PSAxMzkgJiYgdGhpcy5wWzJdID09IDgpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IHRoaXMuRyhjYilcbiAgICAgICAgICAgICAgICAgICAgOiAoKHRoaXMucFswXSAmIDE1KSAhPSA4IHx8ICh0aGlzLnBbMF0gPj4gNCkgPiA3IHx8ICgodGhpcy5wWzBdIDw8IDggfCB0aGlzLnBbMV0pICUgMzEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgdGhpcy5JKGNiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgdGhpcy5aKGNiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnMucHVzaCh0aGlzLnAsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucy5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVjb21wcmVzcztcbn0oKSk7XG5leHBvcnQgeyBEZWNvbXByZXNzIH07XG4vKipcbiAqIEFzeW5jaHJvbm91cyBzdHJlYW1pbmcgR1pJUCwgWmxpYiwgb3IgcmF3IERFRkxBVEUgZGVjb21wcmVzc2lvblxuICovXG52YXIgQXN5bmNEZWNvbXByZXNzID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFzeW5jaHJvbm91cyBkZWNvbXByZXNzaW9uIHN0cmVhbVxuICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvbXByZXNzZWRcbiAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNEZWNvbXByZXNzKGNiKSB7XG4gICAgICAgIHRoaXMuRyA9IEFzeW5jR3VuemlwO1xuICAgICAgICB0aGlzLkkgPSBBc3luY0luZmxhdGU7XG4gICAgICAgIHRoaXMuWiA9IEFzeW5jVW56bGliO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvbXByZXNzZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBEZWNvbXByZXNzLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGZpbmFsKTtcbiAgICB9O1xuICAgIHJldHVybiBBc3luY0RlY29tcHJlc3M7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNEZWNvbXByZXNzIH07XG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzcyhkYXRhLCBvcHRzLCBjYikge1xuICAgIGlmICghY2IpXG4gICAgICAgIGNiID0gb3B0cywgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY2IgIT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICByZXR1cm4gKGRhdGFbMF0gPT0gMzEgJiYgZGF0YVsxXSA9PSAxMzkgJiYgZGF0YVsyXSA9PSA4KVxuICAgICAgICA/IGd1bnppcChkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZShkYXRhLCBvcHRzLCBjYilcbiAgICAgICAgICAgIDogdW56bGliKGRhdGEsIG9wdHMsIGNiKTtcbn1cbi8qKlxuICogRXhwYW5kcyBjb21wcmVzc2VkIEdaSVAsIFpsaWIsIG9yIHJhdyBERUZMQVRFIGRhdGEsIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBmb3JtYXRcbiAqIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIGRlY29tcHJlc3NcbiAqIEBwYXJhbSBvdXQgV2hlcmUgdG8gd3JpdGUgdGhlIGRhdGEuIFNhdmVzIG1lbW9yeSBpZiB5b3Uga25vdyB0aGUgZGVjb21wcmVzc2VkIHNpemUgYW5kIHByb3ZpZGUgYW4gb3V0cHV0IGJ1ZmZlciBvZiB0aGF0IGxlbmd0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgdmVyc2lvbiBvZiB0aGUgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb21wcmVzc1N5bmMoZGF0YSwgb3V0KSB7XG4gICAgcmV0dXJuIChkYXRhWzBdID09IDMxICYmIGRhdGFbMV0gPT0gMTM5ICYmIGRhdGFbMl0gPT0gOClcbiAgICAgICAgPyBndW56aXBTeW5jKGRhdGEsIG91dClcbiAgICAgICAgOiAoKGRhdGFbMF0gJiAxNSkgIT0gOCB8fCAoZGF0YVswXSA+PiA0KSA+IDcgfHwgKChkYXRhWzBdIDw8IDggfCBkYXRhWzFdKSAlIDMxKSlcbiAgICAgICAgICAgID8gaW5mbGF0ZVN5bmMoZGF0YSwgb3V0KVxuICAgICAgICAgICAgOiB1bnpsaWJTeW5jKGRhdGEsIG91dCk7XG59XG4vLyBmbGF0dGVuIGEgZGlyZWN0b3J5IHN0cnVjdHVyZVxudmFyIGZsdG4gPSBmdW5jdGlvbiAoZCwgcCwgdCwgbykge1xuICAgIGZvciAodmFyIGsgaW4gZCkge1xuICAgICAgICB2YXIgdmFsID0gZFtrXSwgbiA9IHAgKyBrO1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgdTgpXG4gICAgICAgICAgICB0W25dID0gW3ZhbCwgb107XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSlcbiAgICAgICAgICAgIHRbbl0gPSBbdmFsWzBdLCBtcmcobywgdmFsWzFdKV07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZsdG4odmFsLCBuICsgJy8nLCB0LCBvKTtcbiAgICB9XG59O1xuLy8gdGV4dCBlbmNvZGVyXG52YXIgdGUgPSB0eXBlb2YgVGV4dEVuY29kZXIgIT0gJ3VuZGVmaW5lZCcgJiYgLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8vIHRleHQgZGVjb2RlclxudmFyIHRkID0gdHlwZW9mIFRleHREZWNvZGVyICE9ICd1bmRlZmluZWQnICYmIC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG4vLyB0ZXh0IGRlY29kZXIgc3RyZWFtXG52YXIgdGRzID0gMDtcbnRyeSB7XG4gICAgdGQuZGVjb2RlKGV0LCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB0ZHMgPSAxO1xufVxuY2F0Y2ggKGUpIHsgfVxuLy8gZGVjb2RlIFVURjhcbnZhciBkdXRmOCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgZm9yICh2YXIgciA9ICcnLCBpID0gMDs7KSB7XG4gICAgICAgIHZhciBjID0gZFtpKytdO1xuICAgICAgICB2YXIgZWIgPSAoYyA+IDEyNykgKyAoYyA+IDIyMykgKyAoYyA+IDIzOSk7XG4gICAgICAgIGlmIChpICsgZWIgPiBkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBbciwgc2xjKGQsIGkgLSAxKV07XG4gICAgICAgIGlmICghZWIpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIGVsc2UgaWYgKGViID09IDMpIHtcbiAgICAgICAgICAgIGMgPSAoKGMgJiAxNSkgPDwgMTggfCAoZFtpKytdICYgNjMpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSkgLSA2NTUzNixcbiAgICAgICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoYyA+PiAxMCksIDU2MzIwIHwgKGMgJiAxMDIzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWIgJiAxKVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMzEpIDw8IDYgfCAoZFtpKytdICYgNjMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKGRbaSsrXSAmIDYzKSA8PCA2IHwgKGRbaSsrXSAmIDYzKSk7XG4gICAgfVxufTtcbi8qKlxuICogU3RyZWFtaW5nIFVURi04IGRlY29kaW5nXG4gKi9cbnZhciBEZWNvZGVVVEY4ID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBVVEYtOCBkZWNvZGluZyBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgZGF0YSBpcyBkZWNvZGVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVjb2RlVVRGOChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICBpZiAodGRzKVxuICAgICAgICAgICAgdGhpcy50ID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBkZWNvZGVkIGZyb20gVVRGLTggYmluYXJ5XG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIERlY29kZVVURjgucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5vbmRhdGEpXG4gICAgICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgICAgICBmaW5hbCA9ICEhZmluYWw7XG4gICAgICAgIGlmICh0aGlzLnQpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKHRoaXMudC5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLCBmaW5hbCk7XG4gICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50LmRlY29kZSgpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucClcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZGF0ID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICBkYXQuc2V0KHRoaXMucCk7XG4gICAgICAgIGRhdC5zZXQoY2h1bmssIHRoaXMucC5sZW5ndGgpO1xuICAgICAgICB2YXIgX2EgPSBkdXRmOChkYXQpLCBjaCA9IF9hWzBdLCBucCA9IF9hWzFdO1xuICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgIGlmIChucC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2ludmFsaWQgdXRmLTggZGF0YSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucCA9IG5wO1xuICAgICAgICB0aGlzLm9uZGF0YShjaCwgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIERlY29kZVVURjg7XG59KCkpO1xuZXhwb3J0IHsgRGVjb2RlVVRGOCB9O1xuLyoqXG4gKiBTdHJlYW1pbmcgVVRGLTggZW5jb2RpbmdcbiAqL1xudmFyIEVuY29kZVVURjggPSAvKiNfX1BVUkVfXyovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFVURi04IGRlY29kaW5nIHN0cmVhbVxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGlzIGVuY29kZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFbmNvZGVVVEY4KGNiKSB7XG4gICAgICAgIHRoaXMub25kYXRhID0gY2I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIGNodW5rIHRvIGJlIGVuY29kZWQgdG8gVVRGLThcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIHN0cmluZyBkYXRhIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgRW5jb2RlVVRGOC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9uZGF0YSlcbiAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgdGhpcy5vbmRhdGEoc3RyVG9VOChjaHVuayksIHRoaXMuZCA9IGZpbmFsIHx8IGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiBFbmNvZGVVVEY4O1xufSgpKTtcbmV4cG9ydCB7IEVuY29kZVVURjggfTtcbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkgZm9yIHVzZSB3aXRoIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gbWV0aG9kc1xuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZGVjb2RpbmcgYSBiaW5hcnkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHN0cmluZyBlbmNvZGVkIGluIFVURi04L0xhdGluLTEgYmluYXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJUb1U4KHN0ciwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgYXJfMSA9IG5ldyB1OChzdHIubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBhcl8xW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHJldHVybiBhcl8xO1xuICAgIH1cbiAgICBpZiAodGUpXG4gICAgICAgIHJldHVybiB0ZS5lbmNvZGUoc3RyKTtcbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGFyID0gbmV3IHU4KHN0ci5sZW5ndGggKyAoc3RyLmxlbmd0aCA+PiAxKSk7XG4gICAgdmFyIGFpID0gMDtcbiAgICB2YXIgdyA9IGZ1bmN0aW9uICh2KSB7IGFyW2FpKytdID0gdjsgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICBpZiAoYWkgKyA1ID4gYXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbiA9IG5ldyB1OChhaSArIDggKyAoKGwgLSBpKSA8PCAxKSk7XG4gICAgICAgICAgICBuLnNldChhcik7XG4gICAgICAgICAgICBhciA9IG47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjggfHwgbGF0aW4xKVxuICAgICAgICAgICAgdyhjKTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgICB3KDE5MiB8IChjID4+IDYpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2UgaWYgKGMgPiA1NTI5NSAmJiBjIDwgNTczNDQpXG4gICAgICAgICAgICBjID0gNjU1MzYgKyAoYyAmIDEwMjMgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKSxcbiAgICAgICAgICAgICAgICB3KDI0MCB8IChjID4+IDE4KSksIHcoMTI4IHwgKChjID4+IDEyKSAmIDYzKSksIHcoMTI4IHwgKChjID4+IDYpICYgNjMpKSwgdygxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHcoMjI0IHwgKGMgPj4gMTIpKSwgdygxMjggfCAoKGMgPj4gNikgJiA2MykpLCB3KDEyOCB8IChjICYgNjMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNsYyhhciwgMCwgYWkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVpbnQ4QXJyYXkgdG8gYSBzdHJpbmdcbiAqIEBwYXJhbSBkYXQgVGhlIGRhdGEgdG8gZGVjb2RlIHRvIHN0cmluZ1xuICogQHBhcmFtIGxhdGluMSBXaGV0aGVyIG9yIG5vdCB0byBpbnRlcnByZXQgdGhlIGRhdGEgYXMgTGF0aW4tMS4gVGhpcyBzaG91bGRcbiAqICAgICAgICAgICAgICAgbm90IG5lZWQgdG8gYmUgdHJ1ZSB1bmxlc3MgZW5jb2RpbmcgdG8gYmluYXJ5IHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBVVEYtOC9MYXRpbi0xIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyRnJvbVU4KGRhdCwgbGF0aW4xKSB7XG4gICAgaWYgKGxhdGluMSkge1xuICAgICAgICB2YXIgciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdC5sZW5ndGg7IGkgKz0gMTYzODQpXG4gICAgICAgICAgICByICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0LnN1YmFycmF5KGksIGkgKyAxNjM4NCkpO1xuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodGQpXG4gICAgICAgIHJldHVybiB0ZC5kZWNvZGUoZGF0KTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIF9hID0gZHV0ZjgoZGF0KSwgb3V0ID0gX2FbMF0sIGV4dCA9IF9hWzFdO1xuICAgICAgICBpZiAoZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93ICdpbnZhbGlkIHV0Zi04IGRhdGEnO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbn1cbjtcbi8vIGRlZmxhdGUgYml0IGZsYWdcbnZhciBkYmYgPSBmdW5jdGlvbiAobCkgeyByZXR1cm4gbCA9PSAxID8gMyA6IGwgPCA2ID8gMiA6IGwgPT0gOSA/IDEgOiAwOyB9O1xuLy8gc2tpcCBsb2NhbCB6aXAgaGVhZGVyXG52YXIgc2x6aCA9IGZ1bmN0aW9uIChkLCBiKSB7IHJldHVybiBiICsgMzAgKyBiMihkLCBiICsgMjYpICsgYjIoZCwgYiArIDI4KTsgfTtcbi8vIHJlYWQgemlwIGhlYWRlclxudmFyIHpoID0gZnVuY3Rpb24gKGQsIGIsIHopIHtcbiAgICB2YXIgZm5sID0gYjIoZCwgYiArIDI4KSwgZm4gPSBzdHJGcm9tVTgoZC5zdWJhcnJheShiICsgNDYsIGIgKyA0NiArIGZubCksICEoYjIoZCwgYiArIDgpICYgMjA0OCkpLCBlcyA9IGIgKyA0NiArIGZubCwgYnMgPSBiNChkLCBiICsgMjApO1xuICAgIHZhciBfYSA9IHogJiYgYnMgPT0gNDI5NDk2NzI5NSA/IHo2NGUoZCwgZXMpIDogW2JzLCBiNChkLCBiICsgMjQpLCBiNChkLCBiICsgNDIpXSwgc2MgPSBfYVswXSwgc3UgPSBfYVsxXSwgb2ZmID0gX2FbMl07XG4gICAgcmV0dXJuIFtiMihkLCBiICsgMTApLCBzYywgc3UsIGZuLCBlcyArIGIyKGQsIGIgKyAzMCkgKyBiMihkLCBiICsgMzIpLCBvZmZdO1xufTtcbi8vIHJlYWQgemlwNjQgZXh0cmEgZmllbGRcbnZhciB6NjRlID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKDsgYjIoZCwgYikgIT0gMTsgYiArPSA0ICsgYjIoZCwgYiArIDIpKVxuICAgICAgICA7XG4gICAgcmV0dXJuIFtiOChkLCBiICsgMTIpLCBiOChkLCBiICsgNCksIGI4KGQsIGIgKyAyMCldO1xufTtcbi8vIGV4dHJhIGZpZWxkIGxlbmd0aFxudmFyIGV4ZmwgPSBmdW5jdGlvbiAoZXgpIHtcbiAgICB2YXIgbGUgPSAwO1xuICAgIGlmIChleCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgbCA9IGV4W2tdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsID4gNjU1MzUpXG4gICAgICAgICAgICAgICAgdGhyb3cgJ2V4dHJhIGZpZWxkIHRvbyBsb25nJztcbiAgICAgICAgICAgIGxlICs9IGwgKyA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZTtcbn07XG4vLyB3cml0ZSB6aXAgaGVhZGVyXG52YXIgd3poID0gZnVuY3Rpb24gKGQsIGIsIGYsIGZuLCB1LCBjLCBjZSwgY28pIHtcbiAgICB2YXIgZmwgPSBmbi5sZW5ndGgsIGV4ID0gZi5leHRyYSwgY29sID0gY28gJiYgY28ubGVuZ3RoO1xuICAgIHZhciBleGwgPSBleGZsKGV4KTtcbiAgICB3Ynl0ZXMoZCwgYiwgY2UgIT0gbnVsbCA/IDB4MjAxNEI1MCA6IDB4NDAzNEI1MCksIGIgKz0gNDtcbiAgICBpZiAoY2UgIT0gbnVsbClcbiAgICAgICAgZFtiKytdID0gMjAsIGRbYisrXSA9IGYub3M7XG4gICAgZFtiXSA9IDIwLCBiICs9IDI7IC8vIHNwZWMgY29tcGxpYW5jZT8gd2hhdCdzIHRoYXQ/XG4gICAgZFtiKytdID0gKGYuZmxhZyA8PCAxKSB8IChjID09IG51bGwgJiYgOCksIGRbYisrXSA9IHUgJiYgODtcbiAgICBkW2IrK10gPSBmLmNvbXByZXNzaW9uICYgMjU1LCBkW2IrK10gPSBmLmNvbXByZXNzaW9uID4+IDg7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUoZi5tdGltZSA9PSBudWxsID8gRGF0ZS5ub3coKSA6IGYubXRpbWUpLCB5ID0gZHQuZ2V0RnVsbFllYXIoKSAtIDE5ODA7XG4gICAgaWYgKHkgPCAwIHx8IHkgPiAxMTkpXG4gICAgICAgIHRocm93ICdkYXRlIG5vdCBpbiByYW5nZSAxOTgwLTIwOTknO1xuICAgIHdieXRlcyhkLCBiLCAoeSA8PCAyNSkgfCAoKGR0LmdldE1vbnRoKCkgKyAxKSA8PCAyMSkgfCAoZHQuZ2V0RGF0ZSgpIDw8IDE2KSB8IChkdC5nZXRIb3VycygpIDw8IDExKSB8IChkdC5nZXRNaW51dGVzKCkgPDwgNSkgfCAoZHQuZ2V0U2Vjb25kcygpID4+PiAxKSksIGIgKz0gNDtcbiAgICBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgIHdieXRlcyhkLCBiLCBmLmNyYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNCwgYyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgOCwgZi5zaXplKTtcbiAgICB9XG4gICAgd2J5dGVzKGQsIGIgKyAxMiwgZmwpO1xuICAgIHdieXRlcyhkLCBiICsgMTQsIGV4bCksIGIgKz0gMTY7XG4gICAgaWYgKGNlICE9IG51bGwpIHtcbiAgICAgICAgd2J5dGVzKGQsIGIsIGNvbCk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgNiwgZi5hdHRycyk7XG4gICAgICAgIHdieXRlcyhkLCBiICsgMTAsIGNlKSwgYiArPSAxNDtcbiAgICB9XG4gICAgZC5zZXQoZm4sIGIpO1xuICAgIGIgKz0gZmw7XG4gICAgaWYgKGV4bCkge1xuICAgICAgICBmb3IgKHZhciBrIGluIGV4KSB7XG4gICAgICAgICAgICB2YXIgZXhmID0gZXhba10sIGwgPSBleGYubGVuZ3RoO1xuICAgICAgICAgICAgd2J5dGVzKGQsIGIsICtrKTtcbiAgICAgICAgICAgIHdieXRlcyhkLCBiICsgMiwgbCk7XG4gICAgICAgICAgICBkLnNldChleGYsIGIgKyA0KSwgYiArPSA0ICsgbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sKVxuICAgICAgICBkLnNldChjbywgYiksIGIgKz0gY29sO1xuICAgIHJldHVybiBiO1xufTtcbi8vIHdyaXRlIHppcCBmb290ZXIgKGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSlcbnZhciB3emYgPSBmdW5jdGlvbiAobywgYiwgYywgZCwgZSkge1xuICAgIHdieXRlcyhvLCBiLCAweDYwNTRCNTApOyAvLyBza2lwIGRpc2tcbiAgICB3Ynl0ZXMobywgYiArIDgsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTAsIGMpO1xuICAgIHdieXRlcyhvLCBiICsgMTIsIGQpO1xuICAgIHdieXRlcyhvLCBiICsgMTYsIGUpO1xufTtcbi8qKlxuICogQSBwYXNzLXRocm91Z2ggc3RyZWFtIHRvIGtlZXAgZGF0YSB1bmNvbXByZXNzZWQgaW4gYSBaSVAgYXJjaGl2ZS5cbiAqL1xudmFyIFppcFBhc3NUaHJvdWdoID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBwYXNzLXRocm91Z2ggc3RyZWFtIHRoYXQgY2FuIGJlIGFkZGVkIHRvIFpJUCBhcmNoaXZlc1xuICAgICAqIEBwYXJhbSBmaWxlbmFtZSBUaGUgZmlsZW5hbWUgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkYXRhIHN0cmVhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcFBhc3NUaHJvdWdoKGZpbGVuYW1lKSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5jID0gY3JjKCk7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgYSBjaHVuayBhbmQgcHVzaGVzIHRvIHRoZSBvdXRwdXQgc3RyZWFtLiBZb3UgY2FuIG92ZXJyaWRlIHRoaXNcbiAgICAgKiBtZXRob2QgaW4gYSBzdWJjbGFzcyBmb3IgY3VzdG9tIGJlaGF2aW9yLCBidXQgYnkgZGVmYXVsdCB0aGlzIHBhc3Nlc1xuICAgICAqIHRoZSBkYXRhIHRocm91Z2guIFlvdSBtdXN0IGNhbGwgdGhpcy5vbmRhdGEoZXJyLCBjaHVuaywgZmluYWwpIGF0IHNvbWVcbiAgICAgKiBwb2ludCBpbiB0aGlzIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHByb2Nlc3NcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoY2h1bmssIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSBhZGRlZC4gSWYgeW91IGFyZSBzdWJjbGFzc2luZyB0aGlzIHdpdGggYSBjdXN0b21cbiAgICAgKiBjb21wcmVzc2lvbiBhbGdvcml0aG0sIG5vdGUgdGhhdCB5b3UgbXVzdCBwdXNoIGRhdGEgZnJvbSB0aGUgc291cmNlXG4gICAgICogZmlsZSBvbmx5LCBwcmUtY29tcHJlc3Npb24uXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBwdXNoXG4gICAgICogQHBhcmFtIGZpbmFsIFdoZXRoZXIgdGhpcyBpcyB0aGUgbGFzdCBjaHVua1xuICAgICAqL1xuICAgIFppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBpZiAoIXRoaXMub25kYXRhKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrIC0gYWRkIHRvIFpJUCBhcmNoaXZlIGJlZm9yZSBwdXNoaW5nJztcbiAgICAgICAgdGhpcy5jLnAoY2h1bmspO1xuICAgICAgICB0aGlzLnNpemUgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBpZiAoZmluYWwpXG4gICAgICAgICAgICB0aGlzLmNyYyA9IHRoaXMuYy5kKCk7XG4gICAgICAgIHRoaXMucHJvY2VzcyhjaHVuaywgZmluYWwgfHwgZmFsc2UpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFppcFBhc3NUaHJvdWdoIH07XG4vLyBJIGRvbid0IGV4dGVuZCBiZWNhdXNlIFR5cGVTY3JpcHQgZXh0ZW5zaW9uIGFkZHMgMWtCIG9mIHJ1bnRpbWUgYmxvYXRcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlcy4gUHJlZmVyIHVzaW5nIEFzeW5jWmlwRGVmbGF0ZVxuICogZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICovXG52YXIgWmlwRGVmbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBzdHJlYW0gdGhhdCBjYW4gYmUgYWRkZWQgdG8gWklQIGFyY2hpdmVzXG4gICAgICogQHBhcmFtIGZpbGVuYW1lIFRoZSBmaWxlbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRhdGEgc3RyZWFtXG4gICAgICogQHBhcmFtIG9wdHMgVGhlIGNvbXByZXNzaW9uIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBaaXBEZWZsYXRlKGZpbGVuYW1lLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRzKVxuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5jYWxsKHRoaXMsIGZpbGVuYW1lKTtcbiAgICAgICAgdGhpcy5kID0gbmV3IERlZmxhdGUob3B0cywgZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuZmxhZyA9IGRiZihvcHRzLmxldmVsKTtcbiAgICB9XG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZC5wdXNoKGNodW5rLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIG51bGwsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgWmlwRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2gucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcERlZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgWmlwRGVmbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgQXN5bmNaaXBEZWZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIHN0cmVhbSB0aGF0IGNhbiBiZSBhZGRlZCB0byBaSVAgYXJjaGl2ZXNcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWUgVGhlIGZpbGVuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZGF0YSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gb3B0cyBUaGUgY29tcHJlc3Npb24gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFzeW5jWmlwRGVmbGF0ZShmaWxlbmFtZSwgb3B0cykge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICghb3B0cylcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgWmlwUGFzc1Rocm91Z2guY2FsbCh0aGlzLCBmaWxlbmFtZSk7XG4gICAgICAgIHRoaXMuZCA9IG5ldyBBc3luY0RlZmxhdGUob3B0cywgZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb24gPSA4O1xuICAgICAgICB0aGlzLmZsYWcgPSBkYmYob3B0cy5sZXZlbCk7XG4gICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5kLnRlcm1pbmF0ZTtcbiAgICB9XG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICB0aGlzLmQucHVzaChjaHVuaywgZmluYWwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgY2h1bmsgdG8gYmUgZGVmbGF0ZWRcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKiBAcGFyYW0gZmluYWwgV2hldGhlciB0aGlzIGlzIHRoZSBsYXN0IGNodW5rXG4gICAgICovXG4gICAgQXN5bmNaaXBEZWZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBmaW5hbCkge1xuICAgICAgICBaaXBQYXNzVGhyb3VnaC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBmaW5hbCk7XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNaaXBEZWZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IEFzeW5jWmlwRGVmbGF0ZSB9O1xuLy8gVE9ETzogQmV0dGVyIHRyZWUgc2hha2luZ1xuLyoqXG4gKiBBIHppcHBhYmxlIGFyY2hpdmUgdG8gd2hpY2ggZmlsZXMgY2FuIGluY3JlbWVudGFsbHkgYmUgYWRkZWRcbiAqL1xudmFyIFppcCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IFpJUCBhcmNoaXZlIHRvIHdoaWNoIGZpbGVzIGNhbiBiZSBhZGRlZFxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgdG8gY2FsbCB3aGVuZXZlciBkYXRhIGZvciB0aGUgZ2VuZXJhdGVkIFpJUCBhcmNoaXZlXG4gICAgICogICAgICAgICAgIGlzIGF2YWlsYWJsZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFppcChjYikge1xuICAgICAgICB0aGlzLm9uZGF0YSA9IGNiO1xuICAgICAgICB0aGlzLnUgPSBbXTtcbiAgICAgICAgdGhpcy5kID0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZpbGUgdG8gdGhlIFpJUCBhcmNoaXZlXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIGZpbGUgc3RyZWFtIHRvIGFkZFxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kICYgMilcbiAgICAgICAgICAgIHRocm93ICdzdHJlYW0gZmluaXNoZWQnO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZmlsZS5maWxlbmFtZSksIGZsID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBmaWxlLmNvbW1lbnQsIG8gPSBjb20gJiYgc3RyVG9VOChjb20pO1xuICAgICAgICB2YXIgdSA9IGZsICE9IGZpbGUuZmlsZW5hbWUubGVuZ3RoIHx8IChvICYmIChjb20ubGVuZ3RoICE9IG8ubGVuZ3RoKSk7XG4gICAgICAgIHZhciBobCA9IGZsICsgZXhmbChmaWxlLmV4dHJhKSArIDMwO1xuICAgICAgICBpZiAoZmwgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBoZWFkZXIgPSBuZXcgdTgoaGwpO1xuICAgICAgICB3emgoaGVhZGVyLCAwLCBmaWxlLCBmLCB1KTtcbiAgICAgICAgdmFyIGNoa3MgPSBbaGVhZGVyXTtcbiAgICAgICAgdmFyIHBBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNoa3NfMSA9IGNoa3M7IF9pIDwgY2hrc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjaGsgPSBjaGtzXzFbX2ldO1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGNoaywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hrcyA9IFtdO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdHIgPSB0aGlzLmQ7XG4gICAgICAgIHRoaXMuZCA9IDA7XG4gICAgICAgIHZhciBpbmQgPSB0aGlzLnUubGVuZ3RoO1xuICAgICAgICB2YXIgdWYgPSBtcmcoZmlsZSwge1xuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIHU6IHUsXG4gICAgICAgICAgICBvOiBvLFxuICAgICAgICAgICAgdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChmaWxlLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZS50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgICAgIGlmICh0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnh0ID0gX3RoaXNfMS51W2luZCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobnh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbnh0LnIoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5kID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsID0gMDtcbiAgICAgICAgZmlsZS5vbmRhdGEgPSBmdW5jdGlvbiAoZXJyLCBkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEoZXJyLCBkYXQsIGZpbmFsKTtcbiAgICAgICAgICAgICAgICBfdGhpc18xLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2wgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaGtzLnB1c2goZGF0KTtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRkID0gbmV3IHU4KDE2KTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCAwLCAweDgwNzRCNTApO1xuICAgICAgICAgICAgICAgICAgICB3Ynl0ZXMoZGQsIDQsIGZpbGUuY3JjKTtcbiAgICAgICAgICAgICAgICAgICAgd2J5dGVzKGRkLCA4LCBjbCk7XG4gICAgICAgICAgICAgICAgICAgIHdieXRlcyhkZCwgMTIsIGZpbGUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoa3MucHVzaChkZCk7XG4gICAgICAgICAgICAgICAgICAgIHVmLmMgPSBjbCwgdWYuYiA9IGhsICsgY2wgKyAxNiwgdWYuY3JjID0gZmlsZS5jcmMsIHVmLnNpemUgPSBmaWxlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmLnIoKTtcbiAgICAgICAgICAgICAgICAgICAgdHIgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0cilcbiAgICAgICAgICAgICAgICAgICAgcEFsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnUucHVzaCh1Zik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbmRzIHRoZSBwcm9jZXNzIG9mIGFkZGluZyBmaWxlcyBhbmQgcHJlcGFyZXMgdG8gZW1pdCB0aGUgZmluYWwgY2h1bmtzLlxuICAgICAqIFRoaXMgKm11c3QqIGJlIGNhbGxlZCBhZnRlciBhZGRpbmcgYWxsIGRlc2lyZWQgZmlsZXMgZm9yIHRoZSByZXN1bHRpbmdcbiAgICAgKiBaSVAgZmlsZSB0byB3b3JrIHByb3Blcmx5LlxuICAgICAqL1xuICAgIFppcC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXNfMSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmQgJiAyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGluZyc7XG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kKVxuICAgICAgICAgICAgdGhpcy5lKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMudS5wdXNoKHtcbiAgICAgICAgICAgICAgICByOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKF90aGlzXzEuZCAmIDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpc18xLnUuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNfMS5lKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0OiBmdW5jdGlvbiAoKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLmQgPSAzO1xuICAgIH07XG4gICAgWmlwLnByb3RvdHlwZS5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnQgPSAwLCBsID0gMCwgdGwgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy51OyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfYVtfaV07XG4gICAgICAgICAgICB0bCArPSA0NiArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpICsgKGYubyA/IGYuby5sZW5ndGggOiAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0ID0gbmV3IHU4KHRsICsgMjIpO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gdGhpcy51OyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGYgPSBfY1tfYl07XG4gICAgICAgICAgICB3emgob3V0LCBidCwgZiwgZi5mLCBmLnUsIGYuYywgbCwgZi5vKTtcbiAgICAgICAgICAgIGJ0ICs9IDQ2ICsgZi5mLmxlbmd0aCArIGV4ZmwoZi5leHRyYSkgKyAoZi5vID8gZi5vLmxlbmd0aCA6IDApLCBsICs9IGYuYjtcbiAgICAgICAgfVxuICAgICAgICB3emYob3V0LCBidCwgdGhpcy51Lmxlbmd0aCwgdGwsIGwpO1xuICAgICAgICB0aGlzLm9uZGF0YShudWxsLCBvdXQsIHRydWUpO1xuICAgICAgICB0aGlzLmQgPSAyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gdGVybWluYXRlIGFueSBpbnRlcm5hbCB3b3JrZXJzIHVzZWQgYnkgdGhlIHN0cmVhbS4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIGFkZCgpIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBaaXAucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMudTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBmID0gX2FbX2ldO1xuICAgICAgICAgICAgZi50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kID0gMjtcbiAgICB9O1xuICAgIHJldHVybiBaaXA7XG59KCkpO1xuZXhwb3J0IHsgWmlwIH07XG5leHBvcnQgZnVuY3Rpb24gemlwKGRhdGEsIG9wdHMsIGNiKSB7XG4gICAgaWYgKCFjYilcbiAgICAgICAgY2IgPSBvcHRzLCBvcHRzID0ge307XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciByID0ge307XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIGsgPSBPYmplY3Qua2V5cyhyKTtcbiAgICB2YXIgbGZ0ID0gay5sZW5ndGgsIG8gPSAwLCB0b3QgPSAwO1xuICAgIHZhciBzbGZ0ID0gbGZ0LCBmaWxlcyA9IG5ldyBBcnJheShsZnQpO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBjYmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgICAgIHRvdCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xmdDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGYuYy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgd3poKG91dCwgdG90LCBmLCBmLmYsIGYudSwgbCk7XG4gICAgICAgICAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSB0b3QgKyBiYWRkO1xuICAgICAgICAgICAgICAgIG91dC5zZXQoZi5jLCBsb2MpO1xuICAgICAgICAgICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBsLCB0b3QsIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKSwgdG90ID0gbG9jICsgbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHd6ZihvdXQsIG8sIGZpbGVzLmxlbmd0aCwgY2RsLCBvZSk7XG4gICAgICAgIGNiKG51bGwsIG91dCk7XG4gICAgfTtcbiAgICBpZiAoIWxmdClcbiAgICAgICAgY2JmKCk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgZm4gPSBrW2ldO1xuICAgICAgICB2YXIgX2EgPSByW2ZuXSwgZmlsZSA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHZhciBjID0gY3JjKCksIHNpemUgPSBmaWxlLmxlbmd0aDtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICB2YXIgZiA9IHN0clRvVTgoZm4pLCBzID0gZi5sZW5ndGg7XG4gICAgICAgIHZhciBjb20gPSBwLmNvbW1lbnQsIG0gPSBjb20gJiYgc3RyVG9VOChjb20pLCBtcyA9IG0gJiYgbS5sZW5ndGg7XG4gICAgICAgIHZhciBleGwgPSBleGZsKHAuZXh0cmEpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGNibCA9IGZ1bmN0aW9uIChlLCBkKSB7XG4gICAgICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgICAgIHRBbGwoKTtcbiAgICAgICAgICAgICAgICBjYihlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBsID0gZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZmlsZXNbaV0gPSBtcmcocCwge1xuICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgICAgICAgICAgICBjcmM6IGMuZCgpLFxuICAgICAgICAgICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgICAgICAgICBmOiBmLFxuICAgICAgICAgICAgICAgICAgICBtOiBtLFxuICAgICAgICAgICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgICAgICAgICBjb21wcmVzc2lvbjogY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvICs9IDMwICsgcyArIGV4bCArIGw7XG4gICAgICAgICAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgICAgICAgICAgICAgaWYgKCEtLWxmdClcbiAgICAgICAgICAgICAgICAgICAgY2JmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzID4gNjU1MzUpXG4gICAgICAgICAgICBjYmwoJ2ZpbGVuYW1lIHRvbyBsb25nJywgbnVsbCk7XG4gICAgICAgIGlmICghY29tcHJlc3Npb24pXG4gICAgICAgICAgICBjYmwobnVsbCwgZmlsZSk7XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPCAxNjAwMDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2JsKG51bGwsIGRlZmxhdGVTeW5jKGZpbGUsIHApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2JsKGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRlcm0ucHVzaChkZWZsYXRlKGZpbGUsIHAsIGNibCkpO1xuICAgIH07XG4gICAgLy8gQ2Fubm90IHVzZSBsZnQgYmVjYXVzZSBpdCBjYW4gZGVjcmVhc2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsZnQ7ICsraSkge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBjcmVhdGVzIGEgWklQIGZpbGUuIFByZWZlciB1c2luZyBgemlwYCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gKiB3aXRoIG1vcmUgdGhhbiBvbmUgZmlsZS5cbiAqIEBwYXJhbSBkYXRhIFRoZSBkaXJlY3Rvcnkgc3RydWN0dXJlIGZvciB0aGUgWklQIGFyY2hpdmVcbiAqIEBwYXJhbSBvcHRzIFRoZSBtYWluIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHBlci1maWxlIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgWklQIGFyY2hpdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHppcFN5bmMoZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIHZhciByID0ge307XG4gICAgdmFyIGZpbGVzID0gW107XG4gICAgZmx0bihkYXRhLCAnJywgciwgb3B0cyk7XG4gICAgdmFyIG8gPSAwO1xuICAgIHZhciB0b3QgPSAwO1xuICAgIGZvciAodmFyIGZuIGluIHIpIHtcbiAgICAgICAgdmFyIF9hID0gcltmbl0sIGZpbGUgPSBfYVswXSwgcCA9IF9hWzFdO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSBwLmxldmVsID09IDAgPyAwIDogODtcbiAgICAgICAgdmFyIGYgPSBzdHJUb1U4KGZuKSwgcyA9IGYubGVuZ3RoO1xuICAgICAgICB2YXIgY29tID0gcC5jb21tZW50LCBtID0gY29tICYmIHN0clRvVTgoY29tKSwgbXMgPSBtICYmIG0ubGVuZ3RoO1xuICAgICAgICB2YXIgZXhsID0gZXhmbChwLmV4dHJhKTtcbiAgICAgICAgaWYgKHMgPiA2NTUzNSlcbiAgICAgICAgICAgIHRocm93ICdmaWxlbmFtZSB0b28gbG9uZyc7XG4gICAgICAgIHZhciBkID0gY29tcHJlc3Npb24gPyBkZWZsYXRlU3luYyhmaWxlLCBwKSA6IGZpbGUsIGwgPSBkLmxlbmd0aDtcbiAgICAgICAgdmFyIGMgPSBjcmMoKTtcbiAgICAgICAgYy5wKGZpbGUpO1xuICAgICAgICBmaWxlcy5wdXNoKG1yZyhwLCB7XG4gICAgICAgICAgICBzaXplOiBmaWxlLmxlbmd0aCxcbiAgICAgICAgICAgIGNyYzogYy5kKCksXG4gICAgICAgICAgICBjOiBkLFxuICAgICAgICAgICAgZjogZixcbiAgICAgICAgICAgIG06IG0sXG4gICAgICAgICAgICB1OiBzICE9IGZuLmxlbmd0aCB8fCAobSAmJiAoY29tLmxlbmd0aCAhPSBtcykpLFxuICAgICAgICAgICAgbzogbyxcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvblxuICAgICAgICB9KSk7XG4gICAgICAgIG8gKz0gMzAgKyBzICsgZXhsICsgbDtcbiAgICAgICAgdG90ICs9IDc2ICsgMiAqIChzICsgZXhsKSArIChtcyB8fCAwKSArIGw7XG4gICAgfVxuICAgIHZhciBvdXQgPSBuZXcgdTgodG90ICsgMjIpLCBvZSA9IG8sIGNkbCA9IHRvdCAtIG87XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZiA9IGZpbGVzW2ldO1xuICAgICAgICB3emgob3V0LCBmLm8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJhZGQgPSAzMCArIGYuZi5sZW5ndGggKyBleGZsKGYuZXh0cmEpO1xuICAgICAgICBvdXQuc2V0KGYuYywgZi5vICsgYmFkZCk7XG4gICAgICAgIHd6aChvdXQsIG8sIGYsIGYuZiwgZi51LCBmLmMubGVuZ3RoLCBmLm8sIGYubSksIG8gKz0gMTYgKyBiYWRkICsgKGYubSA/IGYubS5sZW5ndGggOiAwKTtcbiAgICB9XG4gICAgd3pmKG91dCwgbywgZmlsZXMubGVuZ3RoLCBjZGwsIG9lKTtcbiAgICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBTdHJlYW1pbmcgcGFzcy10aHJvdWdoIGRlY29tcHJlc3Npb24gZm9yIFpJUCBhcmNoaXZlc1xuICovXG52YXIgVW56aXBQYXNzVGhyb3VnaCA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVbnppcFBhc3NUaHJvdWdoKCkge1xuICAgIH1cbiAgICBVbnppcFBhc3NUaHJvdWdoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRoaXMub25kYXRhKG51bGwsIGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIFVuemlwUGFzc1Rocm91Z2guY29tcHJlc3Npb24gPSAwO1xuICAgIHJldHVybiBVbnppcFBhc3NUaHJvdWdoO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwUGFzc1Rocm91Z2ggfTtcbi8qKlxuICogU3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzLiBQcmVmZXIgQXN5bmNaaXBJbmZsYXRlIGZvclxuICogYmV0dGVyIHBlcmZvcm1hbmNlLlxuICovXG52YXIgVW56aXBJbmZsYXRlID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBERUZMQVRFIGRlY29tcHJlc3Npb24gdGhhdCBjYW4gYmUgdXNlZCBpbiBaSVAgYXJjaGl2ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVbnppcEluZmxhdGUoKSB7XG4gICAgICAgIHZhciBfdGhpc18xID0gdGhpcztcbiAgICAgICAgdGhpcy5pID0gbmV3IEluZmxhdGUoZnVuY3Rpb24gKGRhdCwgZmluYWwpIHtcbiAgICAgICAgICAgIF90aGlzXzEub25kYXRhKG51bGwsIGRhdCwgZmluYWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVW56aXBJbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIGZpbmFsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmkucHVzaChkYXRhLCBmaW5hbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25kYXRhKGUsIGRhdGEsIGZpbmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gVW56aXBJbmZsYXRlO1xufSgpKTtcbmV4cG9ydCB7IFVuemlwSW5mbGF0ZSB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXMgc3RyZWFtaW5nIERFRkxBVEUgZGVjb21wcmVzc2lvbiBmb3IgWklQIGFyY2hpdmVzXG4gKi9cbnZhciBBc3luY1VuemlwSW5mbGF0ZSA9IC8qI19fUFVSRV9fKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgREVGTEFURSBkZWNvbXByZXNzaW9uIHRoYXQgY2FuIGJlIHVzZWQgaW4gWklQIGFyY2hpdmVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXN5bmNVbnppcEluZmxhdGUoXywgc3opIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoc3ogPCAzMjAwMDApIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBJbmZsYXRlKGZ1bmN0aW9uIChkYXQsIGZpbmFsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNfMS5vbmRhdGEobnVsbCwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSA9IG5ldyBBc3luY0luZmxhdGUoZnVuY3Rpb24gKGVyciwgZGF0LCBmaW5hbCkge1xuICAgICAgICAgICAgICAgIF90aGlzXzEub25kYXRhKGVyciwgZGF0LCBmaW5hbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlID0gdGhpcy5pLnRlcm1pbmF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBc3luY1VuemlwSW5mbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBmaW5hbCkge1xuICAgICAgICBpZiAodGhpcy5pLnRlcm1pbmF0ZSlcbiAgICAgICAgICAgIGRhdGEgPSBzbGMoZGF0YSwgMCk7XG4gICAgICAgIHRoaXMuaS5wdXNoKGRhdGEsIGZpbmFsKTtcbiAgICB9O1xuICAgIEFzeW5jVW56aXBJbmZsYXRlLmNvbXByZXNzaW9uID0gODtcbiAgICByZXR1cm4gQXN5bmNVbnppcEluZmxhdGU7XG59KCkpO1xuZXhwb3J0IHsgQXN5bmNVbnppcEluZmxhdGUgfTtcbi8qKlxuICogQSBaSVAgYXJjaGl2ZSBkZWNvbXByZXNzaW9uIHN0cmVhbSB0aGF0IGVtaXRzIGZpbGVzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWRcbiAqL1xudmFyIFVuemlwID0gLyojX19QVVJFX18qLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBaSVAgZGVjb21wcmVzc2lvbiBzdHJlYW1cbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2hlbmV2ZXIgYSBmaWxlIGluIHRoZSBaSVAgYXJjaGl2ZSBpcyBmb3VuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFVuemlwKGNiKSB7XG4gICAgICAgIHRoaXMub25maWxlID0gY2I7XG4gICAgICAgIHRoaXMuayA9IFtdO1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgICAwOiBVbnppcFBhc3NUaHJvdWdoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucCA9IGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBjaHVuayB0byBiZSB1bnppcHBlZFxuICAgICAqIEBwYXJhbSBjaHVuayBUaGUgY2h1bmsgdG8gcHVzaFxuICAgICAqIEBwYXJhbSBmaW5hbCBXaGV0aGVyIHRoaXMgaXMgdGhlIGxhc3QgY2h1bmtcbiAgICAgKi9cbiAgICBVbnppcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZmluYWwpIHtcbiAgICAgICAgdmFyIF90aGlzXzEgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMub25maWxlKVxuICAgICAgICAgICAgdGhyb3cgJ25vIGNhbGxiYWNrJztcbiAgICAgICAgaWYgKCF0aGlzLnApXG4gICAgICAgICAgICB0aHJvdyAnc3RyZWFtIGZpbmlzaGVkJztcbiAgICAgICAgaWYgKHRoaXMuYyA+IDApIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbih0aGlzLmMsIGNodW5rLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgdG9BZGQgPSBjaHVuay5zdWJhcnJheSgwLCBsZW4pO1xuICAgICAgICAgICAgdGhpcy5jIC09IGxlbjtcbiAgICAgICAgICAgIGlmICh0aGlzLmQpXG4gICAgICAgICAgICAgICAgdGhpcy5kLnB1c2godG9BZGQsICF0aGlzLmMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMua1swXS5wdXNoKHRvQWRkKTtcbiAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHVzaChjaHVuaywgZmluYWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGYgPSAwLCBpID0gMCwgaXMgPSB2b2lkIDAsIGJ1ZiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5wLmxlbmd0aClcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuaztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaHVuay5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnVmID0gdGhpcy5wO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmID0gbmV3IHU4KHRoaXMucC5sZW5ndGggKyBjaHVuay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJ1Zi5zZXQodGhpcy5wKSwgYnVmLnNldChjaHVuaywgdGhpcy5wLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbCA9IGJ1Zi5sZW5ndGgsIG9jID0gdGhpcy5jLCBhZGQgPSBvYyAmJiB0aGlzLmQ7XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHNpZyA9IGI0KGJ1ZiwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZyA9PSAweDQwMzRCNTApIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IDEsIGlzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLmQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzXzEuYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZiA9IGIyKGJ1ZiwgaSArIDYpLCBjbXBfMSA9IGIyKGJ1ZiwgaSArIDgpLCB1ID0gYmYgJiAyMDQ4LCBkZCA9IGJmICYgOCwgZm5sID0gYjIoYnVmLCBpICsgMjYpLCBlcyA9IGIyKGJ1ZiwgaSArIDI4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGwgPiBpICsgMzAgKyBmbmwgKyBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoa3NfMiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc18xLmsudW5zaGlmdChjaGtzXzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NfMSA9IGI0KGJ1ZiwgaSArIDE4KSwgc3VfMSA9IGI0KGJ1ZiwgaSArIDIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbl8xID0gc3RyRnJvbVU4KGJ1Zi5zdWJhcnJheShpICsgMzAsIGkgKz0gMzAgKyBmbmwpLCAhdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NfMSA9PSA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBkZCA/IFstMl0gOiB6NjRlKGJ1ZiwgaSksIHNjXzEgPSBfYVswXSwgc3VfMSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NfMSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5jID0gc2NfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZV8xID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZuXzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHJlc3Npb246IGNtcF8xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmlsZV8xLm9uZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICdubyBjYWxsYmFjayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVfMS5vbmRhdGEobnVsbCwgZXQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHIgPSBfdGhpc18xLm9bY21wXzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ3Vua25vd24gY29tcHJlc3Npb24gdHlwZSAnICsgY21wXzE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEgPSBzY18xIDwgMCA/IG5ldyBjdHIoZm5fMSkgOiBuZXcgY3RyKGZuXzEsIHNjXzEsIHN1XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZF8xLm9uZGF0YSA9IGZ1bmN0aW9uIChlcnIsIGRhdCwgZmluYWwpIHsgZmlsZV8xLm9uZGF0YShlcnIsIGRhdCwgZmluYWwpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBjaGtzXzMgPSBjaGtzXzI7IF9pIDwgY2hrc18zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXQgPSBjaGtzXzNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRfMS5wdXNoKGRhdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzXzEua1swXSA9PSBjaGtzXzIgJiYgX3RoaXNfMS5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzXzEuZCA9IGRfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEucHVzaChldCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZF8xICYmIGRfMS50ZXJtaW5hdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkXzEudGVybWluYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY18xID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZV8xLnNpemUgPSBzY18xLCBmaWxlXzEub3JpZ2luYWxTaXplID0gc3VfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5vbmZpbGUoZmlsZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2lnID09IDB4ODA3NEI1MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXMgPSBpICs9IDEyICsgKG9jID09IC0yICYmIDgpLCBmID0gMywgdGhpc18xLmMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzaWcgPT0gMHgyMDE0QjUwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcyA9IGkgLT0gNCwgZiA9IDMsIHRoaXNfMS5jID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGwgLSA0OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucCA9IGV0O1xuICAgICAgICAgICAgaWYgKG9jIDwgMCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXQgPSBmID8gYnVmLnN1YmFycmF5KDAsIGlzIC0gMTIgLSAob2MgPT0gLTIgJiYgOCkgLSAoYjQoYnVmLCBpcyAtIDE2KSA9PSAweDgwNzRCNTAgJiYgNCkpIDogYnVmLnN1YmFycmF5KDAsIGkpO1xuICAgICAgICAgICAgICAgIGlmIChhZGQpXG4gICAgICAgICAgICAgICAgICAgIGFkZC5wdXNoKGRhdCwgISFmKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua1srKGYgPT0gMildLnB1c2goZGF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmICYgMilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoKGJ1Zi5zdWJhcnJheShpKSwgZmluYWwpO1xuICAgICAgICAgICAgdGhpcy5wID0gYnVmLnN1YmFycmF5KGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaW5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYylcbiAgICAgICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgICAgICB0aGlzLnAgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBkZWNvZGVyIHdpdGggdGhlIHN0cmVhbSwgYWxsb3dpbmcgZm9yIGZpbGVzIGNvbXByZXNzZWQgd2l0aFxuICAgICAqIHRoZSBjb21wcmVzc2lvbiB0eXBlIHByb3ZpZGVkIHRvIGJlIGV4cGFuZGVkIGNvcnJlY3RseVxuICAgICAqIEBwYXJhbSBkZWNvZGVyIFRoZSBkZWNvZGVyIGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgVW56aXAucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKGRlY29kZXIpIHtcbiAgICAgICAgdGhpcy5vW2RlY29kZXIuY29tcHJlc3Npb25dID0gZGVjb2RlcjtcbiAgICB9O1xuICAgIHJldHVybiBVbnppcDtcbn0oKSk7XG5leHBvcnQgeyBVbnppcCB9O1xuLyoqXG4gKiBBc3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZVxuICogQHBhcmFtIGRhdGEgVGhlIHJhdyBjb21wcmVzc2VkIFpJUCBmaWxlXG4gKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIHRvIGNhbGwgd2l0aCB0aGUgZGVjb21wcmVzc2VkIGZpbGVzXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW1tZWRpYXRlbHkgdGVybWluYXRlIHRoZSB1bnppcHBpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwKGRhdGEsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyAnbm8gY2FsbGJhY2snO1xuICAgIHZhciB0ZXJtID0gW107XG4gICAgdmFyIHRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVybS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRlcm1baV0oKTtcbiAgICB9O1xuICAgIHZhciBmaWxlcyA9IHt9O1xuICAgIHZhciBlID0gZGF0YS5sZW5ndGggLSAyMjtcbiAgICBmb3IgKDsgYjQoZGF0YSwgZSkgIT0gMHg2MDU0QjUwOyAtLWUpIHtcbiAgICAgICAgaWYgKCFlIHx8IGRhdGEubGVuZ3RoIC0gZSA+IDY1NTU4KSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICB2YXIgbGZ0ID0gYjIoZGF0YSwgZSArIDgpO1xuICAgIGlmICghbGZ0KVxuICAgICAgICBjYihudWxsLCB7fSk7XG4gICAgdmFyIGMgPSBsZnQ7XG4gICAgdmFyIG8gPSBiNChkYXRhLCBlICsgMTYpO1xuICAgIHZhciB6ID0gbyA9PSA0Mjk0OTY3Mjk1O1xuICAgIGlmICh6KSB7XG4gICAgICAgIGUgPSBiNChkYXRhLCBlIC0gMTIpO1xuICAgICAgICBpZiAoYjQoZGF0YSwgZSkgIT0gMHg2MDY0QjUwKSB7XG4gICAgICAgICAgICBjYignaW52YWxpZCB6aXAgZmlsZScsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBsZnQgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgdmFyIF9sb29wXzMgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgX2EgPSB6aChkYXRhLCBvLCB6KSwgY18xID0gX2FbMF0sIHNjID0gX2FbMV0sIHN1ID0gX2FbMl0sIGZuID0gX2FbM10sIG5vID0gX2FbNF0sIG9mZiA9IF9hWzVdLCBiID0gc2x6aChkYXRhLCBvZmYpO1xuICAgICAgICBvID0gbm87XG4gICAgICAgIHZhciBjYmwgPSBmdW5jdGlvbiAoZSwgZCkge1xuICAgICAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgICAgICB0QWxsKCk7XG4gICAgICAgICAgICAgICAgY2IoZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlc1tmbl0gPSBkO1xuICAgICAgICAgICAgICAgIGlmICghLS1sZnQpXG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGZpbGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFjXzEpXG4gICAgICAgICAgICBjYmwobnVsbCwgc2xjKGRhdGEsIGIsIGIgKyBzYykpO1xuICAgICAgICBlbHNlIGlmIChjXzEgPT0gOCkge1xuICAgICAgICAgICAgdmFyIGluZmwgPSBkYXRhLnN1YmFycmF5KGIsIGIgKyBzYyk7XG4gICAgICAgICAgICBpZiAoc2MgPCAzMjAwMDApIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYmwobnVsbCwgaW5mbGF0ZVN5bmMoaW5mbCwgbmV3IHU4KHN1KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYmwoZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRlcm0ucHVzaChpbmZsYXRlKGluZmwsIHsgc2l6ZTogc3UgfSwgY2JsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY2JsKCd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMSwgbnVsbCk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGM7ICsraSkge1xuICAgICAgICBfbG9vcF8zKGkpO1xuICAgIH1cbiAgICByZXR1cm4gdEFsbDtcbn1cbi8qKlxuICogU3luY2hyb25vdXNseSBkZWNvbXByZXNzZXMgYSBaSVAgYXJjaGl2ZS4gUHJlZmVyIHVzaW5nIGB1bnppcGAgZm9yIGJldHRlclxuICogcGVyZm9ybWFuY2Ugd2l0aCBtb3JlIHRoYW4gb25lIGZpbGUuXG4gKiBAcGFyYW0gZGF0YSBUaGUgcmF3IGNvbXByZXNzZWQgWklQIGZpbGVcbiAqIEByZXR1cm5zIFRoZSBkZWNvbXByZXNzZWQgZmlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuemlwU3luYyhkYXRhKSB7XG4gICAgdmFyIGZpbGVzID0ge307XG4gICAgdmFyIGUgPSBkYXRhLmxlbmd0aCAtIDIyO1xuICAgIGZvciAoOyBiNChkYXRhLCBlKSAhPSAweDYwNTRCNTA7IC0tZSkge1xuICAgICAgICBpZiAoIWUgfHwgZGF0YS5sZW5ndGggLSBlID4gNjU1NTgpXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgfVxuICAgIDtcbiAgICB2YXIgYyA9IGIyKGRhdGEsIGUgKyA4KTtcbiAgICBpZiAoIWMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgbyA9IGI0KGRhdGEsIGUgKyAxNik7XG4gICAgdmFyIHogPSBvID09IDQyOTQ5NjcyOTU7XG4gICAgaWYgKHopIHtcbiAgICAgICAgZSA9IGI0KGRhdGEsIGUgLSAxMik7XG4gICAgICAgIGlmIChiNChkYXRhLCBlKSAhPSAweDYwNjRCNTApXG4gICAgICAgICAgICB0aHJvdyAnaW52YWxpZCB6aXAgZmlsZSc7XG4gICAgICAgIGMgPSBiNChkYXRhLCBlICsgMzIpO1xuICAgICAgICBvID0gYjQoZGF0YSwgZSArIDQ4KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyArK2kpIHtcbiAgICAgICAgdmFyIF9hID0gemgoZGF0YSwgbywgeiksIGNfMiA9IF9hWzBdLCBzYyA9IF9hWzFdLCBzdSA9IF9hWzJdLCBmbiA9IF9hWzNdLCBubyA9IF9hWzRdLCBvZmYgPSBfYVs1XSwgYiA9IHNsemgoZGF0YSwgb2ZmKTtcbiAgICAgICAgbyA9IG5vO1xuICAgICAgICBpZiAoIWNfMilcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IHNsYyhkYXRhLCBiLCBiICsgc2MpO1xuICAgICAgICBlbHNlIGlmIChjXzIgPT0gOClcbiAgICAgICAgICAgIGZpbGVzW2ZuXSA9IGluZmxhdGVTeW5jKGRhdGEuc3ViYXJyYXkoYiwgYiArIHNjKSwgbmV3IHU4KHN1KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93ICd1bmtub3duIGNvbXByZXNzaW9uIHR5cGUgJyArIGNfMjtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuIl0sIm5hbWVzIjpbImNyZWF0ZVJlcXVpcmUiLCJyZXF1aXJlIiwiV29ya2VyIiwid29ya2VyQWRkIiwiZSIsIndrIiwiYyIsIl8iLCJtc2ciLCJ0cmFuc2ZlciIsImNiIiwiZG9uZSIsInciLCJldmFsIiwib24iLCJtIiwiRXJyb3IiLCJwb3N0TWVzc2FnZSIsInRlcm1pbmF0ZSIsInByb3RvdHlwZSIsImNhbGwiLCJfXyIsIl9fXyIsIl9fX18iLCJzZXRJbW1lZGlhdGUiLCJOT1AiLCJ1OCIsIlVpbnQ4QXJyYXkiLCJ1MTYiLCJVaW50MTZBcnJheSIsInUzMiIsIlVpbnQzMkFycmF5IiwiZmxlYiIsImZkZWIiLCJjbGltIiwiZnJlYiIsImViIiwic3RhcnQiLCJiIiwiaSIsInIiLCJqIiwiX2EiLCJmbCIsInJldmZsIiwiX2IiLCJmZCIsInJldmZkIiwicmV2IiwieCIsImhNYXAiLCJjZCIsIm1iIiwicyIsImxlbmd0aCIsImwiLCJsZSIsImNvIiwicnZiIiwic3YiLCJyXzEiLCJ2IiwiZmx0IiwiZmR0IiwiZmxtIiwiZmxybSIsImZkbSIsImZkcm0iLCJtYXgiLCJhIiwiYml0cyIsImQiLCJwIiwibyIsImJpdHMxNiIsInNoZnQiLCJzbGMiLCJuIiwic2V0Iiwic3ViYXJyYXkiLCJpbmZsdCIsImRhdCIsImJ1ZiIsInN0Iiwic2wiLCJub0J1ZiIsIm5vU3QiLCJjYnVmIiwiYmwiLCJuYnVmIiwiTWF0aCIsImZpbmFsIiwiZiIsInBvcyIsImJ0IiwibG0iLCJkbSIsImxidCIsImRidCIsInRidHMiLCJ0eXBlIiwidCIsImhMaXQiLCJoY0xlbiIsInRsIiwibGR0IiwiY2x0IiwiY2xiIiwiY2xibXNrIiwiY2xtIiwibHQiLCJkdCIsImxtcyIsImRtcyIsImxwb3MiLCJzeW0iLCJhZGQiLCJkc3ltIiwiZW5kIiwid2JpdHMiLCJ3Yml0czE2IiwiaFRyZWUiLCJwdXNoIiwidDIiLCJzbGljZSIsImV0Iiwic29ydCIsImkwIiwiaTEiLCJpMiIsIm1heFN5bSIsInRyIiwibWJ0IiwibG4iLCJsZnQiLCJjc3QiLCJpMl8xIiwiaTJfMiIsImkyXzMiLCJsYyIsImNsIiwiY2xpIiwiY2xuIiwiY2xzIiwiY2xlbiIsImNmIiwid2ZibGsiLCJvdXQiLCJ3YmxrIiwic3ltcyIsImxmIiwiZGYiLCJsaSIsImJzIiwiZGx0IiwibWxiIiwiZGR0IiwibWRiIiwiX2MiLCJsY2x0IiwibmxjIiwiX2QiLCJsY2R0IiwibmRjIiwibGNmcmVxIiwiX2UiLCJsY3QiLCJtbGNiIiwibmxjYyIsImZsZW4iLCJmdGxlbiIsImR0bGVuIiwibGwiLCJkbCIsImxsbSIsImxjdHMiLCJpdCIsImNsY3QiLCJsZW4iLCJkc3QiLCJkZW8iLCJkZmx0IiwibHZsIiwicGx2bCIsInByZSIsInBvc3QiLCJsc3QiLCJjZWlsIiwib3B0IiwibXNrXzEiLCJwcmV2IiwiaGVhZCIsImJzMV8xIiwiYnMyXzEiLCJoc2giLCJsY18xIiwid2kiLCJodiIsImltb2QiLCJwaW1vZCIsInJlbSIsImNoXzEiLCJkaWYiLCJtYXhuIiwibWluIiwibWF4ZCIsIm1sIiwibmwiLCJtbWQiLCJtZCIsInRpIiwicHRpIiwibGluIiwiZGluIiwiY3JjdCIsIkludDMyQXJyYXkiLCJrIiwiY3JjIiwiY3IiLCJhZGxlciIsImRvcHQiLCJsZXZlbCIsIm1lbSIsImxvZyIsIm1yZyIsIndjbG4iLCJmbiIsImZuU3RyIiwidGQiLCJ0b1N0cmluZyIsImtzIiwiaW5kZXhPZiIsImxhc3RJbmRleE9mIiwicmVwbGFjZSIsInNwbGl0Iiwic3RfMSIsInNwSW5kIiwiY2giLCJjYmZzIiwiY29uc3RydWN0b3IiLCJidWZmZXIiLCJ3cmtyIiwiZm5zIiwiaW5pdCIsImlkIiwidGRfMSIsImJJbmZsdCIsImluZmxhdGVTeW5jIiwicGJmIiwiZ3U4IiwiYkRmbHQiLCJkZWZsYXRlU3luYyIsImd6ZSIsImd6aCIsImd6aGwiLCJ3Ynl0ZXMiLCJndXplIiwiZ3pzIiwiZ3psIiwiemxlIiwiemxoIiwienVsZSIsInpsdiIsInNpemUiLCJjYmlmeSIsIm9wdHMiLCJlcnIiLCJjb25zdW1lIiwiYXN0cm0iLCJzdHJtIiwib25kYXRhIiwiZXYiLCJkYXRhIiwiYXN0cm1pZnkiLCJiMiIsImI0IiwiYjgiLCJmaWxlbmFtZSIsIm10aW1lIiwiZmxvb3IiLCJEYXRlIiwibm93IiwiY2hhckNvZGVBdCIsImZsZyIsInpzIiwibHYiLCJBc3luY0NtcFN0cm0iLCJEZWZsYXRlIiwiY2h1bmsiLCJBc3luY0RlZmxhdGUiLCJvbm1lc3NhZ2UiLCJkZWZsYXRlIiwiSW5mbGF0ZSIsImJ0cyIsIkFzeW5jSW5mbGF0ZSIsImluZmxhdGUiLCJHemlwIiwicmF3IiwiQXN5bmNHemlwIiwiZ3ppcCIsImd6aXBTeW5jIiwiR3VuemlwIiwiQXN5bmNHdW56aXAiLCJndW56aXAiLCJndW56aXBTeW5jIiwiWmxpYiIsIkFzeW5jWmxpYiIsInpsaWIiLCJ6bGliU3luYyIsIlVuemxpYiIsIkFzeW5jVW56bGliIiwidW56bGliIiwidW56bGliU3luYyIsImNvbXByZXNzIiwiQXN5bmNDb21wcmVzcyIsImNvbXByZXNzU3luYyIsIkNvbXByZXNzIiwiRGVjb21wcmVzcyIsIkciLCJJIiwiWiIsIl90aGlzXzEiLCJhcHBseSIsImFyZ3VtZW50cyIsIkFzeW5jRGVjb21wcmVzcyIsImRlY29tcHJlc3MiLCJkZWNvbXByZXNzU3luYyIsImZsdG4iLCJ2YWwiLCJBcnJheSIsImlzQXJyYXkiLCJ0ZSIsIlRleHRFbmNvZGVyIiwiVGV4dERlY29kZXIiLCJ0ZHMiLCJkZWNvZGUiLCJzdHJlYW0iLCJkdXRmOCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkRlY29kZVVURjgiLCJucCIsIkVuY29kZVVURjgiLCJzdHJUb1U4Iiwic3RyIiwibGF0aW4xIiwiYXJfMSIsImVuY29kZSIsImFyIiwiYWkiLCJzdHJGcm9tVTgiLCJleHQiLCJkYmYiLCJzbHpoIiwiemgiLCJ6IiwiZm5sIiwiZXMiLCJ6NjRlIiwic2MiLCJzdSIsIm9mZiIsImV4ZmwiLCJleCIsInd6aCIsInUiLCJjZSIsImV4dHJhIiwiY29sIiwiZXhsIiwib3MiLCJmbGFnIiwiY29tcHJlc3Npb24iLCJ5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiYXR0cnMiLCJleGYiLCJ3emYiLCJaaXBQYXNzVGhyb3VnaCIsInByb2Nlc3MiLCJaaXBEZWZsYXRlIiwiQXN5bmNaaXBEZWZsYXRlIiwiWmlwIiwiZmlsZSIsImNvbSIsImNvbW1lbnQiLCJobCIsImhlYWRlciIsImNoa3MiLCJwQWxsIiwiX2kiLCJjaGtzXzEiLCJjaGsiLCJpbmQiLCJ1ZiIsIm54dCIsImRkIiwic3BsaWNlIiwiemlwIiwiT2JqZWN0Iiwia2V5cyIsInRvdCIsInNsZnQiLCJmaWxlcyIsInRlcm0iLCJ0QWxsIiwiY2JmIiwib2UiLCJjZGwiLCJiYWRkIiwibG9jIiwiX2xvb3BfMSIsIm1zIiwiY2JsIiwiemlwU3luYyIsIlVuemlwUGFzc1Rocm91Z2giLCJVbnppcEluZmxhdGUiLCJBc3luY1VuemlwSW5mbGF0ZSIsInN6IiwiVW56aXAiLCJvbmZpbGUiLCJ0b0FkZCIsImlzIiwib2MiLCJfbG9vcF8yIiwic2lnIiwidGhpc18xIiwiYmYiLCJjbXBfMSIsImNoa3NfMiIsInVuc2hpZnQiLCJzY18xIiwic3VfMSIsImZuXzEiLCJkXzEiLCJmaWxlXzEiLCJuYW1lIiwiY3RyIiwiY2hrc18zIiwib3JpZ2luYWxTaXplIiwic3RhdGVfMSIsInJlZ2lzdGVyIiwiZGVjb2RlciIsInVuemlwIiwiX2xvb3BfMyIsImNfMSIsIm5vIiwiaW5mbCIsInVuemlwU3luYyIsImNfMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/node_modules/fflate/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n            `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n        ];\n        const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${_polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RTtBQUMxQjtBQUNwRCxNQUFNSyxnQkFBZ0IsQ0FBQ0MsTUFBUUEsT0FBT0EsSUFBSUQsYUFBYTtBQUN2RCxNQUFNRSwyQkFBMkJQLHVDQUFJQTtJQUNuQ1EsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDNUIsSUFBSUMsSUFBSUM7UUFDUixNQUFNQyxZQUFZUixjQUFjSTtRQUNoQyxNQUFNSyxJQUFJLENBQUNGLEtBQUtDLFlBQVksQ0FBQ0YsS0FBS0YsUUFBUU0sS0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSUosR0FBR0ssS0FBSyxHQUFHUCxRQUFRTSxLQUFLLENBQUNDLEtBQUssS0FBSyxPQUFPSixLQUFLO1FBQ3RILE1BQU1LLFdBQVdILElBQUk7UUFDckIsTUFBTUksVUFBVUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxJQUFJLENBQUNKO1FBQ3JDLE1BQU1LLFlBQVlILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTDtRQUM5QixNQUFNRixRQUFRLElBQUlHLEtBQUtLLEdBQUcsQ0FBQ0YsV0FBVyxLQUFLO1FBQzNDLE1BQU1HLFNBQVMsSUFBSUg7UUFDbkIsTUFBTUksVUFBVTtZQUNkYixZQUFZLDZCQUE2QjtZQUN6QyxDQUFDLDJCQUEyQixFQUFFLElBQUlHLE1BQU0sQ0FBQztZQUN6QyxDQUFDLDRCQUE0QixFQUFFLElBQUlTLE9BQU8sQ0FBQztZQUMzQyxDQUFDLHVCQUF1QixFQUFFUCxRQUFRLEVBQUUsQ0FBQztTQUN0QztRQUNELE1BQU1TLGVBQ0osUUFBUSxHQUNSLENBQUM7Ozs7Ozs7OztRQVNDLENBQUM7UUFFTCxNQUFNQyxpQkFBaUJGLFFBQVFHLElBQUksQ0FBQyxRQUFRLFFBQVEsR0FDcEQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQXFFaUIsRUFBRXpCLDJEQUFPQSxJQUFJLE1BQU0sd0JBQXdCLHFCQUFxQjs7UUFFOUUsQ0FBQztRQUNMLE1BQU0wQixXQUFXO1lBQ2ZDLEtBQUs7Z0JBQUVDLE9BQU92QjtZQUFRO1lBQ3RCZ0IsUUFBUTtnQkFBRU8sT0FBTyxDQUFDdEIsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUWUsTUFBTSxLQUFLO1lBQUc7WUFDbkVRLFFBQVE7Z0JBQUVELE9BQU8sQ0FBQ3RCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVF1QixNQUFNLEtBQUs7WUFBSTtRQUN0RTtRQUNBLE1BQU1DLFdBQVcsSUFBSWpDLHNEQUFtQkEsQ0FBQyxHQUFHO1FBQzVDLE1BQU1rQyxXQUFXLElBQUlqQyxpREFBY0EsQ0FBQztZQUNsQzRCO1lBQ0FGO1lBQ0FEO1lBQ0FTLE1BQU1qQyw2Q0FBVUE7UUFDbEI7UUFDQSxLQUFLLENBQUMrQixVQUFVQztJQUNsQjtJQUNBLElBQUlGLE9BQU9BLE1BQU0sRUFBRTtRQUNqQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDRyxNQUFNLENBQUNELEtBQUssR0FBR0M7SUFDeEM7SUFDQSxJQUFJQSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNFLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDRyxNQUFNLENBQUNELEtBQUs7SUFDNUM7SUFDQSxJQUFJUCxPQUFPQSxNQUFNLEVBQUU7UUFDakIsSUFBSSxDQUFDVSxRQUFRLENBQUNMLFFBQVEsQ0FBQ0wsTUFBTSxDQUFDTyxLQUFLLEdBQUdQO0lBQ3hDO0lBQ0EsSUFBSUEsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDVSxRQUFRLENBQUNMLFFBQVEsQ0FBQ0wsTUFBTSxDQUFDTyxLQUFLO0lBQzVDO0FBQ0Y7QUFHRSxDQUNGLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzPzYwYjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWVzaCwgSWNvc2FoZWRyb25HZW9tZXRyeSwgU2hhZGVyTWF0ZXJpYWwsIERvdWJsZVNpZGUgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuY29uc3QgaXNDdWJlVGV4dHVyZSA9IChkZWYpID0+IGRlZiAmJiBkZWYuaXNDdWJlVGV4dHVyZTtcbmNsYXNzIEdyb3VuZFByb2plY3RlZEVudiBleHRlbmRzIE1lc2gge1xuICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBpc0N1YmVNYXAgPSBpc0N1YmVUZXh0dXJlKHRleHR1cmUpO1xuICAgIGNvbnN0IHcgPSAoX2IgPSBpc0N1YmVNYXAgPyAoX2EgPSB0ZXh0dXJlLmltYWdlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2Eud2lkdGggOiB0ZXh0dXJlLmltYWdlLndpZHRoKSAhPSBudWxsID8gX2IgOiAxMDI0O1xuICAgIGNvbnN0IGN1YmVTaXplID0gdyAvIDQ7XG4gICAgY29uc3QgX2xvZE1heCA9IE1hdGguZmxvb3IoTWF0aC5sb2cyKGN1YmVTaXplKSk7XG4gICAgY29uc3QgX2N1YmVTaXplID0gTWF0aC5wb3coMiwgX2xvZE1heCk7XG4gICAgY29uc3Qgd2lkdGggPSAzICogTWF0aC5tYXgoX2N1YmVTaXplLCAxNiAqIDcpO1xuICAgIGNvbnN0IGhlaWdodCA9IDQgKiBfY3ViZVNpemU7XG4gICAgY29uc3QgZGVmaW5lcyA9IFtcbiAgICAgIGlzQ3ViZU1hcCA/IFwiI2RlZmluZSBFTlZNQVBfVFlQRV9DVUJFXCIgOiBcIlwiLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX1RFWEVMX1dJRFRIICR7MSAvIHdpZHRofWAsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfVEVYRUxfSEVJR0hUICR7MSAvIGhlaWdodH1gLFxuICAgICAgYCNkZWZpbmUgQ1VCRVVWX01BWF9NSVAgJHtfbG9kTWF4fS4wYFxuICAgIF07XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gKFxuICAgICAgLyogZ2xzbCAqL1xuICAgICAgYFxuICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG4gICAgICAgIHZvaWQgbWFpbigpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWM0IHdvcmxkUG9zaXRpb24gPSAoIG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApICk7XG4gICAgICAgICAgICB2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG4gICAgICAgIH1cbiAgICAgICAgYFxuICAgICk7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBkZWZpbmVzLmpvaW4oXCJcXG5cIikgKyAvKiBnbHNsICovXG4gICAgYFxuICAgICAgICAjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVfVVZcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHJhZGl1cztcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBoZWlnaHQ7XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgYW5nbGU7XG4gICAgICAgICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXJDdWJlIG1hcDtcbiAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcbiAgICAgICAgI2VuZGlmXG4gICAgICAgIC8vIEZyb206IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy80dHNCRDdcbiAgICAgICAgZmxvYXQgZGlza0ludGVyc2VjdFdpdGhCYWNrRmFjZUN1bGxpbmcoIHZlYzMgcm8sIHZlYzMgcmQsIHZlYzMgYywgdmVjMyBuLCBmbG9hdCByICkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZsb2F0IGQgPSBkb3QgKCByZCwgbiApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggZCA+IDAuMCApIHsgcmV0dXJuIDFlNjsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2ZWMzICBvID0gcm8gLSBjO1xuICAgICAgICAgICAgZmxvYXQgdCA9IC0gZG90KCBuLCBvICkgLyBkO1xuICAgICAgICAgICAgdmVjMyAgcSA9IG8gKyByZCAqIHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAoIGRvdCggcSwgcSApIDwgciAqIHIgKSA/IHQgOiAxZTY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL2ludGVyc2VjdG9ycy9pbnRlcnNlY3RvcnMuaHRtXG4gICAgICAgIGZsb2F0IHNwaGVyZUludGVyc2VjdCggdmVjMyBybywgdmVjMyByZCwgdmVjMyBjZSwgZmxvYXQgcmEgKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBvYyA9IHJvIC0gY2U7XG4gICAgICAgICAgICBmbG9hdCBiID0gZG90KCBvYywgcmQgKTtcbiAgICAgICAgICAgIGZsb2F0IGMgPSBkb3QoIG9jLCBvYyApIC0gcmEgKiByYTtcbiAgICAgICAgICAgIGZsb2F0IGggPSBiICogYiAtIGM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBoIDwgMC4wICkgeyByZXR1cm4gLTEuMDsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBoID0gc3FydCggaCApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gLSBiICsgaDtcbiAgICAgICAgfVxuICAgICAgICB2ZWMzIHByb2plY3QoKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgdmVjMyBjYW1Qb3MgPSBjYW1lcmFQb3NpdGlvbjtcbiAgICAgICAgICAgIGNhbVBvcy55IC09IGhlaWdodDtcbiAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbiA9IHNwaGVyZUludGVyc2VjdCggY2FtUG9zLCBwLCB2ZWMzKCAwLjAgKSwgcmFkaXVzICk7XG4gICAgICAgICAgICBpZiggaW50ZXJzZWN0aW9uID4gMC4wICkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZlYzMgaCA9IHZlYzMoIDAuMCwgLSBoZWlnaHQsIDAuMCApO1xuICAgICAgICAgICAgICAgIGZsb2F0IGludGVyc2VjdGlvbjIgPSBkaXNrSW50ZXJzZWN0V2l0aEJhY2tGYWNlQ3VsbGluZyggY2FtUG9zLCBwLCBoLCB2ZWMzKCAwLjAsIDEuMCwgMC4wICksIHJhZGl1cyApO1xuICAgICAgICAgICAgICAgIHAgPSAoIGNhbVBvcyArIG1pbiggaW50ZXJzZWN0aW9uLCBpbnRlcnNlY3Rpb24yICkgKiBwICkgLyByYWRpdXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSB2ZWMzKCAwLjAsIDEuMCwgMC4wICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICAjaW5jbHVkZSA8Y29tbW9uPlxuICAgICAgICAjaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxuICAgICAgICB2b2lkIG1haW4oKSBcbiAgICAgICAge1xuICAgICAgICAgICAgdmVjMyBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uID0gcHJvamVjdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxuICAgICAgICAgICAgICAgIHZlYzMgb3V0Y29sb3IgPSB0ZXh0dXJlQ3ViZSggbWFwLCBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uICkucmdiO1xuICAgICAgICAgICAgI2Vsc2VcbiAgICAgICAgICAgICAgICB2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggcHJvamVjdGVkV29ybGRQb3NpdGlvbiApO1xuICAgICAgICAgICAgICAgIHZlYzIgdXYgPSBlcXVpcmVjdFV2KCBkaXJlY3Rpb24gKTtcbiAgICAgICAgICAgICAgICB2ZWMzIG91dGNvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHV2ICkucmdiO1xuICAgICAgICAgICAgI2VuZGlmXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRjb2xvciwgMS4wICk7XG4gICAgICAgICAgICAjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XG4gICAgICAgICAgICAjaW5jbHVkZSA8JHt2ZXJzaW9uID49IDE1NCA/IFwiY29sb3JzcGFjZV9mcmFnbWVudFwiIDogXCJlbmNvZGluZ3NfZnJhZ21lbnRcIn0+XG4gICAgICAgIH1cbiAgICAgICAgYDtcbiAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgIG1hcDogeyB2YWx1ZTogdGV4dHVyZSB9LFxuICAgICAgaGVpZ2h0OiB7IHZhbHVlOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWlnaHQpIHx8IDE1IH0sXG4gICAgICByYWRpdXM6IHsgdmFsdWU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnJhZGl1cykgfHwgMTAwIH1cbiAgICB9O1xuICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEljb3NhaGVkcm9uR2VvbWV0cnkoMSwgMTYpO1xuICAgIGNvbnN0IG1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKHtcbiAgICAgIHVuaWZvcm1zLFxuICAgICAgZnJhZ21lbnRTaGFkZXIsXG4gICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICBzaWRlOiBEb3VibGVTaWRlXG4gICAgfSk7XG4gICAgc3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgfVxuICBzZXQgcmFkaXVzKHJhZGl1cykge1xuICAgIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMucmFkaXVzLnZhbHVlID0gcmFkaXVzO1xuICB9XG4gIGdldCByYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwudW5pZm9ybXMucmFkaXVzLnZhbHVlO1xuICB9XG4gIHNldCBoZWlnaHQoaGVpZ2h0KSB7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5oZWlnaHQudmFsdWUgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5oZWlnaHQudmFsdWU7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIEdyb3VuZFByb2plY3RlZEVudlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyb3VuZFByb2plY3RlZEVudi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNZXNoIiwiSWNvc2FoZWRyb25HZW9tZXRyeSIsIlNoYWRlck1hdGVyaWFsIiwiRG91YmxlU2lkZSIsInZlcnNpb24iLCJpc0N1YmVUZXh0dXJlIiwiZGVmIiwiR3JvdW5kUHJvamVjdGVkRW52IiwiY29uc3RydWN0b3IiLCJ0ZXh0dXJlIiwib3B0aW9ucyIsIl9hIiwiX2IiLCJpc0N1YmVNYXAiLCJ3IiwiaW1hZ2UiLCJ3aWR0aCIsImN1YmVTaXplIiwiX2xvZE1heCIsIk1hdGgiLCJmbG9vciIsImxvZzIiLCJfY3ViZVNpemUiLCJwb3ciLCJtYXgiLCJoZWlnaHQiLCJkZWZpbmVzIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJqb2luIiwidW5pZm9ybXMiLCJtYXAiLCJ2YWx1ZSIsInJhZGl1cyIsImdlb21ldHJ5IiwibWF0ZXJpYWwiLCJzaWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three-stdlib/shaders/HorizontalBlurShader.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalBlurShader: () => (/* binding */ HorizontalBlurShader)\n/* harmony export */ });\nconst HorizontalBlurShader = {\n    uniforms: {\n        tDiffuse: {\n            value: null\n        },\n        h: {\n            value: 1 / 512\n        }\n    },\n    vertexShader: /* glsl */ `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `,\n    fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n};\n //# sourceMappingURL=HorizontalBlurShader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3NoYWRlcnMvSG9yaXpvbnRhbEJsdXJTaGFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLHVCQUF1QjtJQUMzQkMsVUFBVTtRQUNSQyxVQUFVO1lBQUVDLE9BQU87UUFBSztRQUN4QkMsR0FBRztZQUFFRCxPQUFPLElBQUk7UUFBSTtJQUN0QjtJQUNBRSxjQUNFLFFBQVEsR0FDUixDQUFDOzs7Ozs7Ozs7RUFTSCxDQUFDO0lBRURDLGdCQUNFLFFBQVEsR0FDUixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVCSCxDQUFDO0FBRUg7QUFHRSxDQUNGLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3NoYWRlcnMvSG9yaXpvbnRhbEJsdXJTaGFkZXIuanM/MGJhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBIb3Jpem9udGFsQmx1clNoYWRlciA9IHtcbiAgdW5pZm9ybXM6IHtcbiAgICB0RGlmZnVzZTogeyB2YWx1ZTogbnVsbCB9LFxuICAgIGg6IHsgdmFsdWU6IDEgLyA1MTIgfVxuICB9LFxuICB2ZXJ0ZXhTaGFkZXI6IChcbiAgICAvKiBnbHNsICovXG4gICAgYFxuICAgICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgICAgdm9pZCBtYWluKCkge1xuXG4gICAgICAgIHZVdiA9IHV2O1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XG5cbiAgICAgIH1cbiAgYFxuICApLFxuICBmcmFnbWVudFNoYWRlcjogKFxuICAgIC8qIGdsc2wgKi9cbiAgICBgXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XG4gICAgdW5pZm9ybSBmbG9hdCBoO1xuXG4gICAgdmFyeWluZyB2ZWMyIHZVdjtcblxuICAgIHZvaWQgbWFpbigpIHtcblxuICAgIFx0dmVjNCBzdW0gPSB2ZWM0KCAwLjAgKTtcblxuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54IC0gNC4wICogaCwgdlV2LnkgKSApICogMC4wNTE7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggLSAzLjAgKiBoLCB2VXYueSApICkgKiAwLjA5MTg7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggLSAyLjAgKiBoLCB2VXYueSApICkgKiAwLjEyMjQ1O1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54IC0gMS4wICogaCwgdlV2LnkgKSApICogMC4xNTMxO1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSApICkgKiAwLjE2MzM7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggKyAxLjAgKiBoLCB2VXYueSApICkgKiAwLjE1MzE7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggKyAyLjAgKiBoLCB2VXYueSApICkgKiAwLjEyMjQ1O1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgMy4wICogaCwgdlV2LnkgKSApICogMC4wOTE4O1xuICAgIFx0c3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54ICsgNC4wICogaCwgdlV2LnkgKSApICogMC4wNTE7XG5cbiAgICBcdGdsX0ZyYWdDb2xvciA9IHN1bTtcblxuICAgIH1cbiAgYFxuICApXG59O1xuZXhwb3J0IHtcbiAgSG9yaXpvbnRhbEJsdXJTaGFkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ib3Jpem9udGFsQmx1clNoYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJIb3Jpem9udGFsQmx1clNoYWRlciIsInVuaWZvcm1zIiwidERpZmZ1c2UiLCJ2YWx1ZSIsImgiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/shaders/VerticalBlurShader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/shaders/VerticalBlurShader.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VerticalBlurShader: () => (/* binding */ VerticalBlurShader)\n/* harmony export */ });\nconst VerticalBlurShader = {\n    uniforms: {\n        tDiffuse: {\n            value: null\n        },\n        v: {\n            value: 1 / 512\n        }\n    },\n    vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n    fragmentShader: /* glsl */ `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n};\n //# sourceMappingURL=VerticalBlurShader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3NoYWRlcnMvVmVydGljYWxCbHVyU2hhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxxQkFBcUI7SUFDekJDLFVBQVU7UUFDUkMsVUFBVTtZQUFFQyxPQUFPO1FBQUs7UUFDeEJDLEdBQUc7WUFBRUQsT0FBTyxJQUFJO1FBQUk7SUFDdEI7SUFDQUUsY0FDRSxRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7O0VBU0gsQ0FBQztJQUVEQyxnQkFDRSxRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0JILENBQUM7QUFFSDtBQUdFLENBQ0YsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvc2hhZGVycy9WZXJ0aWNhbEJsdXJTaGFkZXIuanM/MjE0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBWZXJ0aWNhbEJsdXJTaGFkZXIgPSB7XG4gIHVuaWZvcm1zOiB7XG4gICAgdERpZmZ1c2U6IHsgdmFsdWU6IG51bGwgfSxcbiAgICB2OiB7IHZhbHVlOiAxIC8gNTEyIH1cbiAgfSxcbiAgdmVydGV4U2hhZGVyOiAoXG4gICAgLyogZ2xzbCAqL1xuICAgIGBcbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdm9pZCBtYWluKCkge1xuXG4gICAgICB2VXYgPSB1djtcbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcblxuICAgIH1cbiAgYFxuICApLFxuICBmcmFnbWVudFNoYWRlcjogKFxuICAgIC8qIGdsc2wgKi9cbiAgICBgXG5cbiAgdW5pZm9ybSBzYW1wbGVyMkQgdERpZmZ1c2U7XG4gIHVuaWZvcm0gZmxvYXQgdjtcblxuICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gIHZvaWQgbWFpbigpIHtcblxuICAgIHZlYzQgc3VtID0gdmVjNCggMC4wICk7XG5cbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gNC4wICogdiApICkgKiAwLjA1MTtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gMy4wICogdiApICkgKiAwLjA5MTg7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSAtIDIuMCAqIHYgKSApICogMC4xMjI0NTtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gMS4wICogdiApICkgKiAwLjE1MzE7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSApICkgKiAwLjE2MzM7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDEuMCAqIHYgKSApICogMC4xNTMxO1xuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgKyAyLjAgKiB2ICkgKSAqIDAuMTIyNDU7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDMuMCAqIHYgKSApICogMC4wOTE4O1xuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgKyA0LjAgKiB2ICkgKSAqIDAuMDUxO1xuXG4gICAgZ2xfRnJhZ0NvbG9yID0gc3VtO1xuXG4gIH1cbiAgYFxuICApXG59O1xuZXhwb3J0IHtcbiAgVmVydGljYWxCbHVyU2hhZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVydGljYWxCbHVyU2hhZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlZlcnRpY2FsQmx1clNoYWRlciIsInVuaWZvcm1zIiwidERpZmZ1c2UiLCJ2YWx1ZSIsInYiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/shaders/VerticalBlurShader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/types/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/three-stdlib/types/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getWithKey: () => (/* binding */ getWithKey)\n/* harmony export */ });\nconst getWithKey = (obj, key)=>obj[key];\n //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3R5cGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWEsQ0FBQ0MsS0FBS0MsTUFBUUQsR0FBRyxDQUFDQyxJQUFJO0FBR3ZDLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvdHlwZXMvaGVscGVycy5qcz8yZjRmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGdldFdpdGhLZXkgPSAob2JqLCBrZXkpID0+IG9ialtrZXldO1xuZXhwb3J0IHtcbiAgZ2V0V2l0aEtleVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0V2l0aEtleSIsIm9iaiIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/types/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js":
/*!****************************************************************!*\
  !*** ./node_modules/three-stdlib/utils/BufferGeometryUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeMorphedAttributes: () => (/* binding */ computeMorphedAttributes),\n/* harmony export */   estimateBytesUsed: () => (/* binding */ estimateBytesUsed),\n/* harmony export */   interleaveAttributes: () => (/* binding */ interleaveAttributes),\n/* harmony export */   mergeBufferAttributes: () => (/* binding */ mergeBufferAttributes),\n/* harmony export */   mergeBufferGeometries: () => (/* binding */ mergeBufferGeometries),\n/* harmony export */   mergeVertices: () => (/* binding */ mergeVertices),\n/* harmony export */   toCreasedNormals: () => (/* binding */ toCreasedNormals),\n/* harmony export */   toTrianglesDrawMode: () => (/* binding */ toTrianglesDrawMode)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _types_helpers_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/helpers.js */ \"(ssr)/./node_modules/three-stdlib/types/helpers.js\");\n\n\nconst mergeBufferGeometries = (geometries, useGroups)=>{\n    const isIndexed = geometries[0].index !== null;\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n    const attributes = {};\n    const morphAttributes = {};\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();\n    let offset = 0;\n    geometries.forEach((geom, i)=>{\n        let attributesCount = 0;\n        if (isIndexed !== (geom.index !== null)) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\");\n            return null;\n        }\n        for(let name in geom.attributes){\n            if (!attributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n            }\n            if (attributes[name] === void 0) {\n                attributes[name] = [];\n            }\n            attributes[name].push(geom.attributes[name]);\n            attributesCount++;\n        }\n        if (attributesCount !== attributesUsed.size) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\");\n            return null;\n        }\n        if (morphTargetsRelative !== geom.morphTargetsRelative) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\");\n            return null;\n        }\n        for(let name in geom.morphAttributes){\n            if (!morphAttributesUsed.has(name)) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\");\n                return null;\n            }\n            if (morphAttributes[name] === void 0) morphAttributes[name] = [];\n            morphAttributes[name].push(geom.morphAttributes[name]);\n        }\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geom.userData);\n        if (useGroups) {\n            let count;\n            if (geom.index) {\n                count = geom.index.count;\n            } else if (geom.attributes.position !== void 0) {\n                count = geom.attributes.position.count;\n            } else {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\");\n                return null;\n            }\n            mergedGeometry.addGroup(offset, count, i);\n            offset += count;\n        }\n    });\n    if (isIndexed) {\n        let indexOffset = 0;\n        const mergedIndex = [];\n        geometries.forEach((geom)=>{\n            const index = geom.index;\n            for(let j = 0; j < index.count; ++j){\n                mergedIndex.push(index.getX(j) + indexOffset);\n            }\n            indexOffset += geom.attributes.position.count;\n        });\n        mergedGeometry.setIndex(mergedIndex);\n    }\n    for(let name in attributes){\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n        if (!mergedAttribute) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\");\n            return null;\n        }\n        mergedGeometry.setAttribute(name, mergedAttribute);\n    }\n    for(let name in morphAttributes){\n        const numMorphTargets = morphAttributes[name][0].length;\n        if (numMorphTargets === 0) break;\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n        for(let i = 0; i < numMorphTargets; ++i){\n            const morphAttributesToMerge = [];\n            for(let j = 0; j < morphAttributes[name].length; ++j){\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n            }\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n            if (!mergedMorphAttribute) {\n                console.error(\"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\");\n                return null;\n            }\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n        }\n    }\n    return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let itemSize = void 0;\n    let normalized = void 0;\n    let arrayLength = 0;\n    attributes.forEach((attr)=>{\n        if (TypedArray === void 0) {\n            TypedArray = attr.array.constructor;\n        }\n        if (TypedArray !== attr.array.constructor) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\");\n            return null;\n        }\n        if (itemSize === void 0) itemSize = attr.itemSize;\n        if (itemSize !== attr.itemSize) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\");\n            return null;\n        }\n        if (normalized === void 0) normalized = attr.normalized;\n        if (normalized !== attr.normalized) {\n            console.error(\"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\");\n            return null;\n        }\n        arrayLength += attr.array.length;\n    });\n    if (TypedArray && itemSize) {\n        const array = new TypedArray(arrayLength);\n        let offset = 0;\n        attributes.forEach((attr)=>{\n            array.set(attr.array, offset);\n            offset += attr.array.length;\n        });\n        return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n    }\n};\nconst interleaveAttributes = (attributes)=>{\n    let TypedArray = void 0;\n    let arrayLength = 0;\n    let stride = 0;\n    for(let i = 0, l = attributes.length; i < l; ++i){\n        const attribute = attributes[i];\n        if (TypedArray === void 0) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n            console.error(\"AttributeBuffers of different types cannot be interleaved\");\n            return null;\n        }\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n    }\n    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    const setters = [\n        \"setX\",\n        \"setY\",\n        \"setZ\",\n        \"setW\"\n    ];\n    for(let j = 0, l = attributes.length; j < l; j++){\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n        offset += itemSize;\n        for(let c = 0; c < count; c++){\n            for(let k = 0; k < itemSize; k++){\n                const set = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(iba, setters[k]);\n                const get = (0,_types_helpers_js__WEBPACK_IMPORTED_MODULE_1__.getWithKey)(attribute, getters[k]);\n                set(c, get(c));\n            }\n        }\n    }\n    return res;\n};\nfunction estimateBytesUsed(geometry) {\n    let mem = 0;\n    for(let name in geometry.attributes){\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n    }\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n    tolerance = Math.max(tolerance, Number.EPSILON);\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute(\"position\");\n    const vertexCount = indices ? indices.count : positions.count;\n    let nextIndex = 0;\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\",\n        \"getW\"\n    ];\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        attrArrays[name] = [];\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(()=>[]);\n        }\n    }\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for(let i = 0; i < vertexCount; i++){\n        const index = indices ? indices.getX(i) : i;\n        let hash = \"\";\n        for(let j = 0, l = attributeNames.length; j < l; j++){\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n            for(let k = 0; k < itemSize; k++){\n                hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n            }\n        }\n        if (hash in hashToIndex) {\n            newIndices.push(hashToIndex[hash]);\n        } else {\n            for(let j = 0, l = attributeNames.length; j < l; j++){\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n                for(let k = 0; k < itemSize; k++){\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n                    if (morphAttr) {\n                        for(let m = 0, ml = morphAttr.length; m < ml; m++){\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n                        }\n                    }\n                }\n            }\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n        }\n    }\n    const result = geometry.clone();\n    for(let i = 0, l = attributeNames.length; i < l; i++){\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n        result.setAttribute(name, attribute);\n        if (name in morphAttrsArrays) {\n            for(let j = 0; j < morphAttrsArrays[name].length; j++){\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n                const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n            }\n        }\n    }\n    result.setIndex(newIndices);\n    return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {\n        console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n        return geometry;\n    }\n    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {\n        let index = geometry.getIndex();\n        if (index === null) {\n            const indices = [];\n            const position = geometry.getAttribute(\"position\");\n            if (position !== void 0) {\n                for(let i = 0; i < position.count; i++){\n                    indices.push(i);\n                }\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n            } else {\n                console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n                return geometry;\n            }\n        }\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n        if (index) {\n            if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n                for(let i = 1; i <= numberOfTriangles; i++){\n                    newIndices.push(index.getX(0));\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                }\n            } else {\n                for(let i = 0; i < numberOfTriangles; i++){\n                    if (i % 2 === 0) {\n                        newIndices.push(index.getX(i));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i + 2));\n                    } else {\n                        newIndices.push(index.getX(i + 2));\n                        newIndices.push(index.getX(i + 1));\n                        newIndices.push(index.getX(i));\n                    }\n                }\n            }\n        }\n        if (newIndices.length / 3 !== numberOfTriangles) {\n            console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n        }\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n        return newGeometry;\n    } else {\n        console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n        return geometry;\n    }\n}\nfunction computeMorphedAttributes(object) {\n    if (object.geometry.isBufferGeometry !== true) {\n        console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n        return null;\n    }\n    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n        _vA.fromBufferAttribute(attribute, a2);\n        _vB.fromBufferAttribute(attribute, b2);\n        _vC.fromBufferAttribute(attribute, c2);\n        const morphInfluences = object2.morphTargetInfluences;\n        if (// @ts-ignore\n        material2.morphTargets && morphAttribute && morphInfluences) {\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n            for(let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++){\n                const influence = morphInfluences[i2];\n                const morph = morphAttribute[i2];\n                if (influence === 0) continue;\n                _tempA.fromBufferAttribute(morph, a2);\n                _tempB.fromBufferAttribute(morph, b2);\n                _tempC.fromBufferAttribute(morph, c2);\n                if (morphTargetsRelative2) {\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n                } else {\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n                }\n            }\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n        }\n        if (object2.isSkinnedMesh) {\n            object2.boneTransform(a2, _vA);\n            object2.boneTransform(b2, _vB);\n            object2.boneTransform(c2, _vC);\n        }\n        modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n    }\n    const geometry = object.geometry;\n    const material = object.material;\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n    if (index !== null) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    } else if (positionAttribute !== void 0) {\n        if (Array.isArray(material)) {\n            for(i = 0, il = groups.length; i < il; i++){\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n                for(j = start, jl = end; j < jl; j += 3){\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n                    _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                    _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n                }\n            }\n        } else {\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n            for(i = start, il = end; i < il; i += 3){\n                a = i;\n                b = i + 1;\n                c = i + 2;\n                _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n                _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n            }\n        }\n    }\n    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);\n    return {\n        positionAttribute,\n        normalAttribute,\n        morphedPositionAttribute,\n        morphedNormalAttribute\n    };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n    const creaseDot = Math.cos(creaseAngle);\n    const hashMultiplier = (1 + 1e-10) * 100;\n    const verts = [\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n        new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()\n    ];\n    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function hashVertex(v) {\n        const x = ~~(v.x * hashMultiplier);\n        const y = ~~(v.y * hashMultiplier);\n        const z = ~~(v.z * hashMultiplier);\n        return `${x},${y},${z}`;\n    }\n    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n    const posAttr = resultGeometry.attributes.position;\n    const vertexMap = {};\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            if (!(hash in vertexMap)) {\n                vertexMap[hash] = [];\n            }\n            vertexMap[hash].push(normal);\n        }\n    }\n    const normalArray = new Float32Array(posAttr.count * 3);\n    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, false);\n    for(let i = 0, l = posAttr.count / 3; i < l; i++){\n        const i3 = 3 * i;\n        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n        tempVec1.subVectors(c, b);\n        tempVec2.subVectors(a, b);\n        tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n        for(let n = 0; n < 3; n++){\n            const vert = verts[n];\n            const hash = hashVertex(vert);\n            const otherNormals = vertexMap[hash];\n            tempNorm2.set(0, 0, 0);\n            for(let k = 0, lk = otherNormals.length; k < lk; k++){\n                const otherNorm = otherNormals[k];\n                if (tempNorm.dot(otherNorm) > creaseDot) {\n                    tempNorm2.add(otherNorm);\n                }\n            }\n            tempNorm2.normalize();\n            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n        }\n    }\n    resultGeometry.setAttribute(\"normal\", normAttr);\n    return resultGeometry;\n}\n //# sourceMappingURL=BufferGeometryUtils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF1TTtBQUN0SjtBQUNqRCxNQUFNVSx3QkFBd0IsQ0FBQ0MsWUFBWUM7SUFDekMsTUFBTUMsWUFBWUYsVUFBVSxDQUFDLEVBQUUsQ0FBQ0csS0FBSyxLQUFLO0lBQzFDLE1BQU1DLGlCQUFpQixJQUFJQyxJQUFJQyxPQUFPQyxJQUFJLENBQUNQLFVBQVUsQ0FBQyxFQUFFLENBQUNRLFVBQVU7SUFDbkUsTUFBTUMsc0JBQXNCLElBQUlKLElBQUlDLE9BQU9DLElBQUksQ0FBQ1AsVUFBVSxDQUFDLEVBQUUsQ0FBQ1UsZUFBZTtJQUM3RSxNQUFNRixhQUFhLENBQUM7SUFDcEIsTUFBTUUsa0JBQWtCLENBQUM7SUFDekIsTUFBTUMsdUJBQXVCWCxVQUFVLENBQUMsRUFBRSxDQUFDVyxvQkFBb0I7SUFDL0QsTUFBTUMsaUJBQWlCLElBQUl2QixpREFBY0E7SUFDekMsSUFBSXdCLFNBQVM7SUFDYmIsV0FBV2MsT0FBTyxDQUFDLENBQUNDLE1BQU1DO1FBQ3hCLElBQUlDLGtCQUFrQjtRQUN0QixJQUFJZixjQUFlYSxDQUFBQSxLQUFLWixLQUFLLEtBQUssSUFBRyxHQUFJO1lBQ3ZDZSxRQUFRQyxLQUFLLENBQ1gsdUZBQXVGSCxJQUFJO1lBRTdGLE9BQU87UUFDVDtRQUNBLElBQUssSUFBSUksUUFBUUwsS0FBS1AsVUFBVSxDQUFFO1lBQ2hDLElBQUksQ0FBQ0osZUFBZWlCLEdBQUcsQ0FBQ0QsT0FBTztnQkFDN0JGLFFBQVFDLEtBQUssQ0FDWCx1RkFBdUZILElBQUksa0VBQWtFSSxPQUFPO2dCQUV0SyxPQUFPO1lBQ1Q7WUFDQSxJQUFJWixVQUFVLENBQUNZLEtBQUssS0FBSyxLQUFLLEdBQUc7Z0JBQy9CWixVQUFVLENBQUNZLEtBQUssR0FBRyxFQUFFO1lBQ3ZCO1lBQ0FaLFVBQVUsQ0FBQ1ksS0FBSyxD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ZXMvdGhyZWUtc3RkbGliL3V0aWxzL0J1ZmZlckdlb21ldHJ5VXRpbHMuanM/MTJlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgQnVmZmVyQXR0cmlidXRlLCBJbnRlcmxlYXZlZEJ1ZmZlciwgSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsIFRyaWFuZ2xlc0RyYXdNb2RlLCBUcmlhbmdsZUZhbkRyYXdNb2RlLCBUcmlhbmdsZVN0cmlwRHJhd01vZGUsIFZlY3RvcjMsIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgfSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCB7IGdldFdpdGhLZXkgfSBmcm9tIFwiLi4vdHlwZXMvaGVscGVycy5qc1wiO1xuY29uc3QgbWVyZ2VCdWZmZXJHZW9tZXRyaWVzID0gKGdlb21ldHJpZXMsIHVzZUdyb3VwcykgPT4ge1xuICBjb25zdCBpc0luZGV4ZWQgPSBnZW9tZXRyaWVzWzBdLmluZGV4ICE9PSBudWxsO1xuICBjb25zdCBhdHRyaWJ1dGVzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZ2VvbWV0cmllc1swXS5hdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IG1vcnBoQXR0cmlidXRlc1VzZWQgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGdlb21ldHJpZXNbMF0ubW9ycGhBdHRyaWJ1dGVzKSk7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyaWJ1dGVzID0ge307XG4gIGNvbnN0IG1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gZ2VvbWV0cmllc1swXS5tb3JwaFRhcmdldHNSZWxhdGl2ZTtcbiAgY29uc3QgbWVyZ2VkR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGdlb21ldHJpZXMuZm9yRWFjaCgoZ2VvbSwgaSkgPT4ge1xuICAgIGxldCBhdHRyaWJ1dGVzQ291bnQgPSAwO1xuICAgIGlmIChpc0luZGV4ZWQgIT09IChnZW9tLmluZGV4ICE9PSBudWxsKSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgXCIuIEFsbCBnZW9tZXRyaWVzIG11c3QgaGF2ZSBjb21wYXRpYmxlIGF0dHJpYnV0ZXM7IG1ha2Ugc3VyZSBpbmRleCBhdHRyaWJ1dGUgZXhpc3RzIGFtb25nIGFsbCBnZW9tZXRyaWVzLCBvciBpbiBub25lIG9mIHRoZW0uXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghYXR0cmlidXRlc1VzZWQuaGFzKG5hbWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJHZW9tZXRyaWVzKCkgZmFpbGVkIHdpdGggZ2VvbWV0cnkgYXQgaW5kZXggXCIgKyBpICsgJy4gQWxsIGdlb21ldHJpZXMgbXVzdCBoYXZlIGNvbXBhdGlibGUgYXR0cmlidXRlczsgbWFrZSBzdXJlIFwiJyArIG5hbWUgKyAnXCIgYXR0cmlidXRlIGV4aXN0cyBhbW9uZyBhbGwgZ2VvbWV0cmllcywgb3IgaW4gbm9uZSBvZiB0aGVtLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlc1tuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLmF0dHJpYnV0ZXNbbmFtZV0pO1xuICAgICAgYXR0cmlidXRlc0NvdW50Kys7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzQ291bnQgIT09IGF0dHJpYnV0ZXNVc2VkLnNpemUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiBNYWtlIHN1cmUgYWxsIGdlb21ldHJpZXMgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgYXR0cmlidXRlcy5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAobW9ycGhUYXJnZXRzUmVsYXRpdmUgIT09IGdlb20ubW9ycGhUYXJnZXRzUmVsYXRpdmUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAubW9ycGhUYXJnZXRzUmVsYXRpdmUgbXVzdCBiZSBjb25zaXN0ZW50IHRocm91Z2hvdXQgYWxsIGdlb21ldHJpZXMuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChsZXQgbmFtZSBpbiBnZW9tLm1vcnBoQXR0cmlidXRlcykge1xuICAgICAgaWYgKCFtb3JwaEF0dHJpYnV0ZXNVc2VkLmhhcyhuYW1lKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aXRoIGdlb21ldHJ5IGF0IGluZGV4IFwiICsgaSArIFwiLiAgLm1vcnBoQXR0cmlidXRlcyBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCBhbGwgZ2VvbWV0cmllcy5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChtb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPT09IHZvaWQgMClcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzW25hbWVdID0gW107XG4gICAgICBtb3JwaEF0dHJpYnV0ZXNbbmFtZV0ucHVzaChnZW9tLm1vcnBoQXR0cmlidXRlc1tuYW1lXSk7XG4gICAgfVxuICAgIG1lcmdlZEdlb21ldHJ5LnVzZXJEYXRhLm1lcmdlZFVzZXJEYXRhID0gbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEgfHwgW107XG4gICAgbWVyZ2VkR2VvbWV0cnkudXNlckRhdGEubWVyZ2VkVXNlckRhdGEucHVzaChnZW9tLnVzZXJEYXRhKTtcbiAgICBpZiAodXNlR3JvdXBzKSB7XG4gICAgICBsZXQgY291bnQ7XG4gICAgICBpZiAoZ2VvbS5pbmRleCkge1xuICAgICAgICBjb3VudCA9IGdlb20uaW5kZXguY291bnQ7XG4gICAgICB9IGVsc2UgaWYgKGdlb20uYXR0cmlidXRlcy5wb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvdW50ID0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHM6IC5tZXJnZUJ1ZmZlckdlb21ldHJpZXMoKSBmYWlsZWQgd2l0aCBnZW9tZXRyeSBhdCBpbmRleCBcIiArIGkgKyBcIi4gVGhlIGdlb21ldHJ5IG11c3QgaGF2ZSBlaXRoZXIgYW4gaW5kZXggb3IgYSBwb3NpdGlvbiBhdHRyaWJ1dGVcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG1lcmdlZEdlb21ldHJ5LmFkZEdyb3VwKG9mZnNldCwgY291bnQsIGkpO1xuICAgICAgb2Zmc2V0ICs9IGNvdW50O1xuICAgIH1cbiAgfSk7XG4gIGlmIChpc0luZGV4ZWQpIHtcbiAgICBsZXQgaW5kZXhPZmZzZXQgPSAwO1xuICAgIGNvbnN0IG1lcmdlZEluZGV4ID0gW107XG4gICAgZ2VvbWV0cmllcy5mb3JFYWNoKChnZW9tKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IGdlb20uaW5kZXg7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGV4LmNvdW50OyArK2opIHtcbiAgICAgICAgbWVyZ2VkSW5kZXgucHVzaChpbmRleC5nZXRYKGopICsgaW5kZXhPZmZzZXQpO1xuICAgICAgfVxuICAgICAgaW5kZXhPZmZzZXQgKz0gZ2VvbS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuICAgIH0pO1xuICAgIG1lcmdlZEdlb21ldHJ5LnNldEluZGV4KG1lcmdlZEluZGV4KTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGUgPSBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMoYXR0cmlidXRlc1tuYW1lXSk7XG4gICAgaWYgKCFtZXJnZWRBdHRyaWJ1dGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIGF0dHJpYnV0ZS5cIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtZXJnZWRHZW9tZXRyeS5zZXRBdHRyaWJ1dGUobmFtZSwgbWVyZ2VkQXR0cmlidXRlKTtcbiAgfVxuICBmb3IgKGxldCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcykge1xuICAgIGNvbnN0IG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoQXR0cmlidXRlc1tuYW1lXVswXS5sZW5ndGg7XG4gICAgaWYgKG51bU1vcnBoVGFyZ2V0cyA9PT0gMClcbiAgICAgIGJyZWFrO1xuICAgIG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyA9IG1lcmdlZEdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyB8fCB7fTtcbiAgICBtZXJnZWRHZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV0gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgKytpKSB7XG4gICAgICBjb25zdCBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlID0gW107XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cmlidXRlc1tuYW1lXS5sZW5ndGg7ICsraikge1xuICAgICAgICBtb3JwaEF0dHJpYnV0ZXNUb01lcmdlLnB1c2gobW9ycGhBdHRyaWJ1dGVzW25hbWVdW2pdW2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lcmdlZE1vcnBoQXR0cmlidXRlID0gbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKG1vcnBoQXR0cmlidXRlc1RvTWVyZ2UpO1xuICAgICAgaWYgKCFtZXJnZWRNb3JwaEF0dHJpYnV0ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyR2VvbWV0cmllcygpIGZhaWxlZCB3aGlsZSB0cnlpbmcgdG8gbWVyZ2UgdGhlIFwiICsgbmFtZSArIFwiIG1vcnBoQXR0cmlidXRlLlwiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbWVyZ2VkR2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdLnB1c2gobWVyZ2VkTW9ycGhBdHRyaWJ1dGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VkR2VvbWV0cnk7XG59O1xuY29uc3QgbWVyZ2VCdWZmZXJBdHRyaWJ1dGVzID0gKGF0dHJpYnV0ZXMpID0+IHtcbiAgbGV0IFR5cGVkQXJyYXkgPSB2b2lkIDA7XG4gIGxldCBpdGVtU2l6ZSA9IHZvaWQgMDtcbiAgbGV0IG5vcm1hbGl6ZWQgPSB2b2lkIDA7XG4gIGxldCBhcnJheUxlbmd0aCA9IDA7XG4gIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgIGlmIChUeXBlZEFycmF5ID09PSB2b2lkIDApIHtcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyLmFycmF5LmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICBpZiAoVHlwZWRBcnJheSAhPT0gYXR0ci5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuYXJyYXkgbXVzdCBiZSBvZiBjb25zaXN0ZW50IGFycmF5IHR5cGVzIGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpdGVtU2l6ZSA9PT0gdm9pZCAwKVxuICAgICAgaXRlbVNpemUgPSBhdHRyLml0ZW1TaXplO1xuICAgIGlmIChpdGVtU2l6ZSAhPT0gYXR0ci5pdGVtU2l6ZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiAubWVyZ2VCdWZmZXJBdHRyaWJ1dGVzKCkgZmFpbGVkLiBCdWZmZXJBdHRyaWJ1dGUuaXRlbVNpemUgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkID09PSB2b2lkIDApXG4gICAgICBub3JtYWxpemVkID0gYXR0ci5ub3JtYWxpemVkO1xuICAgIGlmIChub3JtYWxpemVkICE9PSBhdHRyLm5vcm1hbGl6ZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlsczogLm1lcmdlQnVmZmVyQXR0cmlidXRlcygpIGZhaWxlZC4gQnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWQgbXVzdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBtYXRjaGluZyBhdHRyaWJ1dGVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFycmF5TGVuZ3RoICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICB9KTtcbiAgaWYgKFR5cGVkQXJyYXkgJiYgaXRlbVNpemUpIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBUeXBlZEFycmF5KGFycmF5TGVuZ3RoKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGFycmF5LnNldChhdHRyLmFycmF5LCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGF0dHIuYXJyYXkubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCk7XG4gIH1cbn07XG5jb25zdCBpbnRlcmxlYXZlQXR0cmlidXRlcyA9IChhdHRyaWJ1dGVzKSA9PiB7XG4gIGxldCBUeXBlZEFycmF5ID0gdm9pZCAwO1xuICBsZXQgYXJyYXlMZW5ndGggPSAwO1xuICBsZXQgc3RyaWRlID0gMDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG4gICAgaWYgKFR5cGVkQXJyYXkgPT09IHZvaWQgMClcbiAgICAgIFR5cGVkQXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3I7XG4gICAgaWYgKFR5cGVkQXJyYXkgIT09IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkF0dHJpYnV0ZUJ1ZmZlcnMgb2YgZGlmZmVyZW50IHR5cGVzIGNhbm5vdCBiZSBpbnRlcmxlYXZlZFwiKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhcnJheUxlbmd0aCArPSBhdHRyaWJ1dGUuYXJyYXkubGVuZ3RoO1xuICAgIHN0cmlkZSArPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gIH1cbiAgY29uc3QgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgSW50ZXJsZWF2ZWRCdWZmZXIobmV3IFR5cGVkQXJyYXkoYXJyYXlMZW5ndGgpLCBzdHJpZGUpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgcmVzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBjb25zdCBzZXR0ZXJzID0gW1wic2V0WFwiLCBcInNldFlcIiwgXCJzZXRaXCIsIFwic2V0V1wiXTtcbiAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XG4gICAgY29uc3QgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgY29uc3QgY291bnQgPSBhdHRyaWJ1dGUuY291bnQ7XG4gICAgY29uc3QgaWJhID0gbmV3IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBhdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgcmVzLnB1c2goaWJhKTtcbiAgICBvZmZzZXQgKz0gaXRlbVNpemU7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGl0ZW1TaXplOyBrKyspIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gZ2V0V2l0aEtleShpYmEsIHNldHRlcnNba10pO1xuICAgICAgICBjb25zdCBnZXQgPSBnZXRXaXRoS2V5KGF0dHJpYnV0ZSwgZ2V0dGVyc1trXSk7XG4gICAgICAgIHNldChjLCBnZXQoYykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmZ1bmN0aW9uIGVzdGltYXRlQnl0ZXNVc2VkKGdlb21ldHJ5KSB7XG4gIGxldCBtZW0gPSAwO1xuICBmb3IgKGxldCBuYW1lIGluIGdlb21ldHJ5LmF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBhdHRyID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIG1lbSArPSBhdHRyLmNvdW50ICogYXR0ci5pdGVtU2l6ZSAqIGF0dHIuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gIH1cbiAgY29uc3QgaW5kaWNlcyA9IGdlb21ldHJ5LmdldEluZGV4KCk7XG4gIG1lbSArPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCAqIGluZGljZXMuaXRlbVNpemUgKiBpbmRpY2VzLmFycmF5LkJZVEVTX1BFUl9FTEVNRU5UIDogMDtcbiAgcmV0dXJuIG1lbTtcbn1cbmZ1bmN0aW9uIG1lcmdlVmVydGljZXMoZ2VvbWV0cnksIHRvbGVyYW5jZSA9IDFlLTQpIHtcbiAgdG9sZXJhbmNlID0gTWF0aC5tYXgodG9sZXJhbmNlLCBOdW1iZXIuRVBTSUxPTik7XG4gIGNvbnN0IGhhc2hUb0luZGV4ID0ge307XG4gIGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICBjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgY29uc3QgdmVydGV4Q291bnQgPSBpbmRpY2VzID8gaW5kaWNlcy5jb3VudCA6IHBvc2l0aW9ucy5jb3VudDtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGF0dHJpYnV0ZU5hbWVzID0gT2JqZWN0LmtleXMoZ2VvbWV0cnkuYXR0cmlidXRlcyk7XG4gIGNvbnN0IGF0dHJBcnJheXMgPSB7fTtcbiAgY29uc3QgbW9ycGhBdHRyc0FycmF5cyA9IHt9O1xuICBjb25zdCBuZXdJbmRpY2VzID0gW107XG4gIGNvbnN0IGdldHRlcnMgPSBbXCJnZXRYXCIsIFwiZ2V0WVwiLCBcImdldFpcIiwgXCJnZXRXXCJdO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tpXTtcbiAgICBhdHRyQXJyYXlzW25hbWVdID0gW107XG4gICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgIGlmIChtb3JwaEF0dHIpIHtcbiAgICAgIG1vcnBoQXR0cnNBcnJheXNbbmFtZV0gPSBuZXcgQXJyYXkobW9ycGhBdHRyLmxlbmd0aCkuZmlsbCgwKS5tYXAoKCkgPT4gW10pO1xuICAgIH1cbiAgfVxuICBjb25zdCBkZWNpbWFsU2hpZnQgPSBNYXRoLmxvZzEwKDEgLyB0b2xlcmFuY2UpO1xuICBjb25zdCBzaGlmdE11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgZGVjaW1hbFNoaWZ0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgaW5kZXggPSBpbmRpY2VzID8gaW5kaWNlcy5nZXRYKGkpIDogaTtcbiAgICBsZXQgaGFzaCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaiA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBhdHRyaWJ1dGVOYW1lc1tqXTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIGNvbnN0IGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBpdGVtU2l6ZTsgaysrKSB7XG4gICAgICAgIGhhc2ggKz0gYCR7fn4oYXR0cmlidXRlW2dldHRlcnNba11dKGluZGV4KSAqIHNoaWZ0TXVsdGlwbGllcil9LGA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNoIGluIGhhc2hUb0luZGV4KSB7XG4gICAgICBuZXdJbmRpY2VzLnB1c2goaGFzaFRvSW5kZXhbaGFzaF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMCwgbCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbal07XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgY29uc3QgbW9ycGhBdHRyID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBjb25zdCBpdGVtU2l6ZSA9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcbiAgICAgICAgY29uc3QgbmV3YXJyYXkgPSBhdHRyQXJyYXlzW25hbWVdO1xuICAgICAgICBjb25zdCBuZXdNb3JwaEFycmF5cyA9IG1vcnBoQXR0cnNBcnJheXNbbmFtZV07XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgaXRlbVNpemU7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGdldHRlckZ1bmMgPSBnZXR0ZXJzW2tdO1xuICAgICAgICAgIG5ld2FycmF5LnB1c2goYXR0cmlidXRlW2dldHRlckZ1bmNdKGluZGV4KSk7XG4gICAgICAgICAgaWYgKG1vcnBoQXR0cikge1xuICAgICAgICAgICAgZm9yIChsZXQgbSA9IDAsIG1sID0gbW9ycGhBdHRyLmxlbmd0aDsgbSA8IG1sOyBtKyspIHtcbiAgICAgICAgICAgICAgbmV3TW9ycGhBcnJheXNbbV0ucHVzaChtb3JwaEF0dHJbbV1bZ2V0dGVyRnVuY10oaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhc2hUb0luZGV4W2hhc2hdID0gbmV4dEluZGV4O1xuICAgICAgbmV3SW5kaWNlcy5wdXNoKG5leHRJbmRleCk7XG4gICAgICBuZXh0SW5kZXgrKztcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb25zdCBuYW1lID0gYXR0cmlidXRlTmFtZXNbaV07XG4gICAgY29uc3Qgb2xkQXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBvbGRBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IoYXR0ckFycmF5c1tuYW1lXSk7XG4gICAgY29uc3QgYXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIsIG9sZEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkQXR0cmlidXRlLm5vcm1hbGl6ZWQpO1xuICAgIHJlc3VsdC5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cmlidXRlKTtcbiAgICBpZiAobmFtZSBpbiBtb3JwaEF0dHJzQXJyYXlzKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1vcnBoQXR0cnNBcnJheXNbbmFtZV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgb2xkTW9ycGhBdHRyaWJ1dGUgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal07XG4gICAgICAgIGNvbnN0IGJ1ZmZlcjIgPSBuZXcgb2xkTW9ycGhBdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IobW9ycGhBdHRyc0FycmF5c1tuYW1lXVtqXSk7XG4gICAgICAgIGNvbnN0IG1vcnBoQXR0cmlidXRlID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZShidWZmZXIyLCBvbGRNb3JwaEF0dHJpYnV0ZS5pdGVtU2l6ZSwgb2xkTW9ycGhBdHRyaWJ1dGUubm9ybWFsaXplZCk7XG4gICAgICAgIHJlc3VsdC5tb3JwaEF0dHJpYnV0ZXNbbmFtZV1bal0gPSBtb3JwaEF0dHJpYnV0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzdWx0LnNldEluZGV4KG5ld0luZGljZXMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9UcmlhbmdsZXNEcmF3TW9kZShnZW9tZXRyeSwgZHJhd01vZGUpIHtcbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZXNEcmF3TW9kZSkge1xuICAgIGNvbnNvbGUud2FybihcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBHZW9tZXRyeSBhbHJlYWR5IGRlZmluZWQgYXMgdHJpYW5nbGVzLlwiKTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG4gIH1cbiAgaWYgKGRyYXdNb2RlID09PSBUcmlhbmdsZUZhbkRyYXdNb2RlIHx8IGRyYXdNb2RlID09PSBUcmlhbmdsZVN0cmlwRHJhd01vZGUpIHtcbiAgICBsZXQgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgIGlmIChpbmRleCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5kaWNlcyA9IFtdO1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKTtcbiAgICAgIGlmIChwb3NpdGlvbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24uY291bnQ7IGkrKykge1xuICAgICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBnZW9tZXRyeS5zZXRJbmRleChpbmRpY2VzKTtcbiAgICAgICAgaW5kZXggPSBnZW9tZXRyeS5nZXRJbmRleCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlRIUkVFLkJ1ZmZlckdlb21ldHJ5VXRpbHMudG9UcmlhbmdsZXNEcmF3TW9kZSgpOiBVbmRlZmluZWQgcG9zaXRpb24gYXR0cmlidXRlLiBQcm9jZXNzaW5nIG5vdCBwb3NzaWJsZS5cIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG51bWJlck9mVHJpYW5nbGVzID0gaW5kZXguY291bnQgLSAyO1xuICAgIGNvbnN0IG5ld0luZGljZXMgPSBbXTtcbiAgICBpZiAoaW5kZXgpIHtcbiAgICAgIGlmIChkcmF3TW9kZSA9PT0gVHJpYW5nbGVGYW5EcmF3TW9kZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBudW1iZXJPZlRyaWFuZ2xlczsgaSsrKSB7XG4gICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoMCkpO1xuICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVHJpYW5nbGVzOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkgKyAxKSk7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdJbmRpY2VzLnB1c2goaW5kZXguZ2V0WChpICsgMikpO1xuICAgICAgICAgICAgbmV3SW5kaWNlcy5wdXNoKGluZGV4LmdldFgoaSArIDEpKTtcbiAgICAgICAgICAgIG5ld0luZGljZXMucHVzaChpbmRleC5nZXRYKGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld0luZGljZXMubGVuZ3RoIC8gMyAhPT0gbnVtYmVyT2ZUcmlhbmdsZXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzLnRvVHJpYW5nbGVzRHJhd01vZGUoKTogVW5hYmxlIHRvIGdlbmVyYXRlIGNvcnJlY3QgYW1vdW50IG9mIHRyaWFuZ2xlcy5cIik7XG4gICAgfVxuICAgIGNvbnN0IG5ld0dlb21ldHJ5ID0gZ2VvbWV0cnkuY2xvbmUoKTtcbiAgICBuZXdHZW9tZXRyeS5zZXRJbmRleChuZXdJbmRpY2VzKTtcbiAgICBuZXdHZW9tZXRyeS5jbGVhckdyb3VwcygpO1xuICAgIHJldHVybiBuZXdHZW9tZXRyeTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiVEhSRUUuQnVmZmVyR2VvbWV0cnlVdGlscy50b1RyaWFuZ2xlc0RyYXdNb2RlKCk6IFVua25vd24gZHJhdyBtb2RlOlwiLCBkcmF3TW9kZSk7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTW9ycGhlZEF0dHJpYnV0ZXMob2JqZWN0KSB7XG4gIGlmIChvYmplY3QuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSAhPT0gdHJ1ZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJUSFJFRS5CdWZmZXJHZW9tZXRyeVV0aWxzOiBHZW9tZXRyeSBpcyBub3Qgb2YgdHlwZSBCdWZmZXJHZW9tZXRyeS5cIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgX3ZBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3ZDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBBID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBCID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX3RlbXBDID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgX21vcnBoQSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IF9tb3JwaEIgPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCBfbW9ycGhDID0gbmV3IFZlY3RvcjMoKTtcbiAgZnVuY3Rpb24gX2NhbGN1bGF0ZU1vcnBoZWRBdHRyaWJ1dGVEYXRhKG9iamVjdDIsIG1hdGVyaWFsMiwgYXR0cmlidXRlLCBtb3JwaEF0dHJpYnV0ZSwgbW9ycGhUYXJnZXRzUmVsYXRpdmUyLCBhMiwgYjIsIGMyLCBtb2RpZmllZEF0dHJpYnV0ZUFycmF5KSB7XG4gICAgX3ZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBhMik7XG4gICAgX3ZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBiMik7XG4gICAgX3ZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoYXR0cmlidXRlLCBjMik7XG4gICAgY29uc3QgbW9ycGhJbmZsdWVuY2VzID0gb2JqZWN0Mi5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG4gICAgaWYgKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbWF0ZXJpYWwyLm1vcnBoVGFyZ2V0cyAmJiBtb3JwaEF0dHJpYnV0ZSAmJiBtb3JwaEluZmx1ZW5jZXNcbiAgICApIHtcbiAgICAgIF9tb3JwaEEuc2V0KDAsIDAsIDApO1xuICAgICAgX21vcnBoQi5zZXQoMCwgMCwgMCk7XG4gICAgICBfbW9ycGhDLnNldCgwLCAwLCAwKTtcbiAgICAgIGZvciAobGV0IGkyID0gMCwgaWwyID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpMiA8IGlsMjsgaTIrKykge1xuICAgICAgICBjb25zdCBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbaTJdO1xuICAgICAgICBjb25zdCBtb3JwaCA9IG1vcnBoQXR0cmlidXRlW2kyXTtcbiAgICAgICAgaWYgKGluZmx1ZW5jZSA9PT0gMClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgX3RlbXBBLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGEyKTtcbiAgICAgICAgX3RlbXBCLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGIyKTtcbiAgICAgICAgX3RlbXBDLmZyb21CdWZmZXJBdHRyaWJ1dGUobW9ycGgsIGMyKTtcbiAgICAgICAgaWYgKG1vcnBoVGFyZ2V0c1JlbGF0aXZlMikge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIsIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLCBpbmZsdWVuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9tb3JwaEEuYWRkU2NhbGVkVmVjdG9yKF90ZW1wQS5zdWIoX3ZBKSwgaW5mbHVlbmNlKTtcbiAgICAgICAgICBfbW9ycGhCLmFkZFNjYWxlZFZlY3RvcihfdGVtcEIuc3ViKF92QiksIGluZmx1ZW5jZSk7XG4gICAgICAgICAgX21vcnBoQy5hZGRTY2FsZWRWZWN0b3IoX3RlbXBDLnN1YihfdkMpLCBpbmZsdWVuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfdkEuYWRkKF9tb3JwaEEpO1xuICAgICAgX3ZCLmFkZChfbW9ycGhCKTtcbiAgICAgIF92Qy5hZGQoX21vcnBoQyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QyLmlzU2tpbm5lZE1lc2gpIHtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShhMiwgX3ZBKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShiMiwgX3ZCKTtcbiAgICAgIG9iamVjdDIuYm9uZVRyYW5zZm9ybShjMiwgX3ZDKTtcbiAgICB9XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVthMiAqIDMgKyAwXSA9IF92QS54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYTIgKiAzICsgMV0gPSBfdkEueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2EyICogMyArIDJdID0gX3ZBLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtiMiAqIDMgKyAwXSA9IF92Qi54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYjIgKiAzICsgMV0gPSBfdkIueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2IyICogMyArIDJdID0gX3ZCLno7XG4gICAgbW9kaWZpZWRBdHRyaWJ1dGVBcnJheVtjMiAqIDMgKyAwXSA9IF92Qy54O1xuICAgIG1vZGlmaWVkQXR0cmlidXRlQXJyYXlbYzIgKiAzICsgMV0gPSBfdkMueTtcbiAgICBtb2RpZmllZEF0dHJpYnV0ZUFycmF5W2MyICogMyArIDJdID0gX3ZDLno7XG4gIH1cbiAgY29uc3QgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gIGNvbnN0IG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuICBsZXQgYSwgYiwgYztcbiAgY29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgY29uc3QgcG9zaXRpb25BdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFBvc2l0aW9uID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICBjb25zdCBtb3JwaFRhcmdldHNSZWxhdGl2ZSA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1JlbGF0aXZlO1xuICBjb25zdCBub3JtYWxBdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcbiAgY29uc3QgbW9ycGhOb3JtYWwgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgY29uc3QgZHJhd1JhbmdlID0gZ2VvbWV0cnkuZHJhd1JhbmdlO1xuICBsZXQgaSwgaiwgaWwsIGpsO1xuICBsZXQgZ3JvdXAsIGdyb3VwTWF0ZXJpYWw7XG4gIGxldCBzdGFydCwgZW5kO1xuICBjb25zdCBtb2RpZmllZFBvc2l0aW9uID0gbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbkF0dHJpYnV0ZS5jb3VudCAqIHBvc2l0aW9uQXR0cmlidXRlLml0ZW1TaXplKTtcbiAgY29uc3QgbW9kaWZpZWROb3JtYWwgPSBuZXcgRmxvYXQzMkFycmF5KG5vcm1hbEF0dHJpYnV0ZS5jb3VudCAqIG5vcm1hbEF0dHJpYnV0ZS5pdGVtU2l6ZSk7XG4gIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdGVyaWFsKSkge1xuICAgICAgZm9yIChpID0gMCwgaWwgPSBncm91cHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsW2dyb3VwLm1hdGVyaWFsSW5kZXhdO1xuICAgICAgICBzdGFydCA9IE1hdGgubWF4KGdyb3VwLnN0YXJ0LCBkcmF3UmFuZ2Uuc3RhcnQpO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihncm91cC5zdGFydCArIGdyb3VwLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgICBmb3IgKGogPSBzdGFydCwgamwgPSBlbmQ7IGogPCBqbDsgaiArPSAzKSB7XG4gICAgICAgICAgYSA9IGluZGV4LmdldFgoaik7XG4gICAgICAgICAgYiA9IGluZGV4LmdldFgoaiArIDEpO1xuICAgICAgICAgIGMgPSBpbmRleC5nZXRYKGogKyAyKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaFBvc2l0aW9uLFxuICAgICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICAgKTtcbiAgICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBncm91cE1hdGVyaWFsLFxuICAgICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgICAgbW9ycGhOb3JtYWwsXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KDAsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICBlbmQgPSBNYXRoLm1pbihpbmRleC5jb3VudCwgZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50KTtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbCA9IGVuZDsgaSA8IGlsOyBpICs9IDMpIHtcbiAgICAgICAgYSA9IGluZGV4LmdldFgoaSk7XG4gICAgICAgIGIgPSBpbmRleC5nZXRYKGkgKyAxKTtcbiAgICAgICAgYyA9IGluZGV4LmdldFgoaSArIDIpO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgbW9ycGhUYXJnZXRzUmVsYXRpdmUsXG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIGMsXG4gICAgICAgICAgbW9kaWZpZWRQb3NpdGlvblxuICAgICAgICApO1xuICAgICAgICBfY2FsY3VsYXRlTW9ycGhlZEF0dHJpYnV0ZURhdGEoXG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZE5vcm1hbFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwb3NpdGlvbkF0dHJpYnV0ZSAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpKSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICAgIGdyb3VwID0gZ3JvdXBzW2ldO1xuICAgICAgICBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbZ3JvdXAubWF0ZXJpYWxJbmRleF07XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoZ3JvdXAuc3RhcnQsIGRyYXdSYW5nZS5zdGFydCk7XG4gICAgICAgIGVuZCA9IE1hdGgubWluKGdyb3VwLnN0YXJ0ICsgZ3JvdXAuY291bnQsIGRyYXdSYW5nZS5zdGFydCArIGRyYXdSYW5nZS5jb3VudCk7XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0LCBqbCA9IGVuZDsgaiA8IGpsOyBqICs9IDMpIHtcbiAgICAgICAgICBhID0gajtcbiAgICAgICAgICBiID0gaiArIDE7XG4gICAgICAgICAgYyA9IGogKyAyO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBwb3NpdGlvbkF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG1vcnBoUG9zaXRpb24sXG4gICAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIG1vZGlmaWVkUG9zaXRpb25cbiAgICAgICAgICApO1xuICAgICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgIGdyb3VwTWF0ZXJpYWwsXG4gICAgICAgICAgICBub3JtYWxBdHRyaWJ1dGUsXG4gICAgICAgICAgICBtb3JwaE5vcm1hbCxcbiAgICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgbW9kaWZpZWROb3JtYWxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgZHJhd1JhbmdlLnN0YXJ0KTtcbiAgICAgIGVuZCA9IE1hdGgubWluKHBvc2l0aW9uQXR0cmlidXRlLmNvdW50LCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQpO1xuICAgICAgZm9yIChpID0gc3RhcnQsIGlsID0gZW5kOyBpIDwgaWw7IGkgKz0gMykge1xuICAgICAgICBhID0gaTtcbiAgICAgICAgYiA9IGkgKyAxO1xuICAgICAgICBjID0gaSArIDI7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgcG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgICAgICAgbW9ycGhQb3NpdGlvbixcbiAgICAgICAgICBtb3JwaFRhcmdldHNSZWxhdGl2ZSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBtb2RpZmllZFBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIF9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YShcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgbWF0ZXJpYWwsXG4gICAgICAgICAgbm9ybWFsQXR0cmlidXRlLFxuICAgICAgICAgIG1vcnBoTm9ybWFsLFxuICAgICAgICAgIG1vcnBoVGFyZ2V0c1JlbGF0aXZlLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgYixcbiAgICAgICAgICBjLFxuICAgICAgICAgIG1vZGlmaWVkTm9ybWFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG1vcnBoZWRQb3NpdGlvbkF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKG1vZGlmaWVkUG9zaXRpb24sIDMpO1xuICBjb25zdCBtb3JwaGVkTm9ybWFsQXR0cmlidXRlID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUobW9kaWZpZWROb3JtYWwsIDMpO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uQXR0cmlidXRlLFxuICAgIG5vcm1hbEF0dHJpYnV0ZSxcbiAgICBtb3JwaGVkUG9zaXRpb25BdHRyaWJ1dGUsXG4gICAgbW9ycGhlZE5vcm1hbEF0dHJpYnV0ZVxuICB9O1xufVxuZnVuY3Rpb24gdG9DcmVhc2VkTm9ybWFscyhnZW9tZXRyeSwgY3JlYXNlQW5nbGUgPSBNYXRoLlBJIC8gMykge1xuICBjb25zdCBjcmVhc2VEb3QgPSBNYXRoLmNvcyhjcmVhc2VBbmdsZSk7XG4gIGNvbnN0IGhhc2hNdWx0aXBsaWVyID0gKDEgKyAxZS0xMCkgKiAxMDA7XG4gIGNvbnN0IHZlcnRzID0gW25ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCksIG5ldyBWZWN0b3IzKCldO1xuICBjb25zdCB0ZW1wVmVjMSA9IG5ldyBWZWN0b3IzKCk7XG4gIGNvbnN0IHRlbXBWZWMyID0gbmV3IFZlY3RvcjMoKTtcbiAgY29uc3QgdGVtcE5vcm0gPSBuZXcgVmVjdG9yMygpO1xuICBjb25zdCB0ZW1wTm9ybTIgPSBuZXcgVmVjdG9yMygpO1xuICBmdW5jdGlvbiBoYXNoVmVydGV4KHYpIHtcbiAgICBjb25zdCB4ID0gfn4odi54ICogaGFzaE11bHRpcGxpZXIpO1xuICAgIGNvbnN0IHkgPSB+fih2LnkgKiBoYXNoTXVsdGlwbGllcik7XG4gICAgY29uc3QgeiA9IH5+KHYueiAqIGhhc2hNdWx0aXBsaWVyKTtcbiAgICByZXR1cm4gYCR7eH0sJHt5fSwke3p9YDtcbiAgfVxuICBjb25zdCByZXN1bHRHZW9tZXRyeSA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkudG9Ob25JbmRleGVkKCkgOiBnZW9tZXRyeTtcbiAgY29uc3QgcG9zQXR0ciA9IHJlc3VsdEdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gIGNvbnN0IHZlcnRleE1hcCA9IHt9O1xuICBmb3IgKGxldCBpID0gMCwgbCA9IHBvc0F0dHIuY291bnQgLyAzOyBpIDwgbDsgaSsrKSB7XG4gICAgY29uc3QgaTMgPSAzICogaTtcbiAgICBjb25zdCBhID0gdmVydHNbMF0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDApO1xuICAgIGNvbnN0IGIgPSB2ZXJ0c1sxXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMSk7XG4gICAgY29uc3QgYyA9IHZlcnRzWzJdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAyKTtcbiAgICB0ZW1wVmVjMS5zdWJWZWN0b3JzKGMsIGIpO1xuICAgIHRlbXBWZWMyLnN1YlZlY3RvcnMoYSwgYik7XG4gICAgY29uc3Qgbm9ybWFsID0gbmV3IFZlY3RvcjMoKS5jcm9zc1ZlY3RvcnModGVtcFZlYzEsIHRlbXBWZWMyKS5ub3JtYWxpemUoKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDM7IG4rKykge1xuICAgICAgY29uc3QgdmVydCA9IHZlcnRzW25dO1xuICAgICAgY29uc3QgaGFzaCA9IGhhc2hWZXJ0ZXgodmVydCk7XG4gICAgICBpZiAoIShoYXNoIGluIHZlcnRleE1hcCkpIHtcbiAgICAgICAgdmVydGV4TWFwW2hhc2hdID0gW107XG4gICAgICB9XG4gICAgICB2ZXJ0ZXhNYXBbaGFzaF0ucHVzaChub3JtYWwpO1xuICAgIH1cbiAgfVxuICBjb25zdCBub3JtYWxBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocG9zQXR0ci5jb3VudCAqIDMpO1xuICBjb25zdCBub3JtQXR0ciA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUobm9ybWFsQXJyYXksIDMsIGZhbHNlKTtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBwb3NBdHRyLmNvdW50IC8gMzsgaSA8IGw7IGkrKykge1xuICAgIGNvbnN0IGkzID0gMyAqIGk7XG4gICAgY29uc3QgYSA9IHZlcnRzWzBdLmZyb21CdWZmZXJBdHRyaWJ1dGUocG9zQXR0ciwgaTMgKyAwKTtcbiAgICBjb25zdCBiID0gdmVydHNbMV0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShwb3NBdHRyLCBpMyArIDEpO1xuICAgIGNvbnN0IGMgPSB2ZXJ0c1syXS5mcm9tQnVmZmVyQXR0cmlidXRlKHBvc0F0dHIsIGkzICsgMik7XG4gICAgdGVtcFZlYzEuc3ViVmVjdG9ycyhjLCBiKTtcbiAgICB0ZW1wVmVjMi5zdWJWZWN0b3JzKGEsIGIpO1xuICAgIHRlbXBOb3JtLmNyb3NzVmVjdG9ycyh0ZW1wVmVjMSwgdGVtcFZlYzIpLm5vcm1hbGl6ZSgpO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgMzsgbisrKSB7XG4gICAgICBjb25zdCB2ZXJ0ID0gdmVydHNbbl07XG4gICAgICBjb25zdCBoYXNoID0gaGFzaFZlcnRleCh2ZXJ0KTtcbiAgICAgIGNvbnN0IG90aGVyTm9ybWFscyA9IHZlcnRleE1hcFtoYXNoXTtcbiAgICAgIHRlbXBOb3JtMi5zZXQoMCwgMCwgMCk7XG4gICAgICBmb3IgKGxldCBrID0gMCwgbGsgPSBvdGhlck5vcm1hbHMubGVuZ3RoOyBrIDwgbGs7IGsrKykge1xuICAgICAgICBjb25zdCBvdGhlck5vcm0gPSBvdGhlck5vcm1hbHNba107XG4gICAgICAgIGlmICh0ZW1wTm9ybS5kb3Qob3RoZXJOb3JtKSA+IGNyZWFzZURvdCkge1xuICAgICAgICAgIHRlbXBOb3JtMi5hZGQob3RoZXJOb3JtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGVtcE5vcm0yLm5vcm1hbGl6ZSgpO1xuICAgICAgbm9ybUF0dHIuc2V0WFlaKGkzICsgbiwgdGVtcE5vcm0yLngsIHRlbXBOb3JtMi55LCB0ZW1wTm9ybTIueik7XG4gICAgfVxuICB9XG4gIHJlc3VsdEdlb21ldHJ5LnNldEF0dHJpYnV0ZShcIm5vcm1hbFwiLCBub3JtQXR0cik7XG4gIHJldHVybiByZXN1bHRHZW9tZXRyeTtcbn1cbmV4cG9ydCB7XG4gIGNvbXB1dGVNb3JwaGVkQXR0cmlidXRlcyxcbiAgZXN0aW1hdGVCeXRlc1VzZWQsXG4gIGludGVybGVhdmVBdHRyaWJ1dGVzLFxuICBtZXJnZUJ1ZmZlckF0dHJpYnV0ZXMsXG4gIG1lcmdlQnVmZmVyR2VvbWV0cmllcyxcbiAgbWVyZ2VWZXJ0aWNlcyxcbiAgdG9DcmVhc2VkTm9ybWFscyxcbiAgdG9UcmlhbmdsZXNEcmF3TW9kZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1ZmZlckdlb21ldHJ5VXRpbHMuanMubWFwXG4iXSwibmFtZXMiOlsiQnVmZmVyR2VvbWV0cnkiLCJCdWZmZXJBdHRyaWJ1dGUiLCJJbnRlcmxlYXZlZEJ1ZmZlciIsIkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlIiwiVHJpYW5nbGVzRHJhd01vZGUiLCJUcmlhbmdsZUZhbkRyYXdNb2RlIiwiVHJpYW5nbGVTdHJpcERyYXdNb2RlIiwiVmVjdG9yMyIsIkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUiLCJnZXRXaXRoS2V5IiwibWVyZ2VCdWZmZXJHZW9tZXRyaWVzIiwiZ2VvbWV0cmllcyIsInVzZUdyb3VwcyIsImlzSW5kZXhlZCIsImluZGV4IiwiYXR0cmlidXRlc1VzZWQiLCJTZXQiLCJPYmplY3QiLCJrZXlzIiwiYXR0cmlidXRlcyIsIm1vcnBoQXR0cmlidXRlc1VzZWQiLCJtb3JwaEF0dHJpYnV0ZXMiLCJtb3JwaFRhcmdldHNSZWxhdGl2ZSIsIm1lcmdlZEdlb21ldHJ5Iiwib2Zmc2V0IiwiZm9yRWFjaCIsImdlb20iLCJpIiwiYXR0cmlidXRlc0NvdW50IiwiY29uc29sZSIsImVycm9yIiwibmFtZSIsImhhcyIsInB1c2giLCJzaXplIiwidXNlckRhdGEiLCJtZXJnZWRVc2VyRGF0YSIsImNvdW50IiwicG9zaXRpb24iLCJhZGRHcm91cCIsImluZGV4T2Zmc2V0IiwibWVyZ2VkSW5kZXgiLCJqIiwiZ2V0WCIsInNldEluZGV4IiwibWVyZ2VkQXR0cmlidXRlIiwibWVyZ2VCdWZmZXJBdHRyaWJ1dGVzIiwic2V0QXR0cmlidXRlIiwibnVtTW9ycGhUYXJnZXRzIiwibGVuZ3RoIiwibW9ycGhBdHRyaWJ1dGVzVG9NZXJnZSIsIm1lcmdlZE1vcnBoQXR0cmlidXRlIiwiVHlwZWRBcnJheSIsIml0ZW1TaXplIiwibm9ybWFsaXplZCIsImFycmF5TGVuZ3RoIiwiYXR0ciIsImFycmF5IiwiY29uc3RydWN0b3IiLCJzZXQiLCJpbnRlcmxlYXZlQXR0cmlidXRlcyIsInN0cmlkZSIsImwiLCJhdHRyaWJ1dGUiLCJpbnRlcmxlYXZlZEJ1ZmZlciIsInJlcyIsImdldHRlcnMiLCJzZXR0ZXJzIiwiaWJhIiwiYyIsImsiLCJnZXQiLCJlc3RpbWF0ZUJ5dGVzVXNlZCIsImdlb21ldHJ5IiwibWVtIiwiZ2V0QXR0cmlidXRlIiwiQllURVNfUEVSX0VMRU1FTlQiLCJpbmRpY2VzIiwiZ2V0SW5kZXgiLCJtZXJnZVZlcnRpY2VzIiwidG9sZXJhbmNlIiwiTWF0aCIsIm1heCIsIk51bWJlciIsIkVQU0lMT04iLCJoYXNoVG9JbmRleCIsInBvc2l0aW9ucyIsInZlcnRleENvdW50IiwibmV4dEluZGV4IiwiYXR0cmlidXRlTmFtZXMiLCJhdHRyQXJyYXlzIiwibW9ycGhBdHRyc0FycmF5cyIsIm5ld0luZGljZXMiLCJtb3JwaEF0dHIiLCJBcnJheSIsImZpbGwiLCJtYXAiLCJkZWNpbWFsU2hpZnQiLCJsb2cxMCIsInNoaWZ0TXVsdGlwbGllciIsInBvdyIsImhhc2giLCJuZXdhcnJheSIsIm5ld01vcnBoQXJyYXlzIiwiZ2V0dGVyRnVuYyIsIm0iLCJtbCIsInJlc3VsdCIsImNsb25lIiwib2xkQXR0cmlidXRlIiwiYnVmZmVyIiwib2xkTW9ycGhBdHRyaWJ1dGUiLCJidWZmZXIyIiwibW9ycGhBdHRyaWJ1dGUiLCJ0b1RyaWFuZ2xlc0RyYXdNb2RlIiwiZHJhd01vZGUiLCJ3YXJuIiwibnVtYmVyT2ZUcmlhbmdsZXMiLCJuZXdHZW9tZXRyeSIsImNsZWFyR3JvdXBzIiwiY29tcHV0ZU1vcnBoZWRBdHRyaWJ1dGVzIiwib2JqZWN0IiwiaXNCdWZmZXJHZW9tZXRyeSIsIl92QSIsIl92QiIsIl92QyIsIl90ZW1wQSIsIl90ZW1wQiIsIl90ZW1wQyIsIl9tb3JwaEEiLCJfbW9ycGhCIiwiX21vcnBoQyIsIl9jYWxjdWxhdGVNb3JwaGVkQXR0cmlidXRlRGF0YSIsIm9iamVjdDIiLCJtYXRlcmlhbDIiLCJtb3JwaFRhcmdldHNSZWxhdGl2ZTIiLCJhMiIsImIyIiwiYzIiLCJtb2RpZmllZEF0dHJpYnV0ZUFycmF5IiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIm1vcnBoSW5mbHVlbmNlcyIsIm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyIsIm1vcnBoVGFyZ2V0cyIsImkyIiwiaWwyIiwiaW5mbHVlbmNlIiwibW9ycGgiLCJhZGRTY2FsZWRWZWN0b3IiLCJzdWIiLCJhZGQiLCJpc1NraW5uZWRNZXNoIiwiYm9uZVRyYW5zZm9ybSIsIngiLCJ5IiwieiIsIm1hdGVyaWFsIiwiYSIsImIiLCJwb3NpdGlvbkF0dHJpYnV0ZSIsIm1vcnBoUG9zaXRpb24iLCJub3JtYWxBdHRyaWJ1dGUiLCJub3JtYWwiLCJtb3JwaE5vcm1hbCIsImdyb3VwcyIsImRyYXdSYW5nZSIsImlsIiwiamwiLCJncm91cCIsImdyb3VwTWF0ZXJpYWwiLCJzdGFydCIsImVuZCIsIm1vZGlmaWVkUG9zaXRpb24iLCJGbG9hdDMyQXJyYXkiLCJtb2RpZmllZE5vcm1hbCIsImlzQXJyYXkiLCJtYXRlcmlhbEluZGV4IiwibWluIiwibW9ycGhlZFBvc2l0aW9uQXR0cmlidXRlIiwibW9ycGhlZE5vcm1hbEF0dHJpYnV0ZSIsInRvQ3JlYXNlZE5vcm1hbHMiLCJjcmVhc2VBbmdsZSIsIlBJIiwiY3JlYXNlRG90IiwiY29zIiwiaGFzaE11bHRpcGxpZXIiLCJ2ZXJ0cyIsInRlbXBWZWMxIiwidGVtcFZlYzIiLCJ0ZW1wTm9ybSIsInRlbXBOb3JtMiIsImhhc2hWZXJ0ZXgiLCJ2IiwicmVzdWx0R2VvbWV0cnkiLCJ0b05vbkluZGV4ZWQiLCJwb3NBdHRyIiwidmVydGV4TWFwIiwiaTMiLCJzdWJWZWN0b3JzIiwiY3Jvc3NWZWN0b3JzIiwibm9ybWFsaXplIiwibiIsInZlcnQiLCJub3JtYWxBcnJheSIsIm5vcm1BdHRyIiwib3RoZXJOb3JtYWxzIiwibGsiLCJvdGhlck5vcm0iLCJkb3QiLCJzZXRYWVoiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/utils/BufferGeometryUtils.js\n");

/***/ })

};
;