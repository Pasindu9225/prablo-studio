"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/AccumulativeShadows.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/AccumulativeShadows.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccumulativeShadows: () => (/* binding */ AccumulativeShadows),\n/* harmony export */   RandomizedLight: () => (/* binding */ RandomizedLight),\n/* harmony export */   accumulativeContext: () => (/* binding */ accumulativeContext)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var _shaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaderMaterial.js */ \"(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n/* harmony import */ var _materials_DiscardMaterial_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../materials/DiscardMaterial.js */ \"(ssr)/./node_modules/@react-three/drei/materials/DiscardMaterial.js\");\n/* harmony import */ var _helpers_constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/constants.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/constants.js\");\n\n\n\n\n\n\n\nfunction isLight(object) {\n    return object.isLight;\n}\nfunction isGeometry(object) {\n    return !!object.geometry;\n}\nconst accumulativeContext = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nconst SoftShadowMaterial = /* @__PURE__ */ (0,_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_2__.shaderMaterial)({\n    color: /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Color(),\n    blend: 2.0,\n    alphaTest: 0.75,\n    opacity: 0,\n    map: null\n}, `varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }`, `varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <${_helpers_constants_js__WEBPACK_IMPORTED_MODULE_4__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n   }`);\nconst AccumulativeShadows = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, temporal, frames = 40, limit = Infinity, blend = 20, scale = 10, opacity = 1, alphaTest = 0.75, color = \"black\", colorBlend = 2, resolution = 1024, toneMapped = true, ...props }, forwardRef)=>{\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.e)({\n        SoftShadowMaterial\n    });\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.D)((state)=>state.gl);\n    const scene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.D)((state)=>state.scene);\n    const camera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.D)((state)=>state.camera);\n    const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.D)((state)=>state.invalidate);\n    const gPlane = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const gLights = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [plm] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new ProgressiveLightMap(gl, scene, resolution));\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        plm.configure(gPlane.current);\n    }, []);\n    const api = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            lights: new Map(),\n            temporal: !!temporal,\n            frames: Math.max(2, frames),\n            blend: Math.max(2, frames === Infinity ? blend : frames),\n            count: 0,\n            getMesh: ()=>gPlane.current,\n            reset: ()=>{\n                // Clear buffers, reset opacities, set frame count to 0\n                plm.clear();\n                const material = gPlane.current.material;\n                material.opacity = 0;\n                material.alphaTest = 0;\n                api.count = 0;\n            },\n            update: (frames = 1)=>{\n                // Adapt the opacity-blend ratio to the number of frames\n                const material = gPlane.current.material;\n                if (!api.temporal) {\n                    material.opacity = opacity;\n                    material.alphaTest = alphaTest;\n                } else {\n                    material.opacity = Math.min(opacity, material.opacity + opacity / api.blend);\n                    material.alphaTest = Math.min(alphaTest, material.alphaTest + alphaTest / api.blend);\n                }\n                // Switch accumulative lights on\n                gLights.current.visible = true;\n                // Collect scene lights and meshes\n                plm.prepare();\n                // Update the lightmap and the accumulative lights\n                for(let i = 0; i < frames; i++){\n                    api.lights.forEach((light)=>light.update());\n                    plm.update(camera, api.blend);\n                }\n                // Switch lights off\n                gLights.current.visible = false;\n                // Restore lights and meshes\n                plm.finish();\n            }\n        }), [\n        plm,\n        camera,\n        scene,\n        temporal,\n        frames,\n        blend,\n        opacity,\n        alphaTest\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        // Reset internals, buffers, ...\n        api.reset();\n        // Update lightmap\n        if (!api.temporal && api.frames !== Infinity) api.update(api.blend);\n    });\n    // Expose api, allow children to set itself as the main light source\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardRef, ()=>api, [\n        api\n    ]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.F)(()=>{\n        if ((api.temporal || api.frames === Infinity) && api.count < api.frames && api.count < limit) {\n            invalidate();\n            api.update();\n            api.count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", props, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        traverse: ()=>null,\n        ref: gLights\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(accumulativeContext.Provider, {\n        value: api\n    }, children)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", {\n        receiveShadow: true,\n        ref: gPlane,\n        scale: scale,\n        rotation: [\n            -Math.PI / 2,\n            0,\n            0\n        ]\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"planeGeometry\", null), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"softShadowMaterial\", {\n        transparent: true,\n        depthWrite: false,\n        toneMapped: toneMapped,\n        color: color,\n        blend: colorBlend,\n        map: plm.progressiveLightMap2.texture\n    })));\n});\nconst RandomizedLight = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ castShadow = true, bias = 0.001, mapSize = 512, size = 5, near = 0.5, far = 500, frames = 1, position = [\n    0,\n    0,\n    0\n], radius = 1, amount = 8, intensity = _helpers_constants_js__WEBPACK_IMPORTED_MODULE_4__.version >= 155 ? Math.PI : 1, ambient = 0.5, ...props }, forwardRef)=>{\n    const gLights = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const length = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(...position).length();\n    const parent = react__WEBPACK_IMPORTED_MODULE_1__.useContext(accumulativeContext);\n    const update = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(()=>{\n        let light;\n        if (gLights.current) {\n            for(let l = 0; l < gLights.current.children.length; l++){\n                light = gLights.current.children[l];\n                if (Math.random() > ambient) {\n                    light.position.set(position[0] + three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.randFloatSpread(radius), position[1] + three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.randFloatSpread(radius), position[2] + three__WEBPACK_IMPORTED_MODULE_3__.MathUtils.randFloatSpread(radius));\n                } else {\n                    let lambda = Math.acos(2 * Math.random() - 1) - Math.PI / 2.0;\n                    let phi = 2 * Math.PI * Math.random();\n                    light.position.set(Math.cos(lambda) * Math.cos(phi) * length, Math.abs(Math.cos(lambda) * Math.sin(phi) * length), Math.sin(lambda) * length);\n                }\n            }\n        }\n    }, [\n        radius,\n        ambient,\n        length,\n        ...position\n    ]);\n    const api = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            update\n        }), [\n        update\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardRef, ()=>api, [\n        api\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        var _parent$lights;\n        const group = gLights.current;\n        if (parent) (_parent$lights = parent.lights) == null || _parent$lights.set(group.uuid, api);\n        return ()=>{\n            var _parent$lights2;\n            return void (parent == null || (_parent$lights2 = parent.lights) == null ? void 0 : _parent$lights2.delete(group.uuid));\n        };\n    }, [\n        parent,\n        api\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: gLights\n    }, props), Array.from({\n        length: amount\n    }, (_, index)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"directionalLight\", {\n            key: index,\n            castShadow: castShadow,\n            \"shadow-bias\": bias,\n            \"shadow-mapSize\": [\n                mapSize,\n                mapSize\n            ],\n            intensity: intensity / amount\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"orthographicCamera\", {\n            attach: \"shadow-camera\",\n            args: [\n                -size,\n                size,\n                size,\n                -size,\n                near,\n                far\n            ]\n        }))));\n});\n// Based on \"Progressive Light Map Accumulator\", by [zalo](https://github.com/zalo/)\nclass ProgressiveLightMap {\n    constructor(renderer, scene, res = 1024){\n        this.renderer = renderer;\n        this.res = res;\n        this.scene = scene;\n        this.buffer1Active = false;\n        this.lights = [];\n        this.meshes = [];\n        this.object = null;\n        this.clearColor = new three__WEBPACK_IMPORTED_MODULE_3__.Color();\n        this.clearAlpha = 0;\n        // Create the Progressive LightMap Texture\n        const textureParams = {\n            type: three__WEBPACK_IMPORTED_MODULE_3__.HalfFloatType,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_3__.NearestFilter,\n            minFilter: three__WEBPACK_IMPORTED_MODULE_3__.NearestFilter\n        };\n        this.progressiveLightMap1 = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(this.res, this.res, textureParams);\n        this.progressiveLightMap2 = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(this.res, this.res, textureParams);\n        // Inject some spicy new logic into a standard phong material\n        this.discardMat = new _materials_DiscardMaterial_js__WEBPACK_IMPORTED_MODULE_6__.DiscardMaterial();\n        this.targetMat = new three__WEBPACK_IMPORTED_MODULE_3__.MeshLambertMaterial({\n            fog: false\n        });\n        this.previousShadowMap = {\n            value: this.progressiveLightMap1.texture\n        };\n        this.averagingWindow = {\n            value: 100\n        };\n        this.targetMat.onBeforeCompile = (shader)=>{\n            // Vertex Shader: Set Vertex Positions to the Unwrapped UV Positions\n            shader.vertexShader = \"varying vec2 vUv;\\n\" + shader.vertexShader.slice(0, -1) + \"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }\";\n            // Fragment Shader: Set Pixels to average in the Previous frame's Shadows\n            const bodyStart = shader.fragmentShader.indexOf(\"void main() {\");\n            shader.fragmentShader = \"varying vec2 vUv;\\n\" + shader.fragmentShader.slice(0, bodyStart) + \"uniform sampler2D previousShadowMap;\\n\tuniform float averagingWindow;\\n\" + shader.fragmentShader.slice(bodyStart - 1, -1) + `\\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }`;\n            // Set the Previous Frame's Texture Buffer and Averaging Window\n            shader.uniforms.previousShadowMap = this.previousShadowMap;\n            shader.uniforms.averagingWindow = this.averagingWindow;\n        };\n    }\n    clear() {\n        this.renderer.getClearColor(this.clearColor);\n        this.clearAlpha = this.renderer.getClearAlpha();\n        this.renderer.setClearColor(\"black\", 1);\n        this.renderer.setRenderTarget(this.progressiveLightMap1);\n        this.renderer.clear();\n        this.renderer.setRenderTarget(this.progressiveLightMap2);\n        this.renderer.clear();\n        this.renderer.setRenderTarget(null);\n        this.renderer.setClearColor(this.clearColor, this.clearAlpha);\n        this.lights = [];\n        this.meshes = [];\n        this.scene.traverse((object)=>{\n            if (isGeometry(object)) {\n                this.meshes.push({\n                    object,\n                    material: object.material\n                });\n            } else if (isLight(object)) {\n                this.lights.push({\n                    object,\n                    intensity: object.intensity\n                });\n            }\n        });\n    }\n    prepare() {\n        this.lights.forEach((light)=>light.object.intensity = 0);\n        this.meshes.forEach((mesh)=>mesh.object.material = this.discardMat);\n    }\n    finish() {\n        this.lights.forEach((light)=>light.object.intensity = light.intensity);\n        this.meshes.forEach((mesh)=>mesh.object.material = mesh.material);\n    }\n    configure(object) {\n        this.object = object;\n    }\n    update(camera, blendWindow = 100) {\n        if (!this.object) return;\n        // Set each object's material to the UV Unwrapped Surface Mapping Version\n        this.averagingWindow.value = blendWindow;\n        this.object.material = this.targetMat;\n        // Ping-pong two surface buffers for reading/writing\n        const activeMap = this.buffer1Active ? this.progressiveLightMap1 : this.progressiveLightMap2;\n        const inactiveMap = this.buffer1Active ? this.progressiveLightMap2 : this.progressiveLightMap1;\n        // Render the object's surface maps\n        const oldBg = this.scene.background;\n        this.scene.background = null;\n        this.renderer.setRenderTarget(activeMap);\n        this.previousShadowMap.value = inactiveMap.texture;\n        this.buffer1Active = !this.buffer1Active;\n        this.renderer.render(this.scene, camera);\n        this.renderer.setRenderTarget(null);\n        this.scene.background = oldBg;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9BY2N1bXVsYXRpdmVTaGFkb3dzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ0E7QUFDaUM7QUFDWDtBQUNhO0FBQ2hCO0FBRWxELFNBQVNTLFFBQVFDLE1BQU07SUFDckIsT0FBT0EsT0FBT0QsT0FBTztBQUN2QjtBQUNBLFNBQVNFLFdBQVdELE1BQU07SUFDeEIsT0FBTyxDQUFDLENBQUNBLE9BQU9FLFFBQVE7QUFDMUI7QUFDQSxNQUFNQyxzQkFBc0IsYUFBYSxpQkFBRVgsZ0RBQW1CLENBQUM7QUFDL0QsTUFBTWEscUJBQXFCLGFBQWEsR0FBRVQsa0VBQWNBLENBQUM7SUFDdkRVLE9BQU8sYUFBYSxHQUFFLElBQUlmLHdDQUFXO0lBQ3JDaUIsT0FBTztJQUNQQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsS0FBSztBQUNQLEdBQUcsQ0FBQzs7OztJQUlBLENBQUMsRUFBRSxDQUFDOzs7Ozs7Ozs7O2VBVU8sRUFBRWIsMERBQU9BLElBQUksTUFBTSx3QkFBd0IscUJBQXFCO0lBQzNFLENBQUM7QUFDTCxNQUFNYyxzQkFBc0IsYUFBYSxpQkFBRXBCLDZDQUFnQixDQUFDLENBQUMsRUFDM0RzQixRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsU0FBUyxFQUFFLEVBQ1hDLFFBQVFDLFFBQVEsRUFDaEJWLFFBQVEsRUFBRSxFQUNWVyxRQUFRLEVBQUUsRUFDVlQsVUFBVSxDQUFDLEVBQ1hELFlBQVksSUFBSSxFQUNoQkgsUUFBUSxPQUFPLEVBQ2ZjLGFBQWEsQ0FBQyxFQUNkQyxhQUFhLElBQUksRUFDakJDLGFBQWEsSUFBSSxFQUNqQixHQUFHQyxPQUNKLEVBQUVWO0lBQ0RwQixxREFBTUEsQ0FBQztRQUNMWTtJQUNGO0lBQ0EsTUFBTW1CLEtBQUs5QixxREFBUUEsQ0FBQytCLENBQUFBLFFBQVNBLE1BQU1ELEVBQUU7SUFDckMsTUFBTUUsUUFBUWhDLHFEQUFR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SUFBSSxDQUFDLElBQUksQ0FBQ2pKLE1BQU0sRUFBRTtRQUNsQix5RUFBeUU7UUFDekUsSUFBSSxDQUFDa0ksZUFBZSxDQUFDcEUsS0FBSyxHQUFHbUY7UUFDN0IsSUFBSSxDQUFDakosTUFBTSxDQUFDZ0QsUUFBUSxHQUFHLElBQUksQ0FBQzhFLFNBQVM7UUFDckMsb0RBQW9EO1FBQ3BELE1BQU1vQixZQUFZLElBQUksQ0FBQ2pDLGFBQWEsR0FBRyxJQUFJLENBQUNVLG9CQUFvQixHQUFHLElBQUksQ0FBQ3ZELG9CQUFvQjtRQUM1RixNQUFNK0UsY0FBYyxJQUFJLENBQUNsQyxhQUFhLEdBQUcsSUFBSSxDQUFDN0Msb0JBQW9CLEdBQUcsSUFBSSxDQUFDdUQsb0JBQW9CO1FBQzlGLG1DQUFtQztRQUNuQyxNQUFNeUIsUUFBUSxJQUFJLENBQUMxSCxLQUFLLENBQUMySCxVQUFVO1FBQ25DLElBQUksQ0FBQzNILEtBQUssQ0FBQzJILFVBQVUsR0FBRztRQUN4QixJQUFJLENBQUN0QyxRQUFRLENBQUMrQixlQUFlLENBQUNJO1FBQzlCLElBQUksQ0FBQ2pCLGlCQUFpQixDQUFDbkUsS0FBSyxHQUFHcUYsWUFBWTlFLE9BQU87UUFDbEQsSUFBSSxDQUFDNEMsYUFBYSxHQUFHLENBQUMsSUFBSSxDQUFDQSxhQUFhO1FBQ3hDLElBQUksQ0FBQ0YsUUFBUSxDQUFDdUMsTUFBTSxDQUFDLElBQUksQ0FBQzVILEtBQUssRUFBRUM7UUFDakMsSUFBSSxDQUFDb0YsUUFBUSxDQUFDK0IsZUFBZSxDQUFDO1FBQzlCLElBQUksQ0FBQ3BILEtBQUssQ0FBQzJILFVBQVUsR0FBR0Q7SUFDMUI7QUFDRjtBQUVxRSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9BY2N1bXVsYXRpdmVTaGFkb3dzLmpzPzQwMjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZXh0ZW5kLCB1c2VUaHJlZSwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICcuL3NoYWRlck1hdGVyaWFsLmpzJztcbmltcG9ydCB7IERpc2NhcmRNYXRlcmlhbCB9IGZyb20gJy4uL21hdGVyaWFscy9EaXNjYXJkTWF0ZXJpYWwuanMnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL2hlbHBlcnMvY29uc3RhbnRzLmpzJztcblxuZnVuY3Rpb24gaXNMaWdodChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdC5pc0xpZ2h0O1xufVxuZnVuY3Rpb24gaXNHZW9tZXRyeShvYmplY3QpIHtcbiAgcmV0dXJuICEhb2JqZWN0Lmdlb21ldHJ5O1xufVxuY29uc3QgYWNjdW11bGF0aXZlQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBTb2Z0U2hhZG93TWF0ZXJpYWwgPSAvKiBAX19QVVJFX18gKi9zaGFkZXJNYXRlcmlhbCh7XG4gIGNvbG9yOiAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuQ29sb3IoKSxcbiAgYmxlbmQ6IDIuMCxcbiAgYWxwaGFUZXN0OiAwLjc1LFxuICBvcGFjaXR5OiAwLFxuICBtYXA6IG51bGxcbn0sIGB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgdm9pZCBtYWluKCkge1xuICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLik7XG4gICAgIHZVdiA9IHV2O1xuICAgfWAsIGB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgdW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xuICAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xuICAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xuICAgdW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7XG4gICB1bmlmb3JtIGZsb2F0IGJsZW5kO1xuICAgdm9pZCBtYWluKCkge1xuICAgICB2ZWM0IHNhbXBsZWREaWZmdXNlQ29sb3IgPSB0ZXh0dXJlMkQobWFwLCB2VXYpO1xuICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yICogc2FtcGxlZERpZmZ1c2VDb2xvci5yICogYmxlbmQsIG1heCgwLjAsICgxLjAgLSAoc2FtcGxlZERpZmZ1c2VDb2xvci5yICsgc2FtcGxlZERpZmZ1c2VDb2xvci5nICsgc2FtcGxlZERpZmZ1c2VDb2xvci5iKSAvIGFscGhhVGVzdCkpICogb3BhY2l0eSk7XG4gICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgI2luY2x1ZGUgPCR7dmVyc2lvbiA+PSAxNTQgPyAnY29sb3JzcGFjZV9mcmFnbWVudCcgOiAnZW5jb2RpbmdzX2ZyYWdtZW50J30+XG4gICB9YCk7XG5jb25zdCBBY2N1bXVsYXRpdmVTaGFkb3dzID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgdGVtcG9yYWwsXG4gIGZyYW1lcyA9IDQwLFxuICBsaW1pdCA9IEluZmluaXR5LFxuICBibGVuZCA9IDIwLFxuICBzY2FsZSA9IDEwLFxuICBvcGFjaXR5ID0gMSxcbiAgYWxwaGFUZXN0ID0gMC43NSxcbiAgY29sb3IgPSAnYmxhY2snLFxuICBjb2xvckJsZW5kID0gMixcbiAgcmVzb2x1dGlvbiA9IDEwMjQsXG4gIHRvbmVNYXBwZWQgPSB0cnVlLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZFJlZikgPT4ge1xuICBleHRlbmQoe1xuICAgIFNvZnRTaGFkb3dNYXRlcmlhbFxuICB9KTtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IHNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBjb25zdCBjYW1lcmEgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5jYW1lcmEpO1xuICBjb25zdCBpbnZhbGlkYXRlID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuaW52YWxpZGF0ZSk7XG4gIGNvbnN0IGdQbGFuZSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZ0xpZ2h0cyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW3BsbV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgUHJvZ3Jlc3NpdmVMaWdodE1hcChnbCwgc2NlbmUsIHJlc29sdXRpb24pKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBwbG0uY29uZmlndXJlKGdQbGFuZS5jdXJyZW50KTtcbiAgfSwgW10pO1xuICBjb25zdCBhcGkgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgbGlnaHRzOiBuZXcgTWFwKCksXG4gICAgdGVtcG9yYWw6ICEhdGVtcG9yYWwsXG4gICAgZnJhbWVzOiBNYXRoLm1heCgyLCBmcmFtZXMpLFxuICAgIGJsZW5kOiBNYXRoLm1heCgyLCBmcmFtZXMgPT09IEluZmluaXR5ID8gYmxlbmQgOiBmcmFtZXMpLFxuICAgIGNvdW50OiAwLFxuICAgIGdldE1lc2g6ICgpID0+IGdQbGFuZS5jdXJyZW50LFxuICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAvLyBDbGVhciBidWZmZXJzLCByZXNldCBvcGFjaXRpZXMsIHNldCBmcmFtZSBjb3VudCB0byAwXG4gICAgICBwbG0uY2xlYXIoKTtcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gZ1BsYW5lLmN1cnJlbnQubWF0ZXJpYWw7XG4gICAgICBtYXRlcmlhbC5vcGFjaXR5ID0gMDtcbiAgICAgIG1hdGVyaWFsLmFscGhhVGVzdCA9IDA7XG4gICAgICBhcGkuY291bnQgPSAwO1xuICAgIH0sXG4gICAgdXBkYXRlOiAoZnJhbWVzID0gMSkgPT4ge1xuICAgICAgLy8gQWRhcHQgdGhlIG9wYWNpdHktYmxlbmQgcmF0aW8gdG8gdGhlIG51bWJlciBvZiBmcmFtZXNcbiAgICAgIGNvbnN0IG1hdGVyaWFsID0gZ1BsYW5lLmN1cnJlbnQubWF0ZXJpYWw7XG4gICAgICBpZiAoIWFwaS50ZW1wb3JhbCkge1xuICAgICAgICBtYXRlcmlhbC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgbWF0ZXJpYWwuYWxwaGFUZXN0ID0gYWxwaGFUZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0ZXJpYWwub3BhY2l0eSA9IE1hdGgubWluKG9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKyBvcGFjaXR5IC8gYXBpLmJsZW5kKTtcbiAgICAgICAgbWF0ZXJpYWwuYWxwaGFUZXN0ID0gTWF0aC5taW4oYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKyBhbHBoYVRlc3QgLyBhcGkuYmxlbmQpO1xuICAgICAgfVxuXG4gICAgICAvLyBTd2l0Y2ggYWNjdW11bGF0aXZlIGxpZ2h0cyBvblxuICAgICAgZ0xpZ2h0cy5jdXJyZW50LnZpc2libGUgPSB0cnVlO1xuICAgICAgLy8gQ29sbGVjdCBzY2VuZSBsaWdodHMgYW5kIG1lc2hlc1xuICAgICAgcGxtLnByZXBhcmUoKTtcblxuICAgICAgLy8gVXBkYXRlIHRoZSBsaWdodG1hcCBhbmQgdGhlIGFjY3VtdWxhdGl2ZSBsaWdodHNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhbWVzOyBpKyspIHtcbiAgICAgICAgYXBpLmxpZ2h0cy5mb3JFYWNoKGxpZ2h0ID0+IGxpZ2h0LnVwZGF0ZSgpKTtcbiAgICAgICAgcGxtLnVwZGF0ZShjYW1lcmEsIGFwaS5ibGVuZCk7XG4gICAgICB9XG4gICAgICAvLyBTd2l0Y2ggbGlnaHRzIG9mZlxuICAgICAgZ0xpZ2h0cy5jdXJyZW50LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIC8vIFJlc3RvcmUgbGlnaHRzIGFuZCBtZXNoZXNcbiAgICAgIHBsbS5maW5pc2goKTtcbiAgICB9XG4gIH0pLCBbcGxtLCBjYW1lcmEsIHNjZW5lLCB0ZW1wb3JhbCwgZnJhbWVzLCBibGVuZCwgb3BhY2l0eSwgYWxwaGFUZXN0XSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUmVzZXQgaW50ZXJuYWxzLCBidWZmZXJzLCAuLi5cbiAgICBhcGkucmVzZXQoKTtcbiAgICAvLyBVcGRhdGUgbGlnaHRtYXBcbiAgICBpZiAoIWFwaS50ZW1wb3JhbCAmJiBhcGkuZnJhbWVzICE9PSBJbmZpbml0eSkgYXBpLnVwZGF0ZShhcGkuYmxlbmQpO1xuICB9KTtcblxuICAvLyBFeHBvc2UgYXBpLCBhbGxvdyBjaGlsZHJlbiB0byBzZXQgaXRzZWxmIGFzIHRoZSBtYWluIGxpZ2h0IHNvdXJjZVxuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRSZWYsICgpID0+IGFwaSwgW2FwaV0pO1xuICB1c2VGcmFtZSgoKSA9PiB7XG4gICAgaWYgKChhcGkudGVtcG9yYWwgfHwgYXBpLmZyYW1lcyA9PT0gSW5maW5pdHkpICYmIGFwaS5jb3VudCA8IGFwaS5mcmFtZXMgJiYgYXBpLmNvdW50IDwgbGltaXQpIHtcbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICAgIGFwaS51cGRhdGUoKTtcbiAgICAgIGFwaS5jb3VudCsrO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHByb3BzLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHtcbiAgICB0cmF2ZXJzZTogKCkgPT4gbnVsbCxcbiAgICByZWY6IGdMaWdodHNcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoYWNjdW11bGF0aXZlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcGlcbiAgfSwgY2hpbGRyZW4pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHtcbiAgICByZWNlaXZlU2hhZG93OiB0cnVlLFxuICAgIHJlZjogZ1BsYW5lLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICByb3RhdGlvbjogWy1NYXRoLlBJIC8gMiwgMCwgMF1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwbGFuZUdlb21ldHJ5XCIsIG51bGwpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNvZnRTaGFkb3dNYXRlcmlhbFwiLCB7XG4gICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgZGVwdGhXcml0ZTogZmFsc2UsXG4gICAgdG9uZU1hcHBlZDogdG9uZU1hcHBlZCxcbiAgICBjb2xvcjogY29sb3IsXG4gICAgYmxlbmQ6IGNvbG9yQmxlbmQsXG4gICAgbWFwOiBwbG0ucHJvZ3Jlc3NpdmVMaWdodE1hcDIudGV4dHVyZVxuICB9KSkpO1xufSk7XG5jb25zdCBSYW5kb21pemVkTGlnaHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGNhc3RTaGFkb3cgPSB0cnVlLFxuICBiaWFzID0gMC4wMDEsXG4gIG1hcFNpemUgPSA1MTIsXG4gIHNpemUgPSA1LFxuICBuZWFyID0gMC41LFxuICBmYXIgPSA1MDAsXG4gIGZyYW1lcyA9IDEsXG4gIHBvc2l0aW9uID0gWzAsIDAsIDBdLFxuICByYWRpdXMgPSAxLFxuICBhbW91bnQgPSA4LFxuICBpbnRlbnNpdHkgPSB2ZXJzaW9uID49IDE1NSA/IE1hdGguUEkgOiAxLFxuICBhbWJpZW50ID0gMC41LFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZFJlZikgPT4ge1xuICBjb25zdCBnTGlnaHRzID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBsZW5ndGggPSBuZXcgVEhSRUUuVmVjdG9yMyguLi5wb3NpdGlvbikubGVuZ3RoKCk7XG4gIGNvbnN0IHBhcmVudCA9IFJlYWN0LnVzZUNvbnRleHQoYWNjdW11bGF0aXZlQ29udGV4dCk7XG4gIGNvbnN0IHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBsZXQgbGlnaHQ7XG4gICAgaWYgKGdMaWdodHMuY3VycmVudCkge1xuICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBnTGlnaHRzLmN1cnJlbnQuY2hpbGRyZW4ubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgbGlnaHQgPSBnTGlnaHRzLmN1cnJlbnQuY2hpbGRyZW5bbF07XG4gICAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gYW1iaWVudCkge1xuICAgICAgICAgIGxpZ2h0LnBvc2l0aW9uLnNldChwb3NpdGlvblswXSArIFRIUkVFLk1hdGhVdGlscy5yYW5kRmxvYXRTcHJlYWQocmFkaXVzKSwgcG9zaXRpb25bMV0gKyBUSFJFRS5NYXRoVXRpbHMucmFuZEZsb2F0U3ByZWFkKHJhZGl1cyksIHBvc2l0aW9uWzJdICsgVEhSRUUuTWF0aFV0aWxzLnJhbmRGbG9hdFNwcmVhZChyYWRpdXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgbGFtYmRhID0gTWF0aC5hY29zKDIgKiBNYXRoLnJhbmRvbSgpIC0gMSkgLSBNYXRoLlBJIC8gMi4wO1xuICAgICAgICAgIGxldCBwaGkgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgbGlnaHQucG9zaXRpb24uc2V0KE1hdGguY29zKGxhbWJkYSkgKiBNYXRoLmNvcyhwaGkpICogbGVuZ3RoLCBNYXRoLmFicyhNYXRoLmNvcyhsYW1iZGEpICogTWF0aC5zaW4ocGhpKSAqIGxlbmd0aCksIE1hdGguc2luKGxhbWJkYSkgKiBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbcmFkaXVzLCBhbWJpZW50LCBsZW5ndGgsIC4uLnBvc2l0aW9uXSk7XG4gIGNvbnN0IGFwaSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICB1cGRhdGVcbiAgfSksIFt1cGRhdGVdKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkUmVmLCAoKSA9PiBhcGksIFthcGldKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BhcmVudCRsaWdodHM7XG4gICAgY29uc3QgZ3JvdXAgPSBnTGlnaHRzLmN1cnJlbnQ7XG4gICAgaWYgKHBhcmVudCkgKF9wYXJlbnQkbGlnaHRzID0gcGFyZW50LmxpZ2h0cykgPT0gbnVsbCB8fCBfcGFyZW50JGxpZ2h0cy5zZXQoZ3JvdXAudXVpZCwgYXBpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdmFyIF9wYXJlbnQkbGlnaHRzMjtcbiAgICAgIHJldHVybiB2b2lkIChwYXJlbnQgPT0gbnVsbCB8fCAoX3BhcmVudCRsaWdodHMyID0gcGFyZW50LmxpZ2h0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnQkbGlnaHRzMi5kZWxldGUoZ3JvdXAudXVpZCkpO1xuICAgIH07XG4gIH0sIFtwYXJlbnQsIGFwaV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBnTGlnaHRzXG4gIH0sIHByb3BzKSwgQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBhbW91bnRcbiAgfSwgKF8sIGluZGV4KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpcmVjdGlvbmFsTGlnaHRcIiwge1xuICAgIGtleTogaW5kZXgsXG4gICAgY2FzdFNoYWRvdzogY2FzdFNoYWRvdyxcbiAgICBcInNoYWRvdy1iaWFzXCI6IGJpYXMsXG4gICAgXCJzaGFkb3ctbWFwU2l6ZVwiOiBbbWFwU2l6ZSwgbWFwU2l6ZV0sXG4gICAgaW50ZW5zaXR5OiBpbnRlbnNpdHkgLyBhbW91bnRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcnRob2dyYXBoaWNDYW1lcmFcIiwge1xuICAgIGF0dGFjaDogXCJzaGFkb3ctY2FtZXJhXCIsXG4gICAgYXJnczogWy1zaXplLCBzaXplLCBzaXplLCAtc2l6ZSwgbmVhciwgZmFyXVxuICB9KSkpKTtcbn0pO1xuXG4vLyBCYXNlZCBvbiBcIlByb2dyZXNzaXZlIExpZ2h0IE1hcCBBY2N1bXVsYXRvclwiLCBieSBbemFsb10oaHR0cHM6Ly9naXRodWIuY29tL3phbG8vKVxuY2xhc3MgUHJvZ3Jlc3NpdmVMaWdodE1hcCB7XG4gIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBzY2VuZSwgcmVzID0gMTAyNCkge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLnJlcyA9IHJlcztcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5idWZmZXIxQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5saWdodHMgPSBbXTtcbiAgICB0aGlzLm1lc2hlcyA9IFtdO1xuICAgIHRoaXMub2JqZWN0ID0gbnVsbDtcbiAgICB0aGlzLmNsZWFyQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgICB0aGlzLmNsZWFyQWxwaGEgPSAwO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBQcm9ncmVzc2l2ZSBMaWdodE1hcCBUZXh0dXJlXG4gICAgY29uc3QgdGV4dHVyZVBhcmFtcyA9IHtcbiAgICAgIHR5cGU6IFRIUkVFLkhhbGZGbG9hdFR5cGUsXG4gICAgICBtYWdGaWx0ZXI6IFRIUkVFLk5lYXJlc3RGaWx0ZXIsXG4gICAgICBtaW5GaWx0ZXI6IFRIUkVFLk5lYXJlc3RGaWx0ZXJcbiAgICB9O1xuICAgIHRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDEgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQodGhpcy5yZXMsIHRoaXMucmVzLCB0ZXh0dXJlUGFyYW1zKTtcbiAgICB0aGlzLnByb2dyZXNzaXZlTGlnaHRNYXAyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KHRoaXMucmVzLCB0aGlzLnJlcywgdGV4dHVyZVBhcmFtcyk7XG5cbiAgICAvLyBJbmplY3Qgc29tZSBzcGljeSBuZXcgbG9naWMgaW50byBhIHN0YW5kYXJkIHBob25nIG1hdGVyaWFsXG4gICAgdGhpcy5kaXNjYXJkTWF0ID0gbmV3IERpc2NhcmRNYXRlcmlhbCgpO1xuICAgIHRoaXMudGFyZ2V0TWF0ID0gbmV3IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwoe1xuICAgICAgZm9nOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMucHJldmlvdXNTaGFkb3dNYXAgPSB7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMS50ZXh0dXJlXG4gICAgfTtcbiAgICB0aGlzLmF2ZXJhZ2luZ1dpbmRvdyA9IHtcbiAgICAgIHZhbHVlOiAxMDBcbiAgICB9O1xuICAgIHRoaXMudGFyZ2V0TWF0Lm9uQmVmb3JlQ29tcGlsZSA9IHNoYWRlciA9PiB7XG4gICAgICAvLyBWZXJ0ZXggU2hhZGVyOiBTZXQgVmVydGV4IFBvc2l0aW9ucyB0byB0aGUgVW53cmFwcGVkIFVWIFBvc2l0aW9uc1xuICAgICAgc2hhZGVyLnZlcnRleFNoYWRlciA9ICd2YXJ5aW5nIHZlYzIgdlV2O1xcbicgKyBzaGFkZXIudmVydGV4U2hhZGVyLnNsaWNlKDAsIC0xKSArICd2VXYgPSB1djsgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1diAtIDAuNSkgKiAyLjAsIDEuMCwgMS4wKTsgfSc7XG5cbiAgICAgIC8vIEZyYWdtZW50IFNoYWRlcjogU2V0IFBpeGVscyB0byBhdmVyYWdlIGluIHRoZSBQcmV2aW91cyBmcmFtZSdzIFNoYWRvd3NcbiAgICAgIGNvbnN0IGJvZHlTdGFydCA9IHNoYWRlci5mcmFnbWVudFNoYWRlci5pbmRleE9mKCd2b2lkIG1haW4oKSB7Jyk7XG4gICAgICBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSAndmFyeWluZyB2ZWMyIHZVdjtcXG4nICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyLnNsaWNlKDAsIGJvZHlTdGFydCkgKyAndW5pZm9ybSBzYW1wbGVyMkQgcHJldmlvdXNTaGFkb3dNYXA7XFxuXHR1bmlmb3JtIGZsb2F0IGF2ZXJhZ2luZ1dpbmRvdztcXG4nICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyLnNsaWNlKGJvZHlTdGFydCAtIDEsIC0xKSArIGBcXG52ZWMzIHRleGVsT2xkID0gdGV4dHVyZTJEKHByZXZpb3VzU2hhZG93TWFwLCB2VXYpLnJnYjtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yLnJnYiA9IG1peCh0ZXhlbE9sZCwgZ2xfRnJhZ0NvbG9yLnJnYiwgMS4wLyBhdmVyYWdpbmdXaW5kb3cpO1xuICAgICAgfWA7XG5cbiAgICAgIC8vIFNldCB0aGUgUHJldmlvdXMgRnJhbWUncyBUZXh0dXJlIEJ1ZmZlciBhbmQgQXZlcmFnaW5nIFdpbmRvd1xuICAgICAgc2hhZGVyLnVuaWZvcm1zLnByZXZpb3VzU2hhZG93TWFwID0gdGhpcy5wcmV2aW91c1NoYWRvd01hcDtcbiAgICAgIHNoYWRlci51bmlmb3Jtcy5hdmVyYWdpbmdXaW5kb3cgPSB0aGlzLmF2ZXJhZ2luZ1dpbmRvdztcbiAgICB9O1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcih0aGlzLmNsZWFyQ29sb3IpO1xuICAgIHRoaXMuY2xlYXJBbHBoYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcignYmxhY2snLCAxKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFJlbmRlclRhcmdldCh0aGlzLnByb2dyZXNzaXZlTGlnaHRNYXAxKTtcbiAgICB0aGlzLnJlbmRlcmVyLmNsZWFyKCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMik7XG4gICAgdGhpcy5yZW5kZXJlci5jbGVhcigpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLmNsZWFyQ29sb3IsIHRoaXMuY2xlYXJBbHBoYSk7XG4gICAgdGhpcy5saWdodHMgPSBbXTtcbiAgICB0aGlzLm1lc2hlcyA9IFtdO1xuICAgIHRoaXMuc2NlbmUudHJhdmVyc2Uob2JqZWN0ID0+IHtcbiAgICAgIGlmIChpc0dlb21ldHJ5KG9iamVjdCkpIHtcbiAgICAgICAgdGhpcy5tZXNoZXMucHVzaCh7XG4gICAgICAgICAgb2JqZWN0LFxuICAgICAgICAgIG1hdGVyaWFsOiBvYmplY3QubWF0ZXJpYWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTGlnaHQob2JqZWN0KSkge1xuICAgICAgICB0aGlzLmxpZ2h0cy5wdXNoKHtcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgaW50ZW5zaXR5OiBvYmplY3QuaW50ZW5zaXR5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHByZXBhcmUoKSB7XG4gICAgdGhpcy5saWdodHMuZm9yRWFjaChsaWdodCA9PiBsaWdodC5vYmplY3QuaW50ZW5zaXR5ID0gMCk7XG4gICAgdGhpcy5tZXNoZXMuZm9yRWFjaChtZXNoID0+IG1lc2gub2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5kaXNjYXJkTWF0KTtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgdGhpcy5saWdodHMuZm9yRWFjaChsaWdodCA9PiBsaWdodC5vYmplY3QuaW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5KTtcbiAgICB0aGlzLm1lc2hlcy5mb3JFYWNoKG1lc2ggPT4gbWVzaC5vYmplY3QubWF0ZXJpYWwgPSBtZXNoLm1hdGVyaWFsKTtcbiAgfVxuICBjb25maWd1cmUob2JqZWN0KSB7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gIH1cbiAgdXBkYXRlKGNhbWVyYSwgYmxlbmRXaW5kb3cgPSAxMDApIHtcbiAgICBpZiAoIXRoaXMub2JqZWN0KSByZXR1cm47XG4gICAgLy8gU2V0IGVhY2ggb2JqZWN0J3MgbWF0ZXJpYWwgdG8gdGhlIFVWIFVud3JhcHBlZCBTdXJmYWNlIE1hcHBpbmcgVmVyc2lvblxuICAgIHRoaXMuYXZlcmFnaW5nV2luZG93LnZhbHVlID0gYmxlbmRXaW5kb3c7XG4gICAgdGhpcy5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLnRhcmdldE1hdDtcbiAgICAvLyBQaW5nLXBvbmcgdHdvIHN1cmZhY2UgYnVmZmVycyBmb3IgcmVhZGluZy93cml0aW5nXG4gICAgY29uc3QgYWN0aXZlTWFwID0gdGhpcy5idWZmZXIxQWN0aXZlID8gdGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMSA6IHRoaXMucHJvZ3Jlc3NpdmVMaWdodE1hcDI7XG4gICAgY29uc3QgaW5hY3RpdmVNYXAgPSB0aGlzLmJ1ZmZlcjFBY3RpdmUgPyB0aGlzLnByb2dyZXNzaXZlTGlnaHRNYXAyIDogdGhpcy5wcm9ncmVzc2l2ZUxpZ2h0TWFwMTtcbiAgICAvLyBSZW5kZXIgdGhlIG9iamVjdCdzIHN1cmZhY2UgbWFwc1xuICAgIGNvbnN0IG9sZEJnID0gdGhpcy5zY2VuZS5iYWNrZ3JvdW5kO1xuICAgIHRoaXMuc2NlbmUuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoYWN0aXZlTWFwKTtcbiAgICB0aGlzLnByZXZpb3VzU2hhZG93TWFwLnZhbHVlID0gaW5hY3RpdmVNYXAudGV4dHVyZTtcbiAgICB0aGlzLmJ1ZmZlcjFBY3RpdmUgPSAhdGhpcy5idWZmZXIxQWN0aXZlO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuc2NlbmUsIGNhbWVyYSk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgdGhpcy5zY2VuZS5iYWNrZ3JvdW5kID0gb2xkQmc7XG4gIH1cbn1cblxuZXhwb3J0IHsgQWNjdW11bGF0aXZlU2hhZG93cywgUmFuZG9taXplZExpZ2h0LCBhY2N1bXVsYXRpdmVDb250ZXh0IH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJUSFJFRSIsIlJlYWN0IiwiZXh0ZW5kIiwidXNlVGhyZWUiLCJ1c2VGcmFtZSIsInNoYWRlck1hdGVyaWFsIiwiRGlzY2FyZE1hdGVyaWFsIiwidmVyc2lvbiIsImlzTGlnaHQiLCJvYmplY3QiLCJpc0dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJhY2N1bXVsYXRpdmVDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIlNvZnRTaGFkb3dNYXRlcmlhbCIsImNvbG9yIiwiQ29sb3IiLCJibGVuZCIsImFscGhhVGVzdCIsIm9wYWNpdHkiLCJtYXAiLCJBY2N1bXVsYXRpdmVTaGFkb3dzIiwiZm9yd2FyZFJlZiIsImNoaWxkcmVuIiwidGVtcG9yYWwiLCJmcmFtZXMiLCJsaW1pdCIsIkluZmluaXR5Iiwic2NhbGUiLCJjb2xvckJsZW5kIiwicmVzb2x1dGlvbiIsInRvbmVNYXBwZWQiLCJwcm9wcyIsImdsIiwic3RhdGUiLCJzY2VuZSIsImNhbWVyYSIsImludmFsaWRhdGUiLCJnUGxhbmUiLCJ1c2VSZWYiLCJnTGlnaHRzIiwicGxtIiwidXNlU3RhdGUiLCJQcm9ncmVzc2l2ZUxpZ2h0TWFwIiwidXNlTGF5b3V0RWZmZWN0IiwiY29uZmlndXJlIiwiY3VycmVudCIsImFwaSIsInVzZU1lbW8iLCJsaWdodHMiLCJNYXAiLCJNYXRoIiwibWF4IiwiY291bnQiLCJnZXRNZXNoIiwicmVzZXQiLCJjbGVhciIsIm1hdGVyaWFsIiwidXBkYXRlIiwibWluIiwidmlzaWJsZSIsInByZXBhcmUiLCJpIiwiZm9yRWFjaCIsImxpZ2h0IiwiZmluaXNoIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUVsZW1lbnQiLCJ0cmF2ZXJzZSIsInJlZiIsIlByb3ZpZGVyIiwidmFsdWUiLCJyZWNlaXZlU2hhZG93Iiwicm90YXRpb24iLCJQSSIsInRyYW5zcGFyZW50IiwiZGVwdGhXcml0ZSIsInByb2dyZXNzaXZlTGlnaHRNYXAyIiwidGV4dHVyZSIsIlJhbmRvbWl6ZWRMaWdodCIsImNhc3RTaGFkb3ciLCJiaWFzIiwibWFwU2l6ZSIsInNpemUiLCJuZWFyIiwiZmFyIiwicG9zaXRpb24iLCJyYWRpdXMiLCJhbW91bnQiLCJpbnRlbnNpdHkiLCJhbWJpZW50IiwibGVuZ3RoIiwiVmVjdG9yMyIsInBhcmVudCIsInVzZUNvbnRleHQiLCJ1c2VDYWxsYmFjayIsImwiLCJyYW5kb20iLCJzZXQiLCJNYXRoVXRpbHMiLCJyYW5kRmxvYXRTcHJlYWQiLCJsYW1iZGEiLCJhY29zIiwicGhpIiwiY29zIiwiYWJzIiwic2luIiwiX3BhcmVudCRsaWdodHMiLCJncm91cCIsInV1aWQiLCJfcGFyZW50JGxpZ2h0czIiLCJkZWxldGUiLCJBcnJheSIsImZyb20iLCJfIiwiaW5kZXgiLCJrZXkiLCJhdHRhY2giLCJhcmdzIiwiY29uc3RydWN0b3IiLCJyZW5kZXJlciIsInJlcyIsImJ1ZmZlcjFBY3RpdmUiLCJtZXNoZXMiLCJjbGVhckNvbG9yIiwiY2xlYXJBbHBoYSIsInRleHR1cmVQYXJhbXMiLCJ0eXBlIiwiSGFsZkZsb2F0VHlwZSIsIm1hZ0ZpbHRlciIsIk5lYXJlc3RGaWx0ZXIiLCJtaW5GaWx0ZXIiLCJwcm9ncmVzc2l2ZUxpZ2h0TWFwMSIsIldlYkdMUmVuZGVyVGFyZ2V0IiwiZGlzY2FyZE1hdCIsInRhcmdldE1hdCIsIk1lc2hMYW1iZXJ0TWF0ZXJpYWwiLCJmb2ciLCJwcmV2aW91c1NoYWRvd01hcCIsImF2ZXJhZ2luZ1dpbmRvdyIsIm9uQmVmb3JlQ29tcGlsZSIsInNoYWRlciIsInZlcnRleFNoYWRlciIsInNsaWNlIiwiYm9keVN0YXJ0IiwiZnJhZ21lbnRTaGFkZXIiLCJpbmRleE9mIiwidW5pZm9ybXMiLCJnZXRDbGVhckNvbG9yIiwiZ2V0Q2xlYXJBbHBoYSIsInNldENsZWFyQ29sb3IiLCJzZXRSZW5kZXJUYXJnZXQiLCJwdXNoIiwibWVzaCIsImJsZW5kV2luZG93IiwiYWN0aXZlTWFwIiwiaW5hY3RpdmVNYXAiLCJvbGRCZyIsImJhY2tncm91bmQiLCJyZW5kZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/AccumulativeShadows.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Bounds.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Bounds.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bounds: () => (/* binding */ Bounds),\n/* harmony export */   useBounds: () => (/* binding */ useBounds)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n\n\n\n// eslint-disable-next-line no-shadow\nvar AnimationState = /*#__PURE__*/ function(AnimationState) {\n    AnimationState[AnimationState[\"NONE\"] = 0] = \"NONE\";\n    AnimationState[AnimationState[\"START\"] = 1] = \"START\";\n    AnimationState[AnimationState[\"ACTIVE\"] = 2] = \"ACTIVE\";\n    return AnimationState;\n}(AnimationState || {});\nconst isOrthographic = (def)=>def && def.isOrthographicCamera;\nconst isBox3 = (def)=>def && def.isBox3;\nconst interpolateFuncDefault = (t)=>{\n    // Imitates the previously used THREE.MathUtils.damp\n    return 1 - Math.exp(-5 * t) + 0.007 * t;\n};\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction Bounds({ children, maxDuration = 1.0, margin = 1.2, observe, fit, clip, interpolateFunc = interpolateFuncDefault, onFit }) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const { camera, size, invalidate } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.D)();\n    const controls = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.D)((state)=>state.controls);\n    const onFitRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onFit);\n    onFitRef.current = onFit;\n    const origin = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        camPos: new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(),\n        camRot: new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion(),\n        camZoom: 1\n    });\n    const goal = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        camPos: undefined,\n        camRot: undefined,\n        camZoom: undefined,\n        camUp: undefined,\n        target: undefined\n    });\n    const animationState = react__WEBPACK_IMPORTED_MODULE_0__.useRef(AnimationState.NONE);\n    const t = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0); // represent animation state from 0 to 1\n    const [box] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_2__.Box3());\n    const api = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        function getSize() {\n            const boxSize = box.getSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n            const center = box.getCenter(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3());\n            const maxSize = Math.max(boxSize.x, boxSize.y, boxSize.z);\n            const fitHeightDistance = isOrthographic(camera) ? maxSize * 4 : maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));\n            const fitWidthDistance = isOrthographic(camera) ? maxSize * 4 : fitHeightDistance / camera.aspect;\n            const distance = margin * Math.max(fitHeightDistance, fitWidthDistance);\n            return {\n                box,\n                size: boxSize,\n                center,\n                distance\n            };\n        }\n        return {\n            getSize,\n            refresh (object) {\n                if (isBox3(object)) box.copy(object);\n                else {\n                    const target = object || ref.current;\n                    if (!target) return this;\n                    target.updateWorldMatrix(true, true);\n                    box.setFromObject(target);\n                }\n                if (box.isEmpty()) {\n                    const max = camera.position.length() || 10;\n                    box.setFromCenterAndSize(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(max, max, max));\n                }\n                origin.current.camPos.copy(camera.position);\n                origin.current.camRot.copy(camera.quaternion);\n                isOrthographic(camera) && (origin.current.camZoom = camera.zoom);\n                goal.current.camPos = undefined;\n                goal.current.camRot = undefined;\n                goal.current.camZoom = undefined;\n                goal.current.camUp = undefined;\n                goal.current.target = undefined;\n                return this;\n            },\n            reset () {\n                const { center, distance } = getSize();\n                const direction = camera.position.clone().sub(center).normalize();\n                goal.current.camPos = center.clone().addScaledVector(direction, distance);\n                goal.current.target = center.clone();\n                const mCamRot = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().lookAt(goal.current.camPos, goal.current.target, camera.up);\n                goal.current.camRot = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromRotationMatrix(mCamRot);\n                animationState.current = AnimationState.START;\n                t.current = 0;\n                return this;\n            },\n            moveTo (position) {\n                goal.current.camPos = Array.isArray(position) ? new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(...position) : position.clone();\n                animationState.current = AnimationState.START;\n                t.current = 0;\n                return this;\n            },\n            lookAt ({ target, up }) {\n                goal.current.target = Array.isArray(target) ? new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(...target) : target.clone();\n                if (up) {\n                    goal.current.camUp = Array.isArray(up) ? new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(...up) : up.clone();\n                } else {\n                    goal.current.camUp = camera.up.clone();\n                }\n                const mCamRot = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().lookAt(goal.current.camPos || camera.position, goal.current.target, goal.current.camUp);\n                goal.current.camRot = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion().setFromRotationMatrix(mCamRot);\n                animationState.current = AnimationState.START;\n                t.current = 0;\n                return this;\n            },\n            /**\n       * @deprecated Use moveTo and lookAt instead\n       */ to ({ position, target }) {\n                return this.moveTo(position).lookAt({\n                    target\n                });\n            },\n            fit () {\n                if (!isOrthographic(camera)) {\n                    // For non-orthographic cameras, fit should behave exactly like reset\n                    return this.reset();\n                }\n                // For orthographic cameras, fit should only modify the zoom value\n                let maxHeight = 0, maxWidth = 0;\n                const vertices = [\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.min.x, box.min.y, box.min.z),\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.min.x, box.max.y, box.min.z),\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.min.x, box.min.y, box.max.z),\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.min.x, box.max.y, box.max.z),\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.max.x, box.max.y, box.max.z),\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.max.x, box.max.y, box.min.z),\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.max.x, box.min.y, box.max.z),\n                    new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(box.max.x, box.min.y, box.min.z)\n                ];\n                // Transform the center and each corner to camera space\n                const pos = goal.current.camPos || camera.position;\n                const target = goal.current.target || (controls == null ? void 0 : controls.target);\n                const up = goal.current.camUp || camera.up;\n                const mCamWInv = target ? new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().lookAt(pos, target, up).setPosition(pos).invert() : camera.matrixWorldInverse;\n                for (const v of vertices){\n                    v.applyMatrix4(mCamWInv);\n                    maxHeight = Math.max(maxHeight, Math.abs(v.y));\n                    maxWidth = Math.max(maxWidth, Math.abs(v.x));\n                }\n                maxHeight *= 2;\n                maxWidth *= 2;\n                const zoomForHeight = (camera.top - camera.bottom) / maxHeight;\n                const zoomForWidth = (camera.right - camera.left) / maxWidth;\n                goal.current.camZoom = Math.min(zoomForHeight, zoomForWidth) / margin;\n                animationState.current = AnimationState.START;\n                t.current = 0;\n                onFitRef.current && onFitRef.current(this.getSize());\n                return this;\n            },\n            clip () {\n                const { distance } = getSize();\n                camera.near = distance / 100;\n                camera.far = distance * 100;\n                camera.updateProjectionMatrix();\n                if (controls) {\n                    controls.maxDistance = distance * 10;\n                    controls.update();\n                }\n                invalidate();\n                return this;\n            }\n        };\n    }, [\n        box,\n        camera,\n        controls,\n        margin,\n        invalidate\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        if (controls) {\n            // Try to prevent drag hijacking\n            const callback = ()=>{\n                if (controls && goal.current.target && animationState.current !== AnimationState.NONE) {\n                    const front = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().setFromMatrixColumn(camera.matrix, 2);\n                    const d0 = origin.current.camPos.distanceTo(controls.target);\n                    const d1 = (goal.current.camPos || origin.current.camPos).distanceTo(goal.current.target);\n                    const d = (1 - t.current) * d0 + t.current * d1;\n                    controls.target.copy(camera.position).addScaledVector(front, -d);\n                    controls.update();\n                }\n                animationState.current = AnimationState.NONE;\n            };\n            controls.addEventListener(\"start\", callback);\n            return ()=>controls.removeEventListener(\"start\", callback);\n        }\n    }, [\n        controls\n    ]);\n    // Scale pointer on window resize\n    const count = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        if (observe || count.current++ === 0) {\n            api.refresh();\n            if (fit) api.reset().fit();\n            if (clip) api.clip();\n        }\n    }, [\n        size,\n        clip,\n        fit,\n        observe,\n        camera,\n        controls\n    ]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.F)((state, delta)=>{\n        // This [additional animation step START] is needed to guarantee that delta used in animation isn't absurdly high (2-3 seconds) which is actually possible if rendering happens on demand...\n        if (animationState.current === AnimationState.START) {\n            animationState.current = AnimationState.ACTIVE;\n            invalidate();\n        } else if (animationState.current === AnimationState.ACTIVE) {\n            t.current += delta / maxDuration;\n            if (t.current >= 1) {\n                goal.current.camPos && camera.position.copy(goal.current.camPos);\n                goal.current.camRot && camera.quaternion.copy(goal.current.camRot);\n                goal.current.camUp && camera.up.copy(goal.current.camUp);\n                goal.current.camZoom && isOrthographic(camera) && (camera.zoom = goal.current.camZoom);\n                camera.updateMatrixWorld();\n                camera.updateProjectionMatrix();\n                if (controls && goal.current.target) {\n                    controls.target.copy(goal.current.target);\n                    controls.update();\n                }\n                animationState.current = AnimationState.NONE;\n            } else {\n                const k = interpolateFunc(t.current);\n                goal.current.camPos && camera.position.lerpVectors(origin.current.camPos, goal.current.camPos, k);\n                goal.current.camRot && camera.quaternion.slerpQuaternions(origin.current.camRot, goal.current.camRot, k);\n                goal.current.camUp && camera.up.set(0, 1, 0).applyQuaternion(camera.quaternion);\n                goal.current.camZoom && isOrthographic(camera) && (camera.zoom = (1 - k) * origin.current.camZoom + k * goal.current.camZoom);\n                camera.updateMatrixWorld();\n                camera.updateProjectionMatrix();\n            }\n            invalidate();\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", {\n        ref: ref\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: api\n    }, children));\n}\nfunction useBounds() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Cb3VuZHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDeUI7QUFFeEQscUNBQXFDO0FBQ3JDLElBQUlJLGlCQUFpQixXQUFXLEdBQUUsU0FBVUEsY0FBYztJQUN4REEsY0FBYyxDQUFDQSxjQUFjLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUM3Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsUUFBUSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsY0FBYyxDQUFDQSxjQUFjLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUMvQyxPQUFPQTtBQUNULEVBQUVBLGtCQUFrQixDQUFDO0FBQ3JCLE1BQU1DLGlCQUFpQkMsQ0FBQUEsTUFBT0EsT0FBT0EsSUFBSUMsb0JBQW9CO0FBQzdELE1BQU1DLFNBQVNGLENBQUFBLE1BQU9BLE9BQU9BLElBQUlFLE1BQU07QUFDdkMsTUFBTUMseUJBQXlCQyxDQUFBQTtJQUM3QixvREFBb0Q7SUFDcEQsT0FBTyxJQUFJQyxLQUFLQyxHQUFHLENBQUMsQ0FBQyxJQUFJRixLQUFLLFFBQVFBO0FBQ3hDO0FBQ0EsTUFBTUcsVUFBVSxXQUFXLEdBQUViLGdEQUFtQixDQUFDO0FBQ2pELFNBQVNlLE9BQU8sRUFDZEMsUUFBUSxFQUNSQyxjQUFjLEdBQUcsRUFDakJDLFNBQVMsR0FBRyxFQUNaQyxPQUFPLEVBQ1BDLEdBQUcsRUFDSEMsSUFBSSxFQUNKQyxrQkFBa0JiLHNCQUFzQixFQUN4Q2MsS0FBSyxFQUNOO0lBQ0MsTUFBTUMsTUFBTXhCLHlDQUFZLENBQUM7SUFDekIsTUFBTSxFQUNKMEIsTUFBTSxFQUNOQyxJQUFJLEVBQ0pDLFVBQVUsRUFDWCxHQUFHMUIscURBQVFBO0lBQ1osTUFBTTJCLFdBQVczQixxREFBUUEsQ0FBQzRCLENBQUFBLFFBQVNBLE1BQU1ELFFBQVE7SUFDakQsTUFBTUUsV0FBVy9CLHlDQUFZLENBQUN1QjtJQUM5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STdHLGdCQUFnQlosRUFBRXNCLE9BQU87Z0JBQ25DTyxLQUFLUCxPQUFPLENBQUNFLE1BQU0sSUFBSVIsT0FBTzhDLFFBQVEsQ0FBQzRELFdBQVcsQ0FBQ25HLE9BQU9ELE9BQU8sQ0FBQ0UsTUFBTSxFQUFFSyxLQUFLUCxPQUFPLENBQUNFLE1BQU0sRUFBRWlHO2dCQUMvRjVGLEtBQUtQLE9BQU8sQ0FBQ0ksTUFBTSxJQUFJVixPQUFPaUQsVUFBVSxDQUFDMEQsZ0JBQWdCLENBQUNwRyxPQUFPRCxPQUFPLENBQUNJLE1BQU0sRUFBRUcsS0FBS1AsT0FBTyxDQUFDSSxNQUFNLEVBQUUrRjtnQkFDdEc1RixLQUFLUCxPQUFPLENBQUNTLEtBQUssSUFBSWYsT0FBTzRELEVBQUUsQ0FBQ2dELEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBR0MsZUFBZSxDQUFDN0csT0FBT2lELFVBQVU7Z0JBQzlFcEMsS0FBS1AsT0FBTyxDQUFDTSxPQUFPLElBQUlqQyxlQUFlcUIsV0FBWUEsQ0FBQUEsT0FBT2tELElBQUksR0FBRyxDQUFDLElBQUl1RCxDQUFBQSxJQUFLbEcsT0FBT0QsT0FBTyxDQUFDTSxPQUFPLEdBQUc2RixJQUFJNUYsS0FBS1AsT0FBTyxDQUFDTSxPQUFPO2dCQUM1SFosT0FBT3dHLGlCQUFpQjtnQkFDeEJ4RyxPQUFPdUYsc0JBQXNCO1lBQy9CO1lBQ0FyRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPLFdBQVcsR0FBRTVCLGdEQUFtQixDQUFDLFNBQVM7UUFDL0N3QixLQUFLQTtJQUNQLEdBQUcsV0FBVyxHQUFFeEIsZ0RBQW1CLENBQUNhLFFBQVE0SCxRQUFRLEVBQUU7UUFDcERDLE9BQU8xRjtJQUNULEdBQUdoQztBQUNMO0FBQ0EsU0FBUzJIO0lBQ1AsT0FBTzNJLDZDQUFnQixDQUFDYTtBQUMxQjtBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Cb3VuZHMuanM/ZTQ5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93XG52YXIgQW5pbWF0aW9uU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKEFuaW1hdGlvblN0YXRlKSB7XG4gIEFuaW1hdGlvblN0YXRlW0FuaW1hdGlvblN0YXRlW1wiTk9ORVwiXSA9IDBdID0gXCJOT05FXCI7XG4gIEFuaW1hdGlvblN0YXRlW0FuaW1hdGlvblN0YXRlW1wiU1RBUlRcIl0gPSAxXSA9IFwiU1RBUlRcIjtcbiAgQW5pbWF0aW9uU3RhdGVbQW5pbWF0aW9uU3RhdGVbXCJBQ1RJVkVcIl0gPSAyXSA9IFwiQUNUSVZFXCI7XG4gIHJldHVybiBBbmltYXRpb25TdGF0ZTtcbn0oQW5pbWF0aW9uU3RhdGUgfHwge30pO1xuY29uc3QgaXNPcnRob2dyYXBoaWMgPSBkZWYgPT4gZGVmICYmIGRlZi5pc09ydGhvZ3JhcGhpY0NhbWVyYTtcbmNvbnN0IGlzQm94MyA9IGRlZiA9PiBkZWYgJiYgZGVmLmlzQm94MztcbmNvbnN0IGludGVycG9sYXRlRnVuY0RlZmF1bHQgPSB0ID0+IHtcbiAgLy8gSW1pdGF0ZXMgdGhlIHByZXZpb3VzbHkgdXNlZCBUSFJFRS5NYXRoVXRpbHMuZGFtcFxuICByZXR1cm4gMSAtIE1hdGguZXhwKC01ICogdCkgKyAwLjAwNyAqIHQ7XG59O1xuY29uc3QgY29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gQm91bmRzKHtcbiAgY2hpbGRyZW4sXG4gIG1heER1cmF0aW9uID0gMS4wLFxuICBtYXJnaW4gPSAxLjIsXG4gIG9ic2VydmUsXG4gIGZpdCxcbiAgY2xpcCxcbiAgaW50ZXJwb2xhdGVGdW5jID0gaW50ZXJwb2xhdGVGdW5jRGVmYXVsdCxcbiAgb25GaXRcbn0pIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCB7XG4gICAgY2FtZXJhLFxuICAgIHNpemUsXG4gICAgaW52YWxpZGF0ZVxuICB9ID0gdXNlVGhyZWUoKTtcbiAgY29uc3QgY29udHJvbHMgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5jb250cm9scyk7XG4gIGNvbnN0IG9uRml0UmVmID0gUmVhY3QudXNlUmVmKG9uRml0KTtcbiAgb25GaXRSZWYuY3VycmVudCA9IG9uRml0O1xuICBjb25zdCBvcmlnaW4gPSBSZWFjdC51c2VSZWYoe1xuICAgIGNhbVBvczogbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICBjYW1Sb3Q6IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCksXG4gICAgY2FtWm9vbTogMVxuICB9KTtcbiAgY29uc3QgZ29hbCA9IFJlYWN0LnVzZVJlZih7XG4gICAgY2FtUG9zOiB1bmRlZmluZWQsXG4gICAgY2FtUm90OiB1bmRlZmluZWQsXG4gICAgY2FtWm9vbTogdW5kZWZpbmVkLFxuICAgIGNhbVVwOiB1bmRlZmluZWQsXG4gICAgdGFyZ2V0OiB1bmRlZmluZWRcbiAgfSk7XG4gIGNvbnN0IGFuaW1hdGlvblN0YXRlID0gUmVhY3QudXNlUmVmKEFuaW1hdGlvblN0YXRlLk5PTkUpO1xuICBjb25zdCB0ID0gUmVhY3QudXNlUmVmKDApOyAvLyByZXByZXNlbnQgYW5pbWF0aW9uIHN0YXRlIGZyb20gMCB0byAxXG5cbiAgY29uc3QgW2JveF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuQm94MygpKTtcbiAgY29uc3QgYXBpID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gZ2V0U2l6ZSgpIHtcbiAgICAgIGNvbnN0IGJveFNpemUgPSBib3guZ2V0U2l6ZShuZXcgVEhSRUUuVmVjdG9yMygpKTtcbiAgICAgIGNvbnN0IGNlbnRlciA9IGJveC5nZXRDZW50ZXIobmV3IFRIUkVFLlZlY3RvcjMoKSk7XG4gICAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoYm94U2l6ZS54LCBib3hTaXplLnksIGJveFNpemUueik7XG4gICAgICBjb25zdCBmaXRIZWlnaHREaXN0YW5jZSA9IGlzT3J0aG9ncmFwaGljKGNhbWVyYSkgPyBtYXhTaXplICogNCA6IG1heFNpemUgLyAoMiAqIE1hdGguYXRhbihNYXRoLlBJICogY2FtZXJhLmZvdiAvIDM2MCkpO1xuICAgICAgY29uc3QgZml0V2lkdGhEaXN0YW5jZSA9IGlzT3J0aG9ncmFwaGljKGNhbWVyYSkgPyBtYXhTaXplICogNCA6IGZpdEhlaWdodERpc3RhbmNlIC8gY2FtZXJhLmFzcGVjdDtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gbWFyZ2luICogTWF0aC5tYXgoZml0SGVpZ2h0RGlzdGFuY2UsIGZpdFdpZHRoRGlzdGFuY2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYm94LFxuICAgICAgICBzaXplOiBib3hTaXplLFxuICAgICAgICBjZW50ZXIsXG4gICAgICAgIGRpc3RhbmNlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2l6ZSxcbiAgICAgIHJlZnJlc2gob2JqZWN0KSB7XG4gICAgICAgIGlmIChpc0JveDMob2JqZWN0KSkgYm94LmNvcHkob2JqZWN0KTtlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSBvYmplY3QgfHwgcmVmLmN1cnJlbnQ7XG4gICAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybiB0aGlzO1xuICAgICAgICAgIHRhcmdldC51cGRhdGVXb3JsZE1hdHJpeCh0cnVlLCB0cnVlKTtcbiAgICAgICAgICBib3guc2V0RnJvbU9iamVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChib3guaXNFbXB0eSgpKSB7XG4gICAgICAgICAgY29uc3QgbWF4ID0gY2FtZXJhLnBvc2l0aW9uLmxlbmd0aCgpIHx8IDEwO1xuICAgICAgICAgIGJveC5zZXRGcm9tQ2VudGVyQW5kU2l6ZShuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMyhtYXgsIG1heCwgbWF4KSk7XG4gICAgICAgIH1cbiAgICAgICAgb3JpZ2luLmN1cnJlbnQuY2FtUG9zLmNvcHkoY2FtZXJhLnBvc2l0aW9uKTtcbiAgICAgICAgb3JpZ2luLmN1cnJlbnQuY2FtUm90LmNvcHkoY2FtZXJhLnF1YXRlcm5pb24pO1xuICAgICAgICBpc09ydGhvZ3JhcGhpYyhjYW1lcmEpICYmIChvcmlnaW4uY3VycmVudC5jYW1ab29tID0gY2FtZXJhLnpvb20pO1xuICAgICAgICBnb2FsLmN1cnJlbnQuY2FtUG9zID0gdW5kZWZpbmVkO1xuICAgICAgICBnb2FsLmN1cnJlbnQuY2FtUm90ID0gdW5kZWZpbmVkO1xuICAgICAgICBnb2FsLmN1cnJlbnQuY2FtWm9vbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZ29hbC5jdXJyZW50LmNhbVVwID0gdW5kZWZpbmVkO1xuICAgICAgICBnb2FsLmN1cnJlbnQudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZXNldCgpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNlbnRlcixcbiAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICB9ID0gZ2V0U2l6ZSgpO1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBjYW1lcmEucG9zaXRpb24uY2xvbmUoKS5zdWIoY2VudGVyKS5ub3JtYWxpemUoKTtcbiAgICAgICAgZ29hbC5jdXJyZW50LmNhbVBvcyA9IGNlbnRlci5jbG9uZSgpLmFkZFNjYWxlZFZlY3RvcihkaXJlY3Rpb24sIGRpc3RhbmNlKTtcbiAgICAgICAgZ29hbC5jdXJyZW50LnRhcmdldCA9IGNlbnRlci5jbG9uZSgpO1xuICAgICAgICBjb25zdCBtQ2FtUm90ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5sb29rQXQoZ29hbC5jdXJyZW50LmNhbVBvcywgZ29hbC5jdXJyZW50LnRhcmdldCwgY2FtZXJhLnVwKTtcbiAgICAgICAgZ29hbC5jdXJyZW50LmNhbVJvdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVJvdGF0aW9uTWF0cml4KG1DYW1Sb3QpO1xuICAgICAgICBhbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gQW5pbWF0aW9uU3RhdGUuU1RBUlQ7XG4gICAgICAgIHQuY3VycmVudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG1vdmVUbyhwb3NpdGlvbikge1xuICAgICAgICBnb2FsLmN1cnJlbnQuY2FtUG9zID0gQXJyYXkuaXNBcnJheShwb3NpdGlvbikgPyBuZXcgVEhSRUUuVmVjdG9yMyguLi5wb3NpdGlvbikgOiBwb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICBhbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gQW5pbWF0aW9uU3RhdGUuU1RBUlQ7XG4gICAgICAgIHQuY3VycmVudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGxvb2tBdCh7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdXBcbiAgICAgIH0pIHtcbiAgICAgICAgZ29hbC5jdXJyZW50LnRhcmdldCA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IG5ldyBUSFJFRS5WZWN0b3IzKC4uLnRhcmdldCkgOiB0YXJnZXQuY2xvbmUoKTtcbiAgICAgICAgaWYgKHVwKSB7XG4gICAgICAgICAgZ29hbC5jdXJyZW50LmNhbVVwID0gQXJyYXkuaXNBcnJheSh1cCkgPyBuZXcgVEhSRUUuVmVjdG9yMyguLi51cCkgOiB1cC5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdvYWwuY3VycmVudC5jYW1VcCA9IGNhbWVyYS51cC5jbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1DYW1Sb3QgPSBuZXcgVEhSRUUuTWF0cml4NCgpLmxvb2tBdChnb2FsLmN1cnJlbnQuY2FtUG9zIHx8IGNhbWVyYS5wb3NpdGlvbiwgZ29hbC5jdXJyZW50LnRhcmdldCwgZ29hbC5jdXJyZW50LmNhbVVwKTtcbiAgICAgICAgZ29hbC5jdXJyZW50LmNhbVJvdCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCkuc2V0RnJvbVJvdGF0aW9uTWF0cml4KG1DYW1Sb3QpO1xuICAgICAgICBhbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gQW5pbWF0aW9uU3RhdGUuU1RBUlQ7XG4gICAgICAgIHQuY3VycmVudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIG1vdmVUbyBhbmQgbG9va0F0IGluc3RlYWRcbiAgICAgICAqL1xuICAgICAgdG8oe1xuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0XG4gICAgICB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVUbyhwb3NpdGlvbikubG9va0F0KHtcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZml0KCkge1xuICAgICAgICBpZiAoIWlzT3J0aG9ncmFwaGljKGNhbWVyYSkpIHtcbiAgICAgICAgICAvLyBGb3Igbm9uLW9ydGhvZ3JhcGhpYyBjYW1lcmFzLCBmaXQgc2hvdWxkIGJlaGF2ZSBleGFjdGx5IGxpa2UgcmVzZXRcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG9ydGhvZ3JhcGhpYyBjYW1lcmFzLCBmaXQgc2hvdWxkIG9ubHkgbW9kaWZ5IHRoZSB6b29tIHZhbHVlXG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSAwLFxuICAgICAgICAgIG1heFdpZHRoID0gMDtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbbmV3IFRIUkVFLlZlY3RvcjMoYm94Lm1pbi54LCBib3gubWluLnksIGJveC5taW4ueiksIG5ldyBUSFJFRS5WZWN0b3IzKGJveC5taW4ueCwgYm94Lm1heC55LCBib3gubWluLnopLCBuZXcgVEhSRUUuVmVjdG9yMyhib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1heC56KSwgbmV3IFRIUkVFLlZlY3RvcjMoYm94Lm1pbi54LCBib3gubWF4LnksIGJveC5tYXgueiksIG5ldyBUSFJFRS5WZWN0b3IzKGJveC5tYXgueCwgYm94Lm1heC55LCBib3gubWF4LnopLCBuZXcgVEhSRUUuVmVjdG9yMyhib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1pbi56KSwgbmV3IFRIUkVFLlZlY3RvcjMoYm94Lm1heC54LCBib3gubWluLnksIGJveC5tYXgueiksIG5ldyBUSFJFRS5WZWN0b3IzKGJveC5tYXgueCwgYm94Lm1pbi55LCBib3gubWluLnopXTtcblxuICAgICAgICAvLyBUcmFuc2Zvcm0gdGhlIGNlbnRlciBhbmQgZWFjaCBjb3JuZXIgdG8gY2FtZXJhIHNwYWNlXG4gICAgICAgIGNvbnN0IHBvcyA9IGdvYWwuY3VycmVudC5jYW1Qb3MgfHwgY2FtZXJhLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnb2FsLmN1cnJlbnQudGFyZ2V0IHx8IChjb250cm9scyA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbHMudGFyZ2V0KTtcbiAgICAgICAgY29uc3QgdXAgPSBnb2FsLmN1cnJlbnQuY2FtVXAgfHwgY2FtZXJhLnVwO1xuICAgICAgICBjb25zdCBtQ2FtV0ludiA9IHRhcmdldCA/IG5ldyBUSFJFRS5NYXRyaXg0KCkubG9va0F0KHBvcywgdGFyZ2V0LCB1cCkuc2V0UG9zaXRpb24ocG9zKS5pbnZlcnQoKSA6IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2U7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2ZXJ0aWNlcykge1xuICAgICAgICAgIHYuYXBwbHlNYXRyaXg0KG1DYW1XSW52KTtcbiAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIE1hdGguYWJzKHYueSkpO1xuICAgICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIE1hdGguYWJzKHYueCkpO1xuICAgICAgICB9XG4gICAgICAgIG1heEhlaWdodCAqPSAyO1xuICAgICAgICBtYXhXaWR0aCAqPSAyO1xuICAgICAgICBjb25zdCB6b29tRm9ySGVpZ2h0ID0gKGNhbWVyYS50b3AgLSBjYW1lcmEuYm90dG9tKSAvIG1heEhlaWdodDtcbiAgICAgICAgY29uc3Qgem9vbUZvcldpZHRoID0gKGNhbWVyYS5yaWdodCAtIGNhbWVyYS5sZWZ0KSAvIG1heFdpZHRoO1xuICAgICAgICBnb2FsLmN1cnJlbnQuY2FtWm9vbSA9IE1hdGgubWluKHpvb21Gb3JIZWlnaHQsIHpvb21Gb3JXaWR0aCkgLyBtYXJnaW47XG4gICAgICAgIGFuaW1hdGlvblN0YXRlLmN1cnJlbnQgPSBBbmltYXRpb25TdGF0ZS5TVEFSVDtcbiAgICAgICAgdC5jdXJyZW50ID0gMDtcbiAgICAgICAgb25GaXRSZWYuY3VycmVudCAmJiBvbkZpdFJlZi5jdXJyZW50KHRoaXMuZ2V0U2l6ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgY2xpcCgpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgIH0gPSBnZXRTaXplKCk7XG4gICAgICAgIGNhbWVyYS5uZWFyID0gZGlzdGFuY2UgLyAxMDA7XG4gICAgICAgIGNhbWVyYS5mYXIgPSBkaXN0YW5jZSAqIDEwMDtcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgaWYgKGNvbnRyb2xzKSB7XG4gICAgICAgICAgY29udHJvbHMubWF4RGlzdGFuY2UgPSBkaXN0YW5jZSAqIDEwO1xuICAgICAgICAgIGNvbnRyb2xzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGludmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2JveCwgY2FtZXJhLCBjb250cm9scywgbWFyZ2luLCBpbnZhbGlkYXRlXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnRyb2xzKSB7XG4gICAgICAvLyBUcnkgdG8gcHJldmVudCBkcmFnIGhpamFja2luZ1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmIChjb250cm9scyAmJiBnb2FsLmN1cnJlbnQudGFyZ2V0ICYmIGFuaW1hdGlvblN0YXRlLmN1cnJlbnQgIT09IEFuaW1hdGlvblN0YXRlLk5PTkUpIHtcbiAgICAgICAgICBjb25zdCBmcm9udCA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc2V0RnJvbU1hdHJpeENvbHVtbihjYW1lcmEubWF0cml4LCAyKTtcbiAgICAgICAgICBjb25zdCBkMCA9IG9yaWdpbi5jdXJyZW50LmNhbVBvcy5kaXN0YW5jZVRvKGNvbnRyb2xzLnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgZDEgPSAoZ29hbC5jdXJyZW50LmNhbVBvcyB8fCBvcmlnaW4uY3VycmVudC5jYW1Qb3MpLmRpc3RhbmNlVG8oZ29hbC5jdXJyZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgZCA9ICgxIC0gdC5jdXJyZW50KSAqIGQwICsgdC5jdXJyZW50ICogZDE7XG4gICAgICAgICAgY29udHJvbHMudGFyZ2V0LmNvcHkoY2FtZXJhLnBvc2l0aW9uKS5hZGRTY2FsZWRWZWN0b3IoZnJvbnQsIC1kKTtcbiAgICAgICAgICBjb250cm9scy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gQW5pbWF0aW9uU3RhdGUuTk9ORTtcbiAgICAgIH07XG4gICAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdzdGFydCcsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiAoKSA9PiBjb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGFydCcsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0sIFtjb250cm9sc10pO1xuXG4gIC8vIFNjYWxlIHBvaW50ZXIgb24gd2luZG93IHJlc2l6ZVxuICBjb25zdCBjb3VudCA9IFJlYWN0LnVzZVJlZigwKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAob2JzZXJ2ZSB8fCBjb3VudC5jdXJyZW50KysgPT09IDApIHtcbiAgICAgIGFwaS5yZWZyZXNoKCk7XG4gICAgICBpZiAoZml0KSBhcGkucmVzZXQoKS5maXQoKTtcbiAgICAgIGlmIChjbGlwKSBhcGkuY2xpcCgpO1xuICAgIH1cbiAgfSwgW3NpemUsIGNsaXAsIGZpdCwgb2JzZXJ2ZSwgY2FtZXJhLCBjb250cm9sc10pO1xuICB1c2VGcmFtZSgoc3RhdGUsIGRlbHRhKSA9PiB7XG4gICAgLy8gVGhpcyBbYWRkaXRpb25hbCBhbmltYXRpb24gc3RlcCBTVEFSVF0gaXMgbmVlZGVkIHRvIGd1YXJhbnRlZSB0aGF0IGRlbHRhIHVzZWQgaW4gYW5pbWF0aW9uIGlzbid0IGFic3VyZGx5IGhpZ2ggKDItMyBzZWNvbmRzKSB3aGljaCBpcyBhY3R1YWxseSBwb3NzaWJsZSBpZiByZW5kZXJpbmcgaGFwcGVucyBvbiBkZW1hbmQuLi5cbiAgICBpZiAoYW5pbWF0aW9uU3RhdGUuY3VycmVudCA9PT0gQW5pbWF0aW9uU3RhdGUuU1RBUlQpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlLmN1cnJlbnQgPSBBbmltYXRpb25TdGF0ZS5BQ1RJVkU7XG4gICAgICBpbnZhbGlkYXRlKCk7XG4gICAgfSBlbHNlIGlmIChhbmltYXRpb25TdGF0ZS5jdXJyZW50ID09PSBBbmltYXRpb25TdGF0ZS5BQ1RJVkUpIHtcbiAgICAgIHQuY3VycmVudCArPSBkZWx0YSAvIG1heER1cmF0aW9uO1xuICAgICAgaWYgKHQuY3VycmVudCA+PSAxKSB7XG4gICAgICAgIGdvYWwuY3VycmVudC5jYW1Qb3MgJiYgY2FtZXJhLnBvc2l0aW9uLmNvcHkoZ29hbC5jdXJyZW50LmNhbVBvcyk7XG4gICAgICAgIGdvYWwuY3VycmVudC5jYW1Sb3QgJiYgY2FtZXJhLnF1YXRlcm5pb24uY29weShnb2FsLmN1cnJlbnQuY2FtUm90KTtcbiAgICAgICAgZ29hbC5jdXJyZW50LmNhbVVwICYmIGNhbWVyYS51cC5jb3B5KGdvYWwuY3VycmVudC5jYW1VcCk7XG4gICAgICAgIGdvYWwuY3VycmVudC5jYW1ab29tICYmIGlzT3J0aG9ncmFwaGljKGNhbWVyYSkgJiYgKGNhbWVyYS56b29tID0gZ29hbC5jdXJyZW50LmNhbVpvb20pO1xuICAgICAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgaWYgKGNvbnRyb2xzICYmIGdvYWwuY3VycmVudC50YXJnZXQpIHtcbiAgICAgICAgICBjb250cm9scy50YXJnZXQuY29weShnb2FsLmN1cnJlbnQudGFyZ2V0KTtcbiAgICAgICAgICBjb250cm9scy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gQW5pbWF0aW9uU3RhdGUuTk9ORTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGsgPSBpbnRlcnBvbGF0ZUZ1bmModC5jdXJyZW50KTtcbiAgICAgICAgZ29hbC5jdXJyZW50LmNhbVBvcyAmJiBjYW1lcmEucG9zaXRpb24ubGVycFZlY3RvcnMob3JpZ2luLmN1cnJlbnQuY2FtUG9zLCBnb2FsLmN1cnJlbnQuY2FtUG9zLCBrKTtcbiAgICAgICAgZ29hbC5jdXJyZW50LmNhbVJvdCAmJiBjYW1lcmEucXVhdGVybmlvbi5zbGVycFF1YXRlcm5pb25zKG9yaWdpbi5jdXJyZW50LmNhbVJvdCwgZ29hbC5jdXJyZW50LmNhbVJvdCwgayk7XG4gICAgICAgIGdvYWwuY3VycmVudC5jYW1VcCAmJiBjYW1lcmEudXAuc2V0KDAsIDEsIDApLmFwcGx5UXVhdGVybmlvbihjYW1lcmEucXVhdGVybmlvbik7XG4gICAgICAgIGdvYWwuY3VycmVudC5jYW1ab29tICYmIGlzT3J0aG9ncmFwaGljKGNhbWVyYSkgJiYgKGNhbWVyYS56b29tID0gKDEgLSBrKSAqIG9yaWdpbi5jdXJyZW50LmNhbVpvb20gKyBrICogZ29hbC5jdXJyZW50LmNhbVpvb20pO1xuICAgICAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGUoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCB7XG4gICAgcmVmOiByZWZcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcGlcbiAgfSwgY2hpbGRyZW4pKTtcbn1cbmZ1bmN0aW9uIHVzZUJvdW5kcygpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCk7XG59XG5cbmV4cG9ydCB7IEJvdW5kcywgdXNlQm91bmRzIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJUSFJFRSIsInVzZVRocmVlIiwidXNlRnJhbWUiLCJBbmltYXRpb25TdGF0ZSIsImlzT3J0aG9ncmFwaGljIiwiZGVmIiwiaXNPcnRob2dyYXBoaWNDYW1lcmEiLCJpc0JveDMiLCJpbnRlcnBvbGF0ZUZ1bmNEZWZhdWx0IiwidCIsIk1hdGgiLCJleHAiLCJjb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsIkJvdW5kcyIsImNoaWxkcmVuIiwibWF4RHVyYXRpb24iLCJtYXJnaW4iLCJvYnNlcnZlIiwiZml0IiwiY2xpcCIsImludGVycG9sYXRlRnVuYyIsIm9uRml0IiwicmVmIiwidXNlUmVmIiwiY2FtZXJhIiwic2l6ZSIsImludmFsaWRhdGUiLCJjb250cm9scyIsInN0YXRlIiwib25GaXRSZWYiLCJjdXJyZW50Iiwib3JpZ2luIiwiY2FtUG9zIiwiVmVjdG9yMyIsImNhbVJvdCIsIlF1YXRlcm5pb24iLCJjYW1ab29tIiwiZ29hbCIsInVuZGVmaW5lZCIsImNhbVVwIiwidGFyZ2V0IiwiYW5pbWF0aW9uU3RhdGUiLCJOT05FIiwiYm94IiwidXNlU3RhdGUiLCJCb3gzIiwiYXBpIiwidXNlTWVtbyIsImdldFNpemUiLCJib3hTaXplIiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwibWF4U2l6ZSIsIm1heCIsIngiLCJ5IiwieiIsImZpdEhlaWdodERpc3RhbmNlIiwiYXRhbiIsIlBJIiwiZm92IiwiZml0V2lkdGhEaXN0YW5jZSIsImFzcGVjdCIsImRpc3RhbmNlIiwicmVmcmVzaCIsIm9iamVjdCIsImNvcHkiLCJ1cGRhdGVXb3JsZE1hdHJpeCIsInNldEZyb21PYmplY3QiLCJpc0VtcHR5IiwicG9zaXRpb24iLCJsZW5ndGgiLCJzZXRGcm9tQ2VudGVyQW5kU2l6ZSIsInF1YXRlcm5pb24iLCJ6b29tIiwicmVzZXQiLCJkaXJlY3Rpb24iLCJjbG9uZSIsInN1YiIsIm5vcm1hbGl6ZSIsImFkZFNjYWxlZFZlY3RvciIsIm1DYW1Sb3QiLCJNYXRyaXg0IiwibG9va0F0IiwidXAiLCJzZXRGcm9tUm90YXRpb25NYXRyaXgiLCJTVEFSVCIsIm1vdmVUbyIsIkFycmF5IiwiaXNBcnJheSIsInRvIiwibWF4SGVpZ2h0IiwibWF4V2lkdGgiLCJ2ZXJ0aWNlcyIsIm1pbiIsInBvcyIsIm1DYW1XSW52Iiwic2V0UG9zaXRpb24iLCJpbnZlcnQiLCJtYXRyaXhXb3JsZEludmVyc2UiLCJ2IiwiYXBwbHlNYXRyaXg0IiwiYWJzIiwiem9vbUZvckhlaWdodCIsInRvcCIsImJvdHRvbSIsInpvb21Gb3JXaWR0aCIsInJpZ2h0IiwibGVmdCIsIm5lYXIiLCJmYXIiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwibWF4RGlzdGFuY2UiLCJ1cGRhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJjYWxsYmFjayIsImZyb250Iiwic2V0RnJvbU1hdHJpeENvbHVtbiIsIm1hdHJpeCIsImQwIiwiZGlzdGFuY2VUbyIsImQxIiwiZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY291bnQiLCJkZWx0YSIsIkFDVElWRSIsInVwZGF0ZU1hdHJpeFdvcmxkIiwiayIsImxlcnBWZWN0b3JzIiwic2xlcnBRdWF0ZXJuaW9ucyIsInNldCIsImFwcGx5UXVhdGVybmlvbiIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwidXNlQm91bmRzIiwidXNlQ29udGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Bounds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Center.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Center.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Center: () => (/* binding */ Center)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nconst Center = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Center({ children, disable, disableX, disableY, disableZ, left, right, top, bottom, front, back, onCentered, precise = true, cacheKey = 0, ...props }, fRef) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const outer = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const inner = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        outer.current.matrixWorld.identity();\n        const box3 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3().setFromObject(inner.current, precise);\n        const center = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3();\n        const sphere = new three__WEBPACK_IMPORTED_MODULE_2__.Sphere();\n        const width = box3.max.x - box3.min.x;\n        const height = box3.max.y - box3.min.y;\n        const depth = box3.max.z - box3.min.z;\n        box3.getCenter(center);\n        box3.getBoundingSphere(sphere);\n        const vAlign = top ? height / 2 : bottom ? -height / 2 : 0;\n        const hAlign = left ? -width / 2 : right ? width / 2 : 0;\n        const dAlign = front ? depth / 2 : back ? -depth / 2 : 0;\n        outer.current.position.set(disable || disableX ? 0 : -center.x + hAlign, disable || disableY ? 0 : -center.y + vAlign, disable || disableZ ? 0 : -center.z + dAlign);\n        // Only fire onCentered if the bounding box has changed\n        if (typeof onCentered !== \"undefined\") {\n            onCentered({\n                parent: ref.current.parent,\n                container: ref.current,\n                width,\n                height,\n                depth,\n                boundingBox: box3,\n                boundingSphere: sphere,\n                center: center,\n                verticalAlignment: vAlign,\n                horizontalAlignment: hAlign,\n                depthAlignment: dAlign\n            });\n        }\n    }, [\n        cacheKey,\n        onCentered,\n        top,\n        left,\n        front,\n        disable,\n        disableX,\n        disableY,\n        disableZ,\n        precise,\n        right,\n        bottom,\n        back\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fRef, ()=>ref.current, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: ref\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        ref: outer\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        ref: inner\n    }, children)));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9DZW50ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMEQ7QUFDWjtBQUNmO0FBRS9CLE1BQU1LLFNBQVMsYUFBYSxpQkFBRUQsNkNBQWdCLENBQUMsU0FBU0MsT0FBTyxFQUM3REUsUUFBUSxFQUNSQyxPQUFPLEVBQ1BDLFFBQVEsRUFDUkMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLElBQUksRUFDSkMsS0FBSyxFQUNMQyxHQUFHLEVBQ0hDLE1BQU0sRUFDTkMsS0FBSyxFQUNMQyxJQUFJLEVBQ0pDLFVBQVUsRUFDVkMsVUFBVSxJQUFJLEVBQ2RDLFdBQVcsQ0FBQyxFQUNaLEdBQUdDLE9BQ0osRUFBRUMsSUFBSTtJQUNMLE1BQU1DLE1BQU1uQix5Q0FBWSxDQUFDO0lBQ3pCLE1BQU1xQixRQUFRckIseUNBQVksQ0FBQztJQUMzQixNQUFNc0IsUUFBUXRCLHlDQUFZLENBQUM7SUFDM0JBLGtEQUFxQixDQUFDO1FBQ3BCcUIsTUFBTUcsT0FBTyxDQUFDQyxXQUFXLENBQUNDLFFBQVE7UUFDbEMsTUFBTUMsT0FBTyxJQUFJOUIsdUNBQUlBLEdBQUcrQixhQUFhLENBQUNOLE1BQU1FLE9BQU8sRUFBRVQ7UUFDckQsTUFBTWMsU0FBUyxJQUFJL0IsMENBQU9BO1FBQzFCLE1BQU1nQyxTQUFTLElBQUkvQix5Q0FBTUE7UUFDekIsTUFBTWdDLFFBQVFKLEtBQUtLLEdBQUcsQ0FBQ0MsQ0FBQyxHQUFHTixLQUFLTyxHQUFHLENBQUNELENBQUM7UUFDckMsTUFBTUUsU0FBU1IsS0FBS0ssR0FBRyxDQUFDSSxDQUFDLEdBQUdULEtBQUtPLEdBQUcsQ0FBQ0UsQ0FBQztRQUN0QyxNQUFNQyxRQUFRVixLQUFLSyxHQUFHLENBQUNNLENBQUMsR0FBR1gsS0FBS08sR0FBRyxDQUFDSSxDQUFDO1FBQ3JDWCxLQUFLWSxTQUFTLENBQUNWO1FBQ2ZGLEtBQUthLGlCQUFpQixDQUFDVjtRQUN2QixNQUFNVyxTQUFTL0IsTUFBTXlCLFNBQVMsSUFBSXhCLFNBQVMsQ0FBQ3dCLFNBQVMsSUFBSTtRQUN6RCxNQUFNTyxTQUFTbEMsT0FBTyxDQUFDdUIsUUFBUSxJQUFJdEIsUUFBUXNCLFFBQVEsSUFBSTtRQUN2RCxNQUFNWSxTQUFTL0IsUUFBUXlCLFFBQVEsSUFBSXhCLE9BQU8sQ0FBQ3dCLFFBQVEsSUFBSTtRQUN2RGhCLE1BQU1HLE9BQU8sQ0FBQ29CLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDekMsV0FBV0MsV0FBVyxJQUFJLENBQUN3QixPQUFPSSxDQUFDLEdBQUdTLFFBQVF0QyxXQUFXRSxXQUFXLElBQUksQ0FBQ3VCLE9BQU9PLENBQUMsR0FBR0ssUUFBUXJDLFdBQVdHLFdBQVcsSUFBSSxDQUFDc0IsT0FBT1MsQ0FBQyxHQUFHSztRQUU3Six1REFBdUQ7UUFDdkQsSUFBSSxPQUFPN0IsZUFBZSxhQUFhO1lBQ3JDQSxXQUFXO2dCQUNUZ0MsUUFBUTNCLElBQUlLLE9BQU8sQ0FBQ3NCLE1BQU07Z0JBQzFCQyxXQUFXNUIsSUFBSUssT0FBTztnQkFDdEJPO2dCQUNBSTtnQkFDQUU7Z0JBQ0FXLGFBQWFyQjtnQkFDYnNCLGdCQUFnQm5CO2dCQUNoQkQsUUFBUUE7Z0JBQ1JxQixtQkFBbUJUO2dCQUNuQlUscUJBQXFCVDtnQkFDckJVLGdCQUFnQlQ7WUFDbEI7UUFDRjtJQUNGLEdBQUc7UUFBQzNCO1FBQVVGO1FBQVlKO1FBQUtGO1FBQU1JO1FBQU9SO1FBQVNDO1FBQVVDO1FBQVVDO1FBQVVRO1FBQVNOO1FBQU9FO1FBQVFFO0tBQUs7SUFDaEhiLHNEQUF5QixDQUFDa0IsTUFBTSxJQUFNQyxJQUFJSyxPQUFPLEVBQUUsRUFBRTtJQUNyRCxPQUFPLFdBQVcsR0FBRXhCLGdEQUFtQixDQUFDLFNBQVNKLDhFQUFRQSxDQUFDO1FBQ3hEdUIsS0FBS0E7SUFDUCxHQUFHRixRQUFRLFdBQVcsR0FBRWpCLGdEQUFtQixDQUFDLFNBQVM7UUFDbkRtQixLQUFLRTtJQUNQLEdBQUcsV0FBVyxHQUFFckIsZ0RBQW1CLENBQUMsU0FBUztRQUMzQ21CLEtBQUtHO0lBQ1AsR0FBR25CO0FBQ0w7QUFFa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvQ2VudGVyLmpzP2JjNjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHsgQm94MywgVmVjdG9yMywgU3BoZXJlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBDZW50ZXIgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENlbnRlcih7XG4gIGNoaWxkcmVuLFxuICBkaXNhYmxlLFxuICBkaXNhYmxlWCxcbiAgZGlzYWJsZVksXG4gIGRpc2FibGVaLFxuICBsZWZ0LFxuICByaWdodCxcbiAgdG9wLFxuICBib3R0b20sXG4gIGZyb250LFxuICBiYWNrLFxuICBvbkNlbnRlcmVkLFxuICBwcmVjaXNlID0gdHJ1ZSxcbiAgY2FjaGVLZXkgPSAwLFxuICAuLi5wcm9wc1xufSwgZlJlZikge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG91dGVyID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBpbm5lciA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBvdXRlci5jdXJyZW50Lm1hdHJpeFdvcmxkLmlkZW50aXR5KCk7XG4gICAgY29uc3QgYm94MyA9IG5ldyBCb3gzKCkuc2V0RnJvbU9iamVjdChpbm5lci5jdXJyZW50LCBwcmVjaXNlKTtcbiAgICBjb25zdCBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuICAgIGNvbnN0IHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcbiAgICBjb25zdCB3aWR0aCA9IGJveDMubWF4LnggLSBib3gzLm1pbi54O1xuICAgIGNvbnN0IGhlaWdodCA9IGJveDMubWF4LnkgLSBib3gzLm1pbi55O1xuICAgIGNvbnN0IGRlcHRoID0gYm94My5tYXgueiAtIGJveDMubWluLno7XG4gICAgYm94My5nZXRDZW50ZXIoY2VudGVyKTtcbiAgICBib3gzLmdldEJvdW5kaW5nU3BoZXJlKHNwaGVyZSk7XG4gICAgY29uc3QgdkFsaWduID0gdG9wID8gaGVpZ2h0IC8gMiA6IGJvdHRvbSA/IC1oZWlnaHQgLyAyIDogMDtcbiAgICBjb25zdCBoQWxpZ24gPSBsZWZ0ID8gLXdpZHRoIC8gMiA6IHJpZ2h0ID8gd2lkdGggLyAyIDogMDtcbiAgICBjb25zdCBkQWxpZ24gPSBmcm9udCA/IGRlcHRoIC8gMiA6IGJhY2sgPyAtZGVwdGggLyAyIDogMDtcbiAgICBvdXRlci5jdXJyZW50LnBvc2l0aW9uLnNldChkaXNhYmxlIHx8IGRpc2FibGVYID8gMCA6IC1jZW50ZXIueCArIGhBbGlnbiwgZGlzYWJsZSB8fCBkaXNhYmxlWSA/IDAgOiAtY2VudGVyLnkgKyB2QWxpZ24sIGRpc2FibGUgfHwgZGlzYWJsZVogPyAwIDogLWNlbnRlci56ICsgZEFsaWduKTtcblxuICAgIC8vIE9ubHkgZmlyZSBvbkNlbnRlcmVkIGlmIHRoZSBib3VuZGluZyBib3ggaGFzIGNoYW5nZWRcbiAgICBpZiAodHlwZW9mIG9uQ2VudGVyZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvbkNlbnRlcmVkKHtcbiAgICAgICAgcGFyZW50OiByZWYuY3VycmVudC5wYXJlbnQsXG4gICAgICAgIGNvbnRhaW5lcjogcmVmLmN1cnJlbnQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGRlcHRoLFxuICAgICAgICBib3VuZGluZ0JveDogYm94MyxcbiAgICAgICAgYm91bmRpbmdTcGhlcmU6IHNwaGVyZSxcbiAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgIHZlcnRpY2FsQWxpZ25tZW50OiB2QWxpZ24sXG4gICAgICAgIGhvcml6b250YWxBbGlnbm1lbnQ6IGhBbGlnbixcbiAgICAgICAgZGVwdGhBbGlnbm1lbnQ6IGRBbGlnblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbY2FjaGVLZXksIG9uQ2VudGVyZWQsIHRvcCwgbGVmdCwgZnJvbnQsIGRpc2FibGUsIGRpc2FibGVYLCBkaXNhYmxlWSwgZGlzYWJsZVosIHByZWNpc2UsIHJpZ2h0LCBib3R0b20sIGJhY2tdKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmUmVmLCAoKSA9PiByZWYuY3VycmVudCwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWZcbiAgfSwgcHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHtcbiAgICByZWY6IG91dGVyXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwge1xuICAgIHJlZjogaW5uZXJcbiAgfSwgY2hpbGRyZW4pKSk7XG59KTtcblxuZXhwb3J0IHsgQ2VudGVyIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJCb3gzIiwiVmVjdG9yMyIsIlNwaGVyZSIsIlJlYWN0IiwiQ2VudGVyIiwiZm9yd2FyZFJlZiIsImNoaWxkcmVuIiwiZGlzYWJsZSIsImRpc2FibGVYIiwiZGlzYWJsZVkiLCJkaXNhYmxlWiIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImZyb250IiwiYmFjayIsIm9uQ2VudGVyZWQiLCJwcmVjaXNlIiwiY2FjaGVLZXkiLCJwcm9wcyIsImZSZWYiLCJyZWYiLCJ1c2VSZWYiLCJvdXRlciIsImlubmVyIiwidXNlTGF5b3V0RWZmZWN0IiwiY3VycmVudCIsIm1hdHJpeFdvcmxkIiwiaWRlbnRpdHkiLCJib3gzIiwic2V0RnJvbU9iamVjdCIsImNlbnRlciIsInNwaGVyZSIsIndpZHRoIiwibWF4IiwieCIsIm1pbiIsImhlaWdodCIsInkiLCJkZXB0aCIsInoiLCJnZXRDZW50ZXIiLCJnZXRCb3VuZGluZ1NwaGVyZSIsInZBbGlnbiIsImhBbGlnbiIsImRBbGlnbiIsInBvc2l0aW9uIiwic2V0IiwicGFyZW50IiwiY29udGFpbmVyIiwiYm91bmRpbmdCb3giLCJib3VuZGluZ1NwaGVyZSIsInZlcnRpY2FsQWxpZ25tZW50IiwiaG9yaXpvbnRhbEFsaWdubWVudCIsImRlcHRoQWxpZ25tZW50IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUVsZW1lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Center.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/ContactShadows.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/ContactShadows.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContactShadows: () => (/* binding */ ContactShadows)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/shaders/VerticalBlurShader.js\");\n\n\n\n\n\nconst ContactShadows = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ scale = 10, frames = Infinity, opacity = 1, width = 1, height = 1, blur = 1, near = 0, far = 10, resolution = 512, smooth = true, color = \"#000000\", depthWrite = false, renderOrder, ...props }, fref)=>{\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const scene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)((state)=>state.scene);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)((state)=>state.gl);\n    const shadowCamera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    width = width * (Array.isArray(scale) ? scale[0] : scale || 1);\n    height = height * (Array.isArray(scale) ? scale[1] : scale || 1);\n    const [renderTarget, planeGeometry, depthMaterial, blurPlane, horizontalBlurMaterial, verticalBlurMaterial, renderTargetBlur] = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(resolution, resolution);\n        const renderTargetBlur = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(resolution, resolution);\n        renderTargetBlur.texture.generateMipmaps = renderTarget.texture.generateMipmaps = false;\n        const planeGeometry = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(width, height).rotateX(Math.PI / 2);\n        const blurPlane = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(planeGeometry);\n        const depthMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.MeshDepthMaterial();\n        depthMaterial.depthTest = depthMaterial.depthWrite = false;\n        depthMaterial.onBeforeCompile = (shader)=>{\n            shader.uniforms = {\n                ...shader.uniforms,\n                ucolor: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_3__.Color(color)\n                }\n            };\n            shader.fragmentShader = shader.fragmentShader.replace(`void main() {`, //\n            `uniform vec3 ucolor;\n           void main() {\n          `);\n            shader.fragmentShader = shader.fragmentShader.replace(\"vec4( vec3( 1.0 - fragCoordZ ), opacity );\", // Colorize the shadow, multiply by the falloff so that the center can remain darker\n            \"vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );\");\n        };\n        const horizontalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial(three_stdlib__WEBPACK_IMPORTED_MODULE_4__.HorizontalBlurShader);\n        const verticalBlurMaterial = new three__WEBPACK_IMPORTED_MODULE_3__.ShaderMaterial(three_stdlib__WEBPACK_IMPORTED_MODULE_5__.VerticalBlurShader);\n        verticalBlurMaterial.depthTest = horizontalBlurMaterial.depthTest = false;\n        return [\n            renderTarget,\n            planeGeometry,\n            depthMaterial,\n            blurPlane,\n            horizontalBlurMaterial,\n            verticalBlurMaterial,\n            renderTargetBlur\n        ];\n    }, [\n        resolution,\n        width,\n        height,\n        scale,\n        color\n    ]);\n    const blurShadows = (blur)=>{\n        blurPlane.visible = true;\n        blurPlane.material = horizontalBlurMaterial;\n        horizontalBlurMaterial.uniforms.tDiffuse.value = renderTarget.texture;\n        horizontalBlurMaterial.uniforms.h.value = blur * 1 / 256;\n        gl.setRenderTarget(renderTargetBlur);\n        gl.render(blurPlane, shadowCamera.current);\n        blurPlane.material = verticalBlurMaterial;\n        verticalBlurMaterial.uniforms.tDiffuse.value = renderTargetBlur.texture;\n        verticalBlurMaterial.uniforms.v.value = blur * 1 / 256;\n        gl.setRenderTarget(renderTarget);\n        gl.render(blurPlane, shadowCamera.current);\n        blurPlane.visible = false;\n    };\n    let count = 0;\n    let initialBackground;\n    let initialOverrideMaterial;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F)(()=>{\n        if (shadowCamera.current && (frames === Infinity || count < frames)) {\n            count++;\n            initialBackground = scene.background;\n            initialOverrideMaterial = scene.overrideMaterial;\n            ref.current.visible = false;\n            scene.background = null;\n            scene.overrideMaterial = depthMaterial;\n            gl.setRenderTarget(renderTarget);\n            gl.render(scene, shadowCamera.current);\n            blurShadows(blur);\n            if (smooth) blurShadows(blur * 0.4);\n            gl.setRenderTarget(null);\n            ref.current.visible = true;\n            scene.overrideMaterial = initialOverrideMaterial;\n            scene.background = initialBackground;\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, ()=>ref.current, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        \"rotation-x\": Math.PI / 2\n    }, props, {\n        ref: ref\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", {\n        renderOrder: renderOrder,\n        geometry: planeGeometry,\n        scale: [\n            1,\n            -1,\n            1\n        ],\n        rotation: [\n            -Math.PI / 2,\n            0,\n            0\n        ]\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshBasicMaterial\", {\n        transparent: true,\n        map: renderTarget.texture,\n        opacity: opacity,\n        depthWrite: depthWrite\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"orthographicCamera\", {\n        ref: shadowCamera,\n        args: [\n            -width / 2,\n            width / 2,\n            height / 2,\n            -height / 2,\n            near,\n            far\n        ]\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Db250YWN0U2hhZG93cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNBO0FBQ3lCO0FBQ2dCO0FBRXhFLE1BQU1PLGlCQUFpQixhQUFhLGlCQUFFTiw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3REUSxRQUFRLEVBQUUsRUFDVkMsU0FBU0MsUUFBUSxFQUNqQkMsVUFBVSxDQUFDLEVBQ1hDLFFBQVEsQ0FBQyxFQUNUQyxTQUFTLENBQUMsRUFDVkMsT0FBTyxDQUFDLEVBQ1JDLE9BQU8sQ0FBQyxFQUNSQyxNQUFNLEVBQUUsRUFDUkMsYUFBYSxHQUFHLEVBQ2hCQyxTQUFTLElBQUksRUFDYkMsUUFBUSxTQUFTLEVBQ2pCQyxhQUFhLEtBQUssRUFDbEJDLFdBQVcsRUFDWCxHQUFHQyxPQUNKLEVBQUVDO0lBQ0QsTUFBTUMsTUFBTXhCLHlDQUFZLENBQUM7SUFDekIsTUFBTTBCLFFBQVF4QixxREFBUUEsQ0FBQ3lCLENBQUFBLFFBQVNBLE1BQU1ELEtBQUs7SUFDM0MsTUFBTUUsS0FBSzFCLHFEQUFRQSxDQUFDeUIsQ0FBQUEsUUFBU0EsTUFBTUMsRUFBRTtJQUNyQyxNQUFNQyxlQUFlN0IseUNBQVksQ0FBQztJQUNsQ1ksUUFBUUEsUUFBU2tCLENBQUFBLE1BQU1DLE9BQU8sQ0FBQ3ZCLFNBQVNBLEtBQUssQ0FBQyxFQUFFLEdBQUdBLFNBQVM7SUFDNURLLFNBQVNBLFNBQVVpQixDQUFBQSxNQUFNQyxPQUFPLENBQUN2QixTQUFTQSxLQUFLLENBQUMsRUFBRSxHQUFHQSxTQUFTO0lBQzlELE1BQU0sQ0FBQ3dCLGNBQWNDLGVBQWVDLGVBQWVDLFdBQVdDLHdCQUF3QkMsc0JBQXNCQyxpQkFBaUIsR0FBR3RDLDBDQUFhLENBQUM7UUFDNUksTUFBTWdDLGVBQWUsSUFBSS9CLG9EQUF1QixDQUFDZ0IsWUFBWUE7UUFDN0QsTUFBTXFCLG1CQUFtQixJQUFJckMsb0RBQXVC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dEJsQyxNQUFNOEMsZ0JBQWdCLEdBQUdGO1lBQ3pCNUMsTUFBTTZDLFVBQVUsR0FBR0Y7UUFDckI7SUFDRjtJQUNBckUsc0RBQXlCLENBQUN1QixNQUFNLElBQU1DLElBQUkwQyxPQUFPLEVBQUUsRUFBRTtJQUNyRCxPQUFPLFdBQVcsR0FBRWxFLGdEQUFtQixDQUFDLFNBQVNELDhFQUFRQSxDQUFDO1FBQ3hELGNBQWM4QyxLQUFLQyxFQUFFLEdBQUc7SUFDMUIsR0FBR3hCLE9BQU87UUFDUkUsS0FBS0E7SUFDUCxJQUFJLFdBQVcsR0FBRXhCLGdEQUFtQixDQUFDLFFBQVE7UUFDM0NxQixhQUFhQTtRQUNic0QsVUFBVTFDO1FBQ1Z6QixPQUFPO1lBQUM7WUFBRyxDQUFDO1lBQUc7U0FBRTtRQUNqQm9FLFVBQVU7WUFBQyxDQUFDL0IsS0FBS0MsRUFBRSxHQUFHO1lBQUc7WUFBRztTQUFFO0lBQ2hDLEdBQUcsV0FBVyxHQUFFOUMsZ0RBQW1CLENBQUMscUJBQXFCO1FBQ3ZENkUsYUFBYTtRQUNiQyxLQUFLOUMsYUFBYVMsT0FBTztRQUN6QjlCLFNBQVNBO1FBQ1RTLFlBQVlBO0lBQ2QsS0FBSyxXQUFXLEdBQUVwQixnREFBbUIsQ0FBQyxzQkFBc0I7UUFDMUR3QixLQUFLSztRQUNMa0QsTUFBTTtZQUFDLENBQUNuRSxRQUFRO1lBQUdBLFFBQVE7WUFBR0MsU0FBUztZQUFHLENBQUNBLFNBQVM7WUFBR0U7WUFBTUM7U0FBSTtJQUNuRTtBQUNGO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0NvbnRhY3RTaGFkb3dzLmpzPzM3NTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlVGhyZWUsIHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IEhvcml6b250YWxCbHVyU2hhZGVyLCBWZXJ0aWNhbEJsdXJTaGFkZXIgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuXG5jb25zdCBDb250YWN0U2hhZG93cyA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgc2NhbGUgPSAxMCxcbiAgZnJhbWVzID0gSW5maW5pdHksXG4gIG9wYWNpdHkgPSAxLFxuICB3aWR0aCA9IDEsXG4gIGhlaWdodCA9IDEsXG4gIGJsdXIgPSAxLFxuICBuZWFyID0gMCxcbiAgZmFyID0gMTAsXG4gIHJlc29sdXRpb24gPSA1MTIsXG4gIHNtb290aCA9IHRydWUsXG4gIGNvbG9yID0gJyMwMDAwMDAnLFxuICBkZXB0aFdyaXRlID0gZmFsc2UsXG4gIHJlbmRlck9yZGVyLFxuICAuLi5wcm9wc1xufSwgZnJlZikgPT4ge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3Qgc2hhZG93Q2FtZXJhID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB3aWR0aCA9IHdpZHRoICogKEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGVbMF0gOiBzY2FsZSB8fCAxKTtcbiAgaGVpZ2h0ID0gaGVpZ2h0ICogKEFycmF5LmlzQXJyYXkoc2NhbGUpID8gc2NhbGVbMV0gOiBzY2FsZSB8fCAxKTtcbiAgY29uc3QgW3JlbmRlclRhcmdldCwgcGxhbmVHZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgYmx1clBsYW5lLCBob3Jpem9udGFsQmx1ck1hdGVyaWFsLCB2ZXJ0aWNhbEJsdXJNYXRlcmlhbCwgcmVuZGVyVGFyZ2V0Qmx1cl0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCByZW5kZXJUYXJnZXQgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQocmVzb2x1dGlvbiwgcmVzb2x1dGlvbik7XG4gICAgY29uc3QgcmVuZGVyVGFyZ2V0Qmx1ciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldChyZXNvbHV0aW9uLCByZXNvbHV0aW9uKTtcbiAgICByZW5kZXJUYXJnZXRCbHVyLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgY29uc3QgcGxhbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KHdpZHRoLCBoZWlnaHQpLnJvdGF0ZVgoTWF0aC5QSSAvIDIpO1xuICAgIGNvbnN0IGJsdXJQbGFuZSA9IG5ldyBUSFJFRS5NZXNoKHBsYW5lR2VvbWV0cnkpO1xuICAgIGNvbnN0IGRlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwoKTtcbiAgICBkZXB0aE1hdGVyaWFsLmRlcHRoVGVzdCA9IGRlcHRoTWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGZhbHNlO1xuICAgIGRlcHRoTWF0ZXJpYWwub25CZWZvcmVDb21waWxlID0gc2hhZGVyID0+IHtcbiAgICAgIHNoYWRlci51bmlmb3JtcyA9IHtcbiAgICAgICAgLi4uc2hhZGVyLnVuaWZvcm1zLFxuICAgICAgICB1Y29sb3I6IHtcbiAgICAgICAgICB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKGNvbG9yKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoYHZvaWQgbWFpbigpIHtgLFxuICAgICAgLy9cbiAgICAgIGB1bmlmb3JtIHZlYzMgdWNvbG9yO1xuICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgYCk7XG4gICAgICBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgPSBzaGFkZXIuZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgndmVjNCggdmVjMyggMS4wIC0gZnJhZ0Nvb3JkWiApLCBvcGFjaXR5ICk7JyxcbiAgICAgIC8vIENvbG9yaXplIHRoZSBzaGFkb3csIG11bHRpcGx5IGJ5IHRoZSBmYWxsb2ZmIHNvIHRoYXQgdGhlIGNlbnRlciBjYW4gcmVtYWluIGRhcmtlclxuICAgICAgJ3ZlYzQoIHVjb2xvciAqIGZyYWdDb29yZFogKiAyLjAsICggMS4wIC0gZnJhZ0Nvb3JkWiApICogMS4wICk7Jyk7XG4gICAgfTtcbiAgICBjb25zdCBob3Jpem9udGFsQmx1ck1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKEhvcml6b250YWxCbHVyU2hhZGVyKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEJsdXJNYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbChWZXJ0aWNhbEJsdXJTaGFkZXIpO1xuICAgIHZlcnRpY2FsQmx1ck1hdGVyaWFsLmRlcHRoVGVzdCA9IGhvcml6b250YWxCbHVyTWF0ZXJpYWwuZGVwdGhUZXN0ID0gZmFsc2U7XG4gICAgcmV0dXJuIFtyZW5kZXJUYXJnZXQsIHBsYW5lR2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIGJsdXJQbGFuZSwgaG9yaXpvbnRhbEJsdXJNYXRlcmlhbCwgdmVydGljYWxCbHVyTWF0ZXJpYWwsIHJlbmRlclRhcmdldEJsdXJdO1xuICB9LCBbcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCwgc2NhbGUsIGNvbG9yXSk7XG4gIGNvbnN0IGJsdXJTaGFkb3dzID0gYmx1ciA9PiB7XG4gICAgYmx1clBsYW5lLnZpc2libGUgPSB0cnVlO1xuICAgIGJsdXJQbGFuZS5tYXRlcmlhbCA9IGhvcml6b250YWxCbHVyTWF0ZXJpYWw7XG4gICAgaG9yaXpvbnRhbEJsdXJNYXRlcmlhbC51bmlmb3Jtcy50RGlmZnVzZS52YWx1ZSA9IHJlbmRlclRhcmdldC50ZXh0dXJlO1xuICAgIGhvcml6b250YWxCbHVyTWF0ZXJpYWwudW5pZm9ybXMuaC52YWx1ZSA9IGJsdXIgKiAxIC8gMjU2O1xuICAgIGdsLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXRCbHVyKTtcbiAgICBnbC5yZW5kZXIoYmx1clBsYW5lLCBzaGFkb3dDYW1lcmEuY3VycmVudCk7XG4gICAgYmx1clBsYW5lLm1hdGVyaWFsID0gdmVydGljYWxCbHVyTWF0ZXJpYWw7XG4gICAgdmVydGljYWxCbHVyTWF0ZXJpYWwudW5pZm9ybXMudERpZmZ1c2UudmFsdWUgPSByZW5kZXJUYXJnZXRCbHVyLnRleHR1cmU7XG4gICAgdmVydGljYWxCbHVyTWF0ZXJpYWwudW5pZm9ybXMudi52YWx1ZSA9IGJsdXIgKiAxIC8gMjU2O1xuICAgIGdsLnNldFJlbmRlclRhcmdldChyZW5kZXJUYXJnZXQpO1xuICAgIGdsLnJlbmRlcihibHVyUGxhbmUsIHNoYWRvd0NhbWVyYS5jdXJyZW50KTtcbiAgICBibHVyUGxhbmUudmlzaWJsZSA9IGZhbHNlO1xuICB9O1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgaW5pdGlhbEJhY2tncm91bmQ7XG4gIGxldCBpbml0aWFsT3ZlcnJpZGVNYXRlcmlhbDtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGlmIChzaGFkb3dDYW1lcmEuY3VycmVudCAmJiAoZnJhbWVzID09PSBJbmZpbml0eSB8fCBjb3VudCA8IGZyYW1lcykpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBpbml0aWFsQmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XG4gICAgICBpbml0aWFsT3ZlcnJpZGVNYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XG4gICAgICByZWYuY3VycmVudC52aXNpYmxlID0gZmFsc2U7XG4gICAgICBzY2VuZS5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICAgIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBkZXB0aE1hdGVyaWFsO1xuICAgICAgZ2wuc2V0UmVuZGVyVGFyZ2V0KHJlbmRlclRhcmdldCk7XG4gICAgICBnbC5yZW5kZXIoc2NlbmUsIHNoYWRvd0NhbWVyYS5jdXJyZW50KTtcbiAgICAgIGJsdXJTaGFkb3dzKGJsdXIpO1xuICAgICAgaWYgKHNtb290aCkgYmx1clNoYWRvd3MoYmx1ciAqIDAuNCk7XG4gICAgICBnbC5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICByZWYuY3VycmVudC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgPSBpbml0aWFsT3ZlcnJpZGVNYXRlcmlhbDtcbiAgICAgIHNjZW5lLmJhY2tncm91bmQgPSBpbml0aWFsQmFja2dyb3VuZDtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZyZWYsICgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIF9leHRlbmRzKHtcbiAgICBcInJvdGF0aW9uLXhcIjogTWF0aC5QSSAvIDJcbiAgfSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXNoXCIsIHtcbiAgICByZW5kZXJPcmRlcjogcmVuZGVyT3JkZXIsXG4gICAgZ2VvbWV0cnk6IHBsYW5lR2VvbWV0cnksXG4gICAgc2NhbGU6IFsxLCAtMSwgMV0sXG4gICAgcm90YXRpb246IFstTWF0aC5QSSAvIDIsIDAsIDBdXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWVzaEJhc2ljTWF0ZXJpYWxcIiwge1xuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgIG1hcDogcmVuZGVyVGFyZ2V0LnRleHR1cmUsXG4gICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICBkZXB0aFdyaXRlOiBkZXB0aFdyaXRlXG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJvcnRob2dyYXBoaWNDYW1lcmFcIiwge1xuICAgIHJlZjogc2hhZG93Q2FtZXJhLFxuICAgIGFyZ3M6IFstd2lkdGggLyAyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIC1oZWlnaHQgLyAyLCBuZWFyLCBmYXJdXG4gIH0pKTtcbn0pO1xuXG5leHBvcnQgeyBDb250YWN0U2hhZG93cyB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJUSFJFRSIsInVzZVRocmVlIiwidXNlRnJhbWUiLCJIb3Jpem9udGFsQmx1clNoYWRlciIsIlZlcnRpY2FsQmx1clNoYWRlciIsIkNvbnRhY3RTaGFkb3dzIiwiZm9yd2FyZFJlZiIsInNjYWxlIiwiZnJhbWVzIiwiSW5maW5pdHkiLCJvcGFjaXR5Iiwid2lkdGgiLCJoZWlnaHQiLCJibHVyIiwibmVhciIsImZhciIsInJlc29sdXRpb24iLCJzbW9vdGgiLCJjb2xvciIsImRlcHRoV3JpdGUiLCJyZW5kZXJPcmRlciIsInByb3BzIiwiZnJlZiIsInJlZiIsInVzZVJlZiIsInNjZW5lIiwic3RhdGUiLCJnbCIsInNoYWRvd0NhbWVyYSIsIkFycmF5IiwiaXNBcnJheSIsInJlbmRlclRhcmdldCIsInBsYW5lR2VvbWV0cnkiLCJkZXB0aE1hdGVyaWFsIiwiYmx1clBsYW5lIiwiaG9yaXpvbnRhbEJsdXJNYXRlcmlhbCIsInZlcnRpY2FsQmx1ck1hdGVyaWFsIiwicmVuZGVyVGFyZ2V0Qmx1ciIsInVzZU1lbW8iLCJXZWJHTFJlbmRlclRhcmdldCIsInRleHR1cmUiLCJnZW5lcmF0ZU1pcG1hcHMiLCJQbGFuZUdlb21ldHJ5Iiwicm90YXRlWCIsIk1hdGgiLCJQSSIsIk1lc2giLCJNZXNoRGVwdGhNYXRlcmlhbCIsImRlcHRoVGVzdCIsIm9uQmVmb3JlQ29tcGlsZSIsInNoYWRlciIsInVuaWZvcm1zIiwidWNvbG9yIiwidmFsdWUiLCJDb2xvciIsImZyYWdtZW50U2hhZGVyIiwicmVwbGFjZSIsIlNoYWRlck1hdGVyaWFsIiwiYmx1clNoYWRvd3MiLCJ2aXNpYmxlIiwibWF0ZXJpYWwiLCJ0RGlmZnVzZSIsImgiLCJzZXRSZW5kZXJUYXJnZXQiLCJyZW5kZXIiLCJjdXJyZW50IiwidiIsImNvdW50IiwiaW5pdGlhbEJhY2tncm91bmQiLCJpbml0aWFsT3ZlcnJpZGVNYXRlcmlhbCIsImJhY2tncm91bmQiLCJvdmVycmlkZU1hdGVyaWFsIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImNyZWF0ZUVsZW1lbnQiLCJnZW9tZXRyeSIsInJvdGF0aW9uIiwidHJhbnNwYXJlbnQiLCJtYXAiLCJhcmdzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/ContactShadows.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Environment.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Environment.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   EnvironmentCube: () => (/* binding */ EnvironmentCube),\n/* harmony export */   EnvironmentMap: () => (/* binding */ EnvironmentMap),\n/* harmony export */   EnvironmentPortal: () => (/* binding */ EnvironmentPortal)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\");\n/* harmony import */ var _useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useEnvironment.js */ \"(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\");\n\n\n\n\n\n\nconst isRef = (obj)=>obj.current && obj.current.isScene;\nconst resolveScene = (scene)=>isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, blur = 0) {\n    const target = resolveScene(scene || defaultScene);\n    const oldbg = target.background;\n    const oldenv = target.environment;\n    // @ts-ignore\n    const oldBlur = target.backgroundBlurriness || 0;\n    if (background !== \"only\") target.environment = texture;\n    if (background) target.background = texture;\n    // @ts-ignore\n    if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = blur;\n    return ()=>{\n        if (background !== \"only\") target.environment = oldenv;\n        if (background) target.background = oldbg;\n        // @ts-ignore\n        if (background && target.backgroundBlurriness !== undefined) target.backgroundBlurriness = oldBlur;\n    };\n}\nfunction EnvironmentMap({ scene, background = false, blur, map }) {\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (map) return setEnvProps(background, scene, defaultScene, map, blur);\n    }, [\n        defaultScene,\n        scene,\n        map,\n        background,\n        blur\n    ]);\n    return null;\n}\nfunction EnvironmentCube({ background = false, scene, blur, ...rest }) {\n    const texture = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(rest);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)((state)=>state.scene);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        return setEnvProps(background, scene, defaultScene, texture, blur);\n    }, [\n        texture,\n        background,\n        scene,\n        defaultScene,\n        blur\n    ]);\n    return null;\n}\nfunction EnvironmentPortal({ children, near = 1, far = 1000, resolution = 256, frames = 1, map, background = false, blur, scene, files, path, preset = undefined, extensions }) {\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)((state)=>state.gl);\n    const defaultScene = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)((state)=>state.scene);\n    const camera = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [virtualScene] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Scene());\n    const fbo = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const fbo = new three__WEBPACK_IMPORTED_MODULE_4__.WebGLCubeRenderTarget(resolution);\n        fbo.texture.type = three__WEBPACK_IMPORTED_MODULE_4__.HalfFloatType;\n        return fbo;\n    }, [\n        resolution\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (frames === 1) camera.current.update(gl, virtualScene);\n        return setEnvProps(background, scene, defaultScene, fbo.texture, blur);\n    }, [\n        children,\n        virtualScene,\n        fbo.texture,\n        scene,\n        defaultScene,\n        background,\n        frames,\n        gl\n    ]);\n    let count = 1;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.F)(()=>{\n        if (frames === Infinity || count < frames) {\n            camera.current.update(gl, virtualScene);\n            count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.h)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"cubeCamera\", {\n        ref: camera,\n        args: [\n            near,\n            far,\n            fbo\n        ]\n    }), files || preset ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, {\n        background: true,\n        files: files,\n        preset: preset,\n        path: path,\n        extensions: extensions\n    }) : map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, {\n        background: true,\n        map: map,\n        extensions: extensions\n    }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n    var _props$ground, _props$ground2, _scale, _props$ground3;\n    const textureDefault = (0,_useEnvironment_js__WEBPACK_IMPORTED_MODULE_3__.useEnvironment)(props);\n    const texture = props.map || textureDefault;\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.e)({\n            GroundProjectedEnvImpl: three_stdlib__WEBPACK_IMPORTED_MODULE_5__.GroundProjectedEnv\n        }), []);\n    const args = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            texture\n        ], [\n        texture\n    ]);\n    const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n    const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n    const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        map: texture\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"groundProjectedEnvImpl\", {\n        args: args,\n        scale: scale,\n        height: height,\n        radius: radius\n    }));\n}\nfunction Environment(props) {\n    return props.ground ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentPortal, props) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(EnvironmentCube, props);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9FbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUMrQztBQUNWO0FBQ2xCO0FBQ0c7QUFFckQsTUFBTVcsUUFBUUMsQ0FBQUEsTUFBT0EsSUFBSUMsT0FBTyxJQUFJRCxJQUFJQyxPQUFPLENBQUNDLE9BQU87QUFDdkQsTUFBTUMsZUFBZUMsQ0FBQUEsUUFBU0wsTUFBTUssU0FBU0EsTUFBTUgsT0FBTyxHQUFHRztBQUM3RCxTQUFTQyxZQUFZQyxVQUFVLEVBQUVGLEtBQUssRUFBRUcsWUFBWSxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sQ0FBQztJQUNyRSxNQUFNQyxTQUFTUCxhQUFhQyxTQUFTRztJQUNyQyxNQUFNSSxRQUFRRCxPQUFPSixVQUFVO0lBQy9CLE1BQU1NLFNBQVNGLE9BQU9HLFdBQVc7SUFDakMsYUFBYTtJQUNiLE1BQU1DLFVBQVVKLE9BQU9LLG9CQUFvQixJQUFJO0lBQy9DLElBQUlULGVBQWUsUUFBUUksT0FBT0csV0FBVyxHQUFHTDtJQUNoRCxJQUFJRixZQUFZSSxPQUFPSixVQUFVLEdBQUdFO0lBQ3BDLGFBQWE7SUFDYixJQUFJRixjQUFjSSxPQUFPSyxvQkFBb0IsS0FBS0MsV0FBV04sT0FBT0ssb0JBQW9CLEdBQUdOO0lBQzNGLE9BQU87UUFDTCxJQUFJSCxlQUFlLFFBQVFJLE9BQU9HLFdBQVcsR0FBR0Q7UUFDaEQsSUFBSU4sWUFBWUksT0FBT0osVUFBVSxHQUFHSztRQUNwQyxhQUFhO1FBQ2IsSUFBSUwsY0FBY0ksT0FBT0ssb0JBQW9CLEtBQUtDLFdBQVdOLE9BQU9LLG9CQUFvQixHQUFHRDtJQUM3RjtBQUNGO0FBQ0EsU0FBU0csZUFBZSxFQUN0QmIsS0FBSyxFQUNMRSxhQUFhLEtBQUssRUFDbEJHLElBQUksRUFDSlMsR0FBRyxFQUNKO0lBQ0MsTUFBTVgsZUFBZWpCLHFEQUFRQSxDQUFDNkIsQ0FBQUEs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QUNrQyxtQkFBbUIwQixTQUFTLFdBQVcsR0FBRTVELGdEQUFtQixDQUFDZ0MsaUJBQWlCNEI7QUFDM1I7QUFFMkUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvRW52aXJvbm1lbnQuanM/NjA0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUsIGNyZWF0ZVBvcnRhbCwgZXh0ZW5kIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IFNjZW5lLCBXZWJHTEN1YmVSZW5kZXJUYXJnZXQsIEhhbGZGbG9hdFR5cGUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBHcm91bmRQcm9qZWN0ZWRFbnYgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuaW1wb3J0IHsgdXNlRW52aXJvbm1lbnQgfSBmcm9tICcuL3VzZUVudmlyb25tZW50LmpzJztcblxuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqLmN1cnJlbnQgJiYgb2JqLmN1cnJlbnQuaXNTY2VuZTtcbmNvbnN0IHJlc29sdmVTY2VuZSA9IHNjZW5lID0+IGlzUmVmKHNjZW5lKSA/IHNjZW5lLmN1cnJlbnQgOiBzY2VuZTtcbmZ1bmN0aW9uIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIHRleHR1cmUsIGJsdXIgPSAwKSB7XG4gIGNvbnN0IHRhcmdldCA9IHJlc29sdmVTY2VuZShzY2VuZSB8fCBkZWZhdWx0U2NlbmUpO1xuICBjb25zdCBvbGRiZyA9IHRhcmdldC5iYWNrZ3JvdW5kO1xuICBjb25zdCBvbGRlbnYgPSB0YXJnZXQuZW52aXJvbm1lbnQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgb2xkQmx1ciA9IHRhcmdldC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyB8fCAwO1xuICBpZiAoYmFja2dyb3VuZCAhPT0gJ29ubHknKSB0YXJnZXQuZW52aXJvbm1lbnQgPSB0ZXh0dXJlO1xuICBpZiAoYmFja2dyb3VuZCkgdGFyZ2V0LmJhY2tncm91bmQgPSB0ZXh0dXJlO1xuICAvLyBAdHMtaWdub3JlXG4gIGlmIChiYWNrZ3JvdW5kICYmIHRhcmdldC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyAhPT0gdW5kZWZpbmVkKSB0YXJnZXQuYmFja2dyb3VuZEJsdXJyaW5lc3MgPSBibHVyO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChiYWNrZ3JvdW5kICE9PSAnb25seScpIHRhcmdldC5lbnZpcm9ubWVudCA9IG9sZGVudjtcbiAgICBpZiAoYmFja2dyb3VuZCkgdGFyZ2V0LmJhY2tncm91bmQgPSBvbGRiZztcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGJhY2tncm91bmQgJiYgdGFyZ2V0LmJhY2tncm91bmRCbHVycmluZXNzICE9PSB1bmRlZmluZWQpIHRhcmdldC5iYWNrZ3JvdW5kQmx1cnJpbmVzcyA9IG9sZEJsdXI7XG4gIH07XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudE1hcCh7XG4gIHNjZW5lLFxuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIGJsdXIsXG4gIG1hcFxufSkge1xuICBjb25zdCBkZWZhdWx0U2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcCkgcmV0dXJuIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIG1hcCwgYmx1cik7XG4gIH0sIFtkZWZhdWx0U2NlbmUsIHNjZW5lLCBtYXAsIGJhY2tncm91bmQsIGJsdXJdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudEN1YmUoe1xuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIHNjZW5lLFxuICBibHVyLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IHRleHR1cmUgPSB1c2VFbnZpcm9ubWVudChyZXN0KTtcbiAgY29uc3QgZGVmYXVsdFNjZW5lID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2NlbmUpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBzZXRFbnZQcm9wcyhiYWNrZ3JvdW5kLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCB0ZXh0dXJlLCBibHVyKTtcbiAgfSwgW3RleHR1cmUsIGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIGJsdXJdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudFBvcnRhbCh7XG4gIGNoaWxkcmVuLFxuICBuZWFyID0gMSxcbiAgZmFyID0gMTAwMCxcbiAgcmVzb2x1dGlvbiA9IDI1NixcbiAgZnJhbWVzID0gMSxcbiAgbWFwLFxuICBiYWNrZ3JvdW5kID0gZmFsc2UsXG4gIGJsdXIsXG4gIHNjZW5lLFxuICBmaWxlcyxcbiAgcGF0aCxcbiAgcHJlc2V0ID0gdW5kZWZpbmVkLFxuICBleHRlbnNpb25zXG59KSB7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICBjb25zdCBkZWZhdWx0U2NlbmUgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zY2VuZSk7XG4gIGNvbnN0IGNhbWVyYSA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW3ZpcnR1YWxTY2VuZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgU2NlbmUoKSk7XG4gIGNvbnN0IGZibyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGZibyA9IG5ldyBXZWJHTEN1YmVSZW5kZXJUYXJnZXQocmVzb2x1dGlvbik7XG4gICAgZmJvLnRleHR1cmUudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gICAgcmV0dXJuIGZibztcbiAgfSwgW3Jlc29sdXRpb25dKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZnJhbWVzID09PSAxKSBjYW1lcmEuY3VycmVudC51cGRhdGUoZ2wsIHZpcnR1YWxTY2VuZSk7XG4gICAgcmV0dXJuIHNldEVudlByb3BzKGJhY2tncm91bmQsIHNjZW5lLCBkZWZhdWx0U2NlbmUsIGZiby50ZXh0dXJlLCBibHVyKTtcbiAgfSwgW2NoaWxkcmVuLCB2aXJ0dWFsU2NlbmUsIGZiby50ZXh0dXJlLCBzY2VuZSwgZGVmYXVsdFNjZW5lLCBiYWNrZ3JvdW5kLCBmcmFtZXMsIGdsXSk7XG4gIGxldCBjb3VudCA9IDE7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBpZiAoZnJhbWVzID09PSBJbmZpbml0eSB8fCBjb3VudCA8IGZyYW1lcykge1xuICAgICAgY2FtZXJhLmN1cnJlbnQudXBkYXRlKGdsLCB2aXJ0dWFsU2NlbmUpO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNyZWF0ZVBvcnRhbCggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImN1YmVDYW1lcmFcIiwge1xuICAgIHJlZjogY2FtZXJhLFxuICAgIGFyZ3M6IFtuZWFyLCBmYXIsIGZib11cbiAgfSksIGZpbGVzIHx8IHByZXNldCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50Q3ViZSwge1xuICAgIGJhY2tncm91bmQ6IHRydWUsXG4gICAgZmlsZXM6IGZpbGVzLFxuICAgIHByZXNldDogcHJlc2V0LFxuICAgIHBhdGg6IHBhdGgsXG4gICAgZXh0ZW5zaW9uczogZXh0ZW5zaW9uc1xuICB9KSA6IG1hcCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50TWFwLCB7XG4gICAgYmFja2dyb3VuZDogdHJ1ZSxcbiAgICBtYXA6IG1hcCxcbiAgICBleHRlbnNpb25zOiBleHRlbnNpb25zXG4gIH0pIDogbnVsbCksIHZpcnR1YWxTY2VuZSkpO1xufVxuZnVuY3Rpb24gRW52aXJvbm1lbnRHcm91bmQocHJvcHMpIHtcbiAgdmFyIF9wcm9wcyRncm91bmQsIF9wcm9wcyRncm91bmQyLCBfc2NhbGUsIF9wcm9wcyRncm91bmQzO1xuICBjb25zdCB0ZXh0dXJlRGVmYXVsdCA9IHVzZUVudmlyb25tZW50KHByb3BzKTtcbiAgY29uc3QgdGV4dHVyZSA9IHByb3BzLm1hcCB8fCB0ZXh0dXJlRGVmYXVsdDtcbiAgUmVhY3QudXNlTWVtbygoKSA9PiBleHRlbmQoe1xuICAgIEdyb3VuZFByb2plY3RlZEVudkltcGw6IEdyb3VuZFByb2plY3RlZEVudlxuICB9KSwgW10pO1xuICBjb25zdCBhcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiBbdGV4dHVyZV0sIFt0ZXh0dXJlXSk7XG4gIGNvbnN0IGhlaWdodCA9IChfcHJvcHMkZ3JvdW5kID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZC5oZWlnaHQ7XG4gIGNvbnN0IHJhZGl1cyA9IChfcHJvcHMkZ3JvdW5kMiA9IHByb3BzLmdyb3VuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRncm91bmQyLnJhZGl1cztcbiAgY29uc3Qgc2NhbGUgPSAoX3NjYWxlID0gKF9wcm9wcyRncm91bmQzID0gcHJvcHMuZ3JvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdyb3VuZDMuc2NhbGUpICE9PSBudWxsICYmIF9zY2FsZSAhPT0gdm9pZCAwID8gX3NjYWxlIDogMTAwMDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudE1hcCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgbWFwOiB0ZXh0dXJlXG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91bmRQcm9qZWN0ZWRFbnZJbXBsXCIsIHtcbiAgICBhcmdzOiBhcmdzLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByYWRpdXM6IHJhZGl1c1xuICB9KSk7XG59XG5mdW5jdGlvbiBFbnZpcm9ubWVudChwcm9wcykge1xuICByZXR1cm4gcHJvcHMuZ3JvdW5kID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnRHcm91bmQsIHByb3BzKSA6IHByb3BzLm1hcCA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50TWFwLCBwcm9wcykgOiBwcm9wcy5jaGlsZHJlbiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVudmlyb25tZW50UG9ydGFsLCBwcm9wcykgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFbnZpcm9ubWVudEN1YmUsIHByb3BzKTtcbn1cblxuZXhwb3J0IHsgRW52aXJvbm1lbnQsIEVudmlyb25tZW50Q3ViZSwgRW52aXJvbm1lbnRNYXAsIEVudmlyb25tZW50UG9ydGFsIH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJSZWFjdCIsInVzZVRocmVlIiwidXNlRnJhbWUiLCJjcmVhdGVQb3J0YWwiLCJleHRlbmQiLCJTY2VuZSIsIldlYkdMQ3ViZVJlbmRlclRhcmdldCIsIkhhbGZGbG9hdFR5cGUiLCJHcm91bmRQcm9qZWN0ZWRFbnYiLCJ1c2VFbnZpcm9ubWVudCIsImlzUmVmIiwib2JqIiwiY3VycmVudCIsImlzU2NlbmUiLCJyZXNvbHZlU2NlbmUiLCJzY2VuZSIsInNldEVudlByb3BzIiwiYmFja2dyb3VuZCIsImRlZmF1bHRTY2VuZSIsInRleHR1cmUiLCJibHVyIiwidGFyZ2V0Iiwib2xkYmciLCJvbGRlbnYiLCJlbnZpcm9ubWVudCIsIm9sZEJsdXIiLCJiYWNrZ3JvdW5kQmx1cnJpbmVzcyIsInVuZGVmaW5lZCIsIkVudmlyb25tZW50TWFwIiwibWFwIiwic3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJFbnZpcm9ubWVudEN1YmUiLCJyZXN0IiwiRW52aXJvbm1lbnRQb3J0YWwiLCJjaGlsZHJlbiIsIm5lYXIiLCJmYXIiLCJyZXNvbHV0aW9uIiwiZnJhbWVzIiwiZmlsZXMiLCJwYXRoIiwicHJlc2V0IiwiZXh0ZW5zaW9ucyIsImdsIiwiY2FtZXJhIiwidXNlUmVmIiwidmlydHVhbFNjZW5lIiwidXNlU3RhdGUiLCJmYm8iLCJ1c2VNZW1vIiwidHlwZSIsInVwZGF0ZSIsImNvdW50IiwiSW5maW5pdHkiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJyZWYiLCJhcmdzIiwiRW52aXJvbm1lbnRHcm91bmQiLCJwcm9wcyIsIl9wcm9wcyRncm91bmQiLCJfcHJvcHMkZ3JvdW5kMiIsIl9zY2FsZSIsIl9wcm9wcyRncm91bmQzIiwidGV4dHVyZURlZmF1bHQiLCJHcm91bmRQcm9qZWN0ZWRFbnZJbXBsIiwiaGVpZ2h0IiwiZ3JvdW5kIiwicmFkaXVzIiwic2NhbGUiLCJFbnZpcm9ubWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Environment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Float.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Float.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Float: () => (/* binding */ Float)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n\n\nconst Float = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({ children, enabled = true, speed = 1, rotationIntensity = 1, floatIntensity = 1, floatingRange = [\n    -0.1,\n    0.1\n], ...props }, forwardRef)=>{\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(forwardRef, ()=>ref.current, []);\n    const offset = react__WEBPACK_IMPORTED_MODULE_0__.useRef(Math.random() * 10000);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.F)((state)=>{\n        var _floatingRange$, _floatingRange$2;\n        if (!enabled || speed === 0) return;\n        const t = offset.current + state.clock.getElapsedTime();\n        ref.current.rotation.x = Math.cos(t / 4 * speed) / 8 * rotationIntensity;\n        ref.current.rotation.y = Math.sin(t / 4 * speed) / 8 * rotationIntensity;\n        ref.current.rotation.z = Math.sin(t / 4 * speed) / 20 * rotationIntensity;\n        let yPosition = Math.sin(t / 4 * speed) / 10;\n        yPosition = three__WEBPACK_IMPORTED_MODULE_2__.MathUtils.mapLinear(yPosition, -0.1, 0.1, (_floatingRange$ = floatingRange == null ? void 0 : floatingRange[0]) !== null && _floatingRange$ !== void 0 ? _floatingRange$ : -0.1, (_floatingRange$2 = floatingRange == null ? void 0 : floatingRange[1]) !== null && _floatingRange$2 !== void 0 ? _floatingRange$2 : 0.1);\n        ref.current.position.y = yPosition * floatIntensity;\n        ref.current.updateMatrix();\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", props, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", {\n        ref: ref,\n        matrixAutoUpdate: false\n    }, children));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9GbG9hdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErQjtBQUNlO0FBQ2Y7QUFFL0IsTUFBTUcsUUFBUSxhQUFhLGlCQUFFSCw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQzdDSyxRQUFRLEVBQ1JDLFVBQVUsSUFBSSxFQUNkQyxRQUFRLENBQUMsRUFDVEMsb0JBQW9CLENBQUMsRUFDckJDLGlCQUFpQixDQUFDLEVBQ2xCQyxnQkFBZ0I7SUFBQyxDQUFDO0lBQUs7Q0FBSSxFQUMzQixHQUFHQyxPQUNKLEVBQUVQO0lBQ0QsTUFBTVEsTUFBTVoseUNBQVksQ0FBQztJQUN6QkEsc0RBQXlCLENBQUNJLFlBQVksSUFBTVEsSUFBSUcsT0FBTyxFQUFFLEVBQUU7SUFDM0QsTUFBTUMsU0FBU2hCLHlDQUFZLENBQUNpQixLQUFLQyxNQUFNLEtBQUs7SUFDNUNqQixxREFBUUEsQ0FBQ2tCLENBQUFBO1FBQ1AsSUFBSUMsaUJBQWlCQztRQUNyQixJQUFJLENBQUNmLFdBQVdDLFVBQVUsR0FBRztRQUM3QixNQUFNZSxJQUFJTixPQUFPRCxPQUFPLEdBQUdJLE1BQU1JLEtBQUssQ0FBQ0MsY0FBYztRQUNyRFosSUFBSUcsT0FBTyxDQUFDVSxRQUFRLENBQUNDLENBQUMsR0FBR1QsS0FBS1UsR0FBRyxDQUFDTCxJQUFJLElBQUlmLFNBQVMsSUFBSUM7UUFDdkRJLElBQUlHLE9BQU8sQ0FBQ1UsUUFBUSxDQUFDRyxDQUFDLEdBQUdYLEtBQUtZLEdBQUcsQ0FBQ1AsSUFBSSxJQUFJZixTQUFTLElBQUlDO1FBQ3ZESSxJQUFJRyxPQUFPLENBQUNVLFFBQVEsQ0FBQ0ssQ0FBQyxHQUFHYixLQUFLWSxHQUFHLENBQUNQLElBQUksSUFBSWYsU0FBUyxLQUFLQztRQUN4RCxJQUFJdUIsWUFBWWQsS0FBS1ksR0FBRyxDQUFDUCxJQUFJLElBQUlmLFNBQVM7UUFDMUN3QixZQUFZN0IsNENBQWUsQ0FBQytCLFNBQVMsQ0FBQ0YsV0FBVyxDQUFDLEtBQUssS0FBSyxDQUFDWCxrQkFBa0JWLGlCQUFpQixPQUFPLEtBQUssSUFBSUEsYUFBYSxDQUFDLEVBQUUsTUFBTSxRQUFRVSxvQkFBb0IsS0FBSyxJQUFJQSxrQkFBa0IsQ0FBQyxLQUFLLENBQUNDLG1CQUFtQlgsaUJBQWlCLE9BQU8sS0FBSyxJQUFJQSxhQUFhLENBQUMsRUFBRSxNQUFNLFFBQVFXLHFCQUFxQixLQUFLLElBQUlBLG1CQUFtQjtRQUN2VVQsSUFBSUcsT0FBTyxDQUFDbUIsUUFBUSxDQUFDTixDQUFDLEdBQUdHLFlBQVl0QjtRQUNyQ0csSUFBSUcsT0FBTyxDQUFDb0IsWUFBWTtJQUMxQjtJQUNBLE9BQU8sV0FBVyxHQUFFbkMsZ0RBQW1CLENBQUMsU0FBU1csT0FBTyxXQUFXLEdBQUVYLGdEQUFtQixDQUFDLFNBQVM7UUFDaEdZLEtBQUtBO1FBQ0x5QixrQkFBa0I7SUFDcEIsR0FBR2hDO0FBQ0w7QUFFaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvRmxvYXQuanM/MmVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IEZsb2F0ID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgZW5hYmxlZCA9IHRydWUsXG4gIHNwZWVkID0gMSxcbiAgcm90YXRpb25JbnRlbnNpdHkgPSAxLFxuICBmbG9hdEludGVuc2l0eSA9IDEsXG4gIGZsb2F0aW5nUmFuZ2UgPSBbLTAuMSwgMC4xXSxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRSZWYpID0+IHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRSZWYsICgpID0+IHJlZi5jdXJyZW50LCBbXSk7XG4gIGNvbnN0IG9mZnNldCA9IFJlYWN0LnVzZVJlZihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xuICB1c2VGcmFtZShzdGF0ZSA9PiB7XG4gICAgdmFyIF9mbG9hdGluZ1JhbmdlJCwgX2Zsb2F0aW5nUmFuZ2UkMjtcbiAgICBpZiAoIWVuYWJsZWQgfHwgc3BlZWQgPT09IDApIHJldHVybjtcbiAgICBjb25zdCB0ID0gb2Zmc2V0LmN1cnJlbnQgKyBzdGF0ZS5jbG9jay5nZXRFbGFwc2VkVGltZSgpO1xuICAgIHJlZi5jdXJyZW50LnJvdGF0aW9uLnggPSBNYXRoLmNvcyh0IC8gNCAqIHNwZWVkKSAvIDggKiByb3RhdGlvbkludGVuc2l0eTtcbiAgICByZWYuY3VycmVudC5yb3RhdGlvbi55ID0gTWF0aC5zaW4odCAvIDQgKiBzcGVlZCkgLyA4ICogcm90YXRpb25JbnRlbnNpdHk7XG4gICAgcmVmLmN1cnJlbnQucm90YXRpb24ueiA9IE1hdGguc2luKHQgLyA0ICogc3BlZWQpIC8gMjAgKiByb3RhdGlvbkludGVuc2l0eTtcbiAgICBsZXQgeVBvc2l0aW9uID0gTWF0aC5zaW4odCAvIDQgKiBzcGVlZCkgLyAxMDtcbiAgICB5UG9zaXRpb24gPSBUSFJFRS5NYXRoVXRpbHMubWFwTGluZWFyKHlQb3NpdGlvbiwgLTAuMSwgMC4xLCAoX2Zsb2F0aW5nUmFuZ2UkID0gZmxvYXRpbmdSYW5nZSA9PSBudWxsID8gdm9pZCAwIDogZmxvYXRpbmdSYW5nZVswXSkgIT09IG51bGwgJiYgX2Zsb2F0aW5nUmFuZ2UkICE9PSB2b2lkIDAgPyBfZmxvYXRpbmdSYW5nZSQgOiAtMC4xLCAoX2Zsb2F0aW5nUmFuZ2UkMiA9IGZsb2F0aW5nUmFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGZsb2F0aW5nUmFuZ2VbMV0pICE9PSBudWxsICYmIF9mbG9hdGluZ1JhbmdlJDIgIT09IHZvaWQgMCA/IF9mbG9hdGluZ1JhbmdlJDIgOiAwLjEpO1xuICAgIHJlZi5jdXJyZW50LnBvc2l0aW9uLnkgPSB5UG9zaXRpb24gKiBmbG9hdEludGVuc2l0eTtcbiAgICByZWYuY3VycmVudC51cGRhdGVNYXRyaXgoKTtcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHByb3BzLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHtcbiAgICByZWY6IHJlZixcbiAgICBtYXRyaXhBdXRvVXBkYXRlOiBmYWxzZVxuICB9LCBjaGlsZHJlbikpO1xufSk7XG5cbmV4cG9ydCB7IEZsb2F0IH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VGcmFtZSIsIlRIUkVFIiwiRmxvYXQiLCJmb3J3YXJkUmVmIiwiY2hpbGRyZW4iLCJlbmFibGVkIiwic3BlZWQiLCJyb3RhdGlvbkludGVuc2l0eSIsImZsb2F0SW50ZW5zaXR5IiwiZmxvYXRpbmdSYW5nZSIsInByb3BzIiwicmVmIiwidXNlUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImN1cnJlbnQiLCJvZmZzZXQiLCJNYXRoIiwicmFuZG9tIiwic3RhdGUiLCJfZmxvYXRpbmdSYW5nZSQiLCJfZmxvYXRpbmdSYW5nZSQyIiwidCIsImNsb2NrIiwiZ2V0RWxhcHNlZFRpbWUiLCJyb3RhdGlvbiIsIngiLCJjb3MiLCJ5Iiwic2luIiwieiIsInlQb3NpdGlvbiIsIk1hdGhVdGlscyIsIm1hcExpbmVhciIsInBvc2l0aW9uIiwidXBkYXRlTWF0cml4IiwiY3JlYXRlRWxlbWVudCIsIm1hdHJpeEF1dG9VcGRhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Float.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Stage.js":
/*!******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Stage.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stage: () => (/* binding */ Stage)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Environment_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Environment.js */ \"(ssr)/./node_modules/@react-three/drei/core/Environment.js\");\n/* harmony import */ var _ContactShadows_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ContactShadows.js */ \"(ssr)/./node_modules/@react-three/drei/core/ContactShadows.js\");\n/* harmony import */ var _Center_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Center.js */ \"(ssr)/./node_modules/@react-three/drei/core/Center.js\");\n/* harmony import */ var _AccumulativeShadows_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AccumulativeShadows.js */ \"(ssr)/./node_modules/@react-three/drei/core/AccumulativeShadows.js\");\n/* harmony import */ var _Bounds_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bounds.js */ \"(ssr)/./node_modules/@react-three/drei/core/Bounds.js\");\n\n\n\n\n\n\n\nconst presets = {\n    rembrandt: {\n        main: [\n            1,\n            2,\n            1\n        ],\n        fill: [\n            -2,\n            -0.5,\n            -2\n        ]\n    },\n    portrait: {\n        main: [\n            -1,\n            2,\n            0.5\n        ],\n        fill: [\n            -1,\n            0.5,\n            -1.5\n        ]\n    },\n    upfront: {\n        main: [\n            0,\n            2,\n            1\n        ],\n        fill: [\n            -1,\n            0.5,\n            -1.5\n        ]\n    },\n    soft: {\n        main: [\n            -2,\n            4,\n            4\n        ],\n        fill: [\n            -1,\n            0.5,\n            -1.5\n        ]\n    }\n};\nfunction Refit({ radius, adjustCamera }) {\n    const api = (0,_Bounds_js__WEBPACK_IMPORTED_MODULE_2__.useBounds)();\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (adjustCamera) api.refresh().clip().fit();\n    }, [\n        radius,\n        adjustCamera\n    ]);\n    return null;\n}\nfunction Stage({ children, center, adjustCamera = true, intensity = 0.5, shadows = \"contact\", environment = \"city\", preset = \"rembrandt\", ...props }) {\n    var _bias, _normalBias, _size, _offset, _amount, _radius, _ambient, _intensity;\n    const config = typeof preset === \"string\" ? presets[preset] : preset;\n    const [{ radius, height }, set] = react__WEBPACK_IMPORTED_MODULE_1__.useState({\n        radius: 0,\n        width: 0,\n        height: 0,\n        depth: 0\n    });\n    const shadowBias = (_bias = shadows == null ? void 0 : shadows.bias) !== null && _bias !== void 0 ? _bias : -0.0001;\n    const normalBias = (_normalBias = shadows == null ? void 0 : shadows.normalBias) !== null && _normalBias !== void 0 ? _normalBias : 0;\n    const shadowSize = (_size = shadows == null ? void 0 : shadows.size) !== null && _size !== void 0 ? _size : 1024;\n    const shadowOffset = (_offset = shadows == null ? void 0 : shadows.offset) !== null && _offset !== void 0 ? _offset : 0;\n    const contactShadow = shadows === \"contact\" || (shadows == null ? void 0 : shadows.type) === \"contact\";\n    const accumulativeShadow = shadows === \"accumulative\" || (shadows == null ? void 0 : shadows.type) === \"accumulative\";\n    const shadowSpread = {\n        ...typeof shadows === \"object\" ? shadows : {}\n    };\n    const environmentProps = !environment ? null : typeof environment === \"string\" ? {\n        preset: environment\n    } : environment;\n    const onCentered = react__WEBPACK_IMPORTED_MODULE_1__.useCallback((props)=>{\n        const { width, height, depth, boundingSphere } = props;\n        set({\n            radius: boundingSphere.radius,\n            width,\n            height,\n            depth\n        });\n        if (center != null && center.onCentered) center.onCentered(props);\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"ambientLight\", {\n        intensity: intensity / 3\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"spotLight\", {\n        penumbra: 1,\n        position: [\n            config.main[0] * radius,\n            config.main[1] * radius,\n            config.main[2] * radius\n        ],\n        intensity: intensity * 2,\n        castShadow: !!shadows,\n        \"shadow-bias\": shadowBias,\n        \"shadow-normalBias\": normalBias,\n        \"shadow-mapSize\": shadowSize\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"pointLight\", {\n        position: [\n            config.fill[0] * radius,\n            config.fill[1] * radius,\n            config.fill[2] * radius\n        ],\n        intensity: intensity\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Bounds_js__WEBPACK_IMPORTED_MODULE_2__.Bounds, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        fit: !!adjustCamera,\n        clip: !!adjustCamera,\n        margin: Number(adjustCamera),\n        observe: true\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Refit, {\n        radius: radius,\n        adjustCamera: adjustCamera\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Center_js__WEBPACK_IMPORTED_MODULE_3__.Center, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, center, {\n        position: [\n            0,\n            shadowOffset / 2,\n            0\n        ],\n        onCentered: onCentered\n    }), children)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        position: [\n            0,\n            -height / 2 - shadowOffset / 2,\n            0\n        ]\n    }, contactShadow && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_ContactShadows_js__WEBPACK_IMPORTED_MODULE_4__.ContactShadows, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        scale: radius * 4,\n        far: radius,\n        blur: 2\n    }, shadowSpread)), accumulativeShadow && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_AccumulativeShadows_js__WEBPACK_IMPORTED_MODULE_5__.AccumulativeShadows, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        temporal: true,\n        frames: 100,\n        alphaTest: 0.9,\n        toneMapped: true,\n        scale: radius * 4\n    }, shadowSpread), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_AccumulativeShadows_js__WEBPACK_IMPORTED_MODULE_5__.RandomizedLight, {\n        amount: (_amount = shadowSpread.amount) !== null && _amount !== void 0 ? _amount : 8,\n        radius: (_radius = shadowSpread.radius) !== null && _radius !== void 0 ? _radius : radius,\n        ambient: (_ambient = shadowSpread.ambient) !== null && _ambient !== void 0 ? _ambient : 0.5,\n        intensity: (_intensity = shadowSpread.intensity) !== null && _intensity !== void 0 ? _intensity : 1,\n        position: [\n            config.main[0] * radius,\n            config.main[1] * radius,\n            config.main[2] * radius\n        ],\n        size: radius * 4,\n        bias: -shadowBias,\n        mapSize: shadowSize\n    }))), environment && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_Environment_js__WEBPACK_IMPORTED_MODULE_6__.Environment, environmentProps));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9TdGFnZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDZ0I7QUFDTTtBQUNoQjtBQUMyQztBQUNoQztBQUVoRCxNQUFNUyxVQUFVO0lBQ2RDLFdBQVc7UUFDVEMsTUFBTTtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQ2ZDLE1BQU07WUFBQyxDQUFDO1lBQUcsQ0FBQztZQUFLLENBQUM7U0FBRTtJQUN0QjtJQUNBQyxVQUFVO1FBQ1JGLE1BQU07WUFBQyxDQUFDO1lBQUc7WUFBRztTQUFJO1FBQ2xCQyxNQUFNO1lBQUMsQ0FBQztZQUFHO1lBQUssQ0FBQztTQUFJO0lBQ3ZCO0lBQ0FFLFNBQVM7UUFDUEgsTUFBTTtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQ2ZDLE1BQU07WUFBQyxDQUFDO1lBQUc7WUFBSyxDQUFDO1NBQUk7SUFDdkI7SUFDQUcsTUFBTTtRQUNKSixNQUFNO1lBQUMsQ0FBQztZQUFHO1lBQUc7U0FBRTtRQUNoQkMsTUFBTTtZQUFDLENBQUM7WUFBRztZQUFLLENBQUM7U0FBSTtJQUN2QjtBQUNGO0FBQ0EsU0FBU0ksTUFBTSxFQUNiQyxNQUFNLEVBQ05DLFlBQVksRUFDYjtJQUNDLE1BQU1DLE1BQU1YLHFEQUFTQTtJQUNyQlAsNENBQWUsQ0FBQztRQUNkLElBQUlpQixjQUFjQyxJQUFJRSxPQUFPLEdBQUdDLElBQUksR0FBR0MsR0FBRztJQUM1QyxHQUFHO1FBQUNOO1FBQVFDO0tBQWE7SUFDekIsT0FBTztBQUNUO0FBQ0EsU0FBU00sTUFBTSxFQUNiQyxRQUFRLEVBQ1JDLE1BQU0sRUFDTlIsZUFBZSxJQUFJLEVBQ25CUyxZQUFZLEdBQUcsRUFDZkMsVUFBVSxTQUFTLEVBQ25CQyxjQUFjLE1BQU0sRUFDcEJDLFNBQVMsV0FBVyxFQUNwQixHQUFHQyxPQUNKO0lBQ0MsSUFBSUMsT0FBT0MsYUFBYUMsT0FBT0MsU0FBU0MsU0FBU0MsU0FBU0Ms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LFVBQVU7WUFBQ3hCLE9BQU83QixJQUFJLENBQUMsRUFBRSxHQUFHTTtZQUFRdUIsT0FBTzdCLElBQUksQ0FBQyxFQUFFLEdBQUdNO1lBQVF1QixPQUFPN0IsSUFBSSxDQUFDLEVBQUUsR0FBR007U0FBTztRQUNyRmlDLE1BQU1qQyxTQUFTO1FBQ2Y4QixNQUFNLENBQUNEO1FBQ1BnQyxTQUFTN0I7SUFDWCxNQUFNcEIsZUFBZSxXQUFXLEdBQUU1QixnREFBbUIsQ0FBQ0Msd0RBQVdBLEVBQUV1RDtBQUNyRTtBQUVpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9TdGFnZS5qcz9mOTgyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVudmlyb25tZW50IH0gZnJvbSAnLi9FbnZpcm9ubWVudC5qcyc7XG5pbXBvcnQgeyBDb250YWN0U2hhZG93cyB9IGZyb20gJy4vQ29udGFjdFNoYWRvd3MuanMnO1xuaW1wb3J0IHsgQ2VudGVyIH0gZnJvbSAnLi9DZW50ZXIuanMnO1xuaW1wb3J0IHsgQWNjdW11bGF0aXZlU2hhZG93cywgUmFuZG9taXplZExpZ2h0IH0gZnJvbSAnLi9BY2N1bXVsYXRpdmVTaGFkb3dzLmpzJztcbmltcG9ydCB7IEJvdW5kcywgdXNlQm91bmRzIH0gZnJvbSAnLi9Cb3VuZHMuanMnO1xuXG5jb25zdCBwcmVzZXRzID0ge1xuICByZW1icmFuZHQ6IHtcbiAgICBtYWluOiBbMSwgMiwgMV0sXG4gICAgZmlsbDogWy0yLCAtMC41LCAtMl1cbiAgfSxcbiAgcG9ydHJhaXQ6IHtcbiAgICBtYWluOiBbLTEsIDIsIDAuNV0sXG4gICAgZmlsbDogWy0xLCAwLjUsIC0xLjVdXG4gIH0sXG4gIHVwZnJvbnQ6IHtcbiAgICBtYWluOiBbMCwgMiwgMV0sXG4gICAgZmlsbDogWy0xLCAwLjUsIC0xLjVdXG4gIH0sXG4gIHNvZnQ6IHtcbiAgICBtYWluOiBbLTIsIDQsIDRdLFxuICAgIGZpbGw6IFstMSwgMC41LCAtMS41XVxuICB9XG59O1xuZnVuY3Rpb24gUmVmaXQoe1xuICByYWRpdXMsXG4gIGFkanVzdENhbWVyYVxufSkge1xuICBjb25zdCBhcGkgPSB1c2VCb3VuZHMoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWRqdXN0Q2FtZXJhKSBhcGkucmVmcmVzaCgpLmNsaXAoKS5maXQoKTtcbiAgfSwgW3JhZGl1cywgYWRqdXN0Q2FtZXJhXSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gU3RhZ2Uoe1xuICBjaGlsZHJlbixcbiAgY2VudGVyLFxuICBhZGp1c3RDYW1lcmEgPSB0cnVlLFxuICBpbnRlbnNpdHkgPSAwLjUsXG4gIHNoYWRvd3MgPSAnY29udGFjdCcsXG4gIGVudmlyb25tZW50ID0gJ2NpdHknLFxuICBwcmVzZXQgPSAncmVtYnJhbmR0JyxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgdmFyIF9iaWFzLCBfbm9ybWFsQmlhcywgX3NpemUsIF9vZmZzZXQsIF9hbW91bnQsIF9yYWRpdXMsIF9hbWJpZW50LCBfaW50ZW5zaXR5O1xuICBjb25zdCBjb25maWcgPSB0eXBlb2YgcHJlc2V0ID09PSAnc3RyaW5nJyA/IHByZXNldHNbcHJlc2V0XSA6IHByZXNldDtcbiAgY29uc3QgW3tcbiAgICByYWRpdXMsXG4gICAgaGVpZ2h0XG4gIH0sIHNldF0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgcmFkaXVzOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBkZXB0aDogMFxuICB9KTtcbiAgY29uc3Qgc2hhZG93QmlhcyA9IChfYmlhcyA9IHNoYWRvd3MgPT0gbnVsbCA/IHZvaWQgMCA6IHNoYWRvd3MuYmlhcykgIT09IG51bGwgJiYgX2JpYXMgIT09IHZvaWQgMCA/IF9iaWFzIDogLTAuMDAwMTtcbiAgY29uc3Qgbm9ybWFsQmlhcyA9IChfbm9ybWFsQmlhcyA9IHNoYWRvd3MgPT0gbnVsbCA/IHZvaWQgMCA6IHNoYWRvd3Mubm9ybWFsQmlhcykgIT09IG51bGwgJiYgX25vcm1hbEJpYXMgIT09IHZvaWQgMCA/IF9ub3JtYWxCaWFzIDogMDtcbiAgY29uc3Qgc2hhZG93U2l6ZSA9IChfc2l6ZSA9IHNoYWRvd3MgPT0gbnVsbCA/IHZvaWQgMCA6IHNoYWRvd3Muc2l6ZSkgIT09IG51bGwgJiYgX3NpemUgIT09IHZvaWQgMCA/IF9zaXplIDogMTAyNDtcbiAgY29uc3Qgc2hhZG93T2Zmc2V0ID0gKF9vZmZzZXQgPSBzaGFkb3dzID09IG51bGwgPyB2b2lkIDAgOiBzaGFkb3dzLm9mZnNldCkgIT09IG51bGwgJiYgX29mZnNldCAhPT0gdm9pZCAwID8gX29mZnNldCA6IDA7XG4gIGNvbnN0IGNvbnRhY3RTaGFkb3cgPSBzaGFkb3dzID09PSAnY29udGFjdCcgfHwgKHNoYWRvd3MgPT0gbnVsbCA/IHZvaWQgMCA6IHNoYWRvd3MudHlwZSkgPT09ICdjb250YWN0JztcbiAgY29uc3QgYWNjdW11bGF0aXZlU2hhZG93ID0gc2hhZG93cyA9PT0gJ2FjY3VtdWxhdGl2ZScgfHwgKHNoYWRvd3MgPT0gbnVsbCA/IHZvaWQgMCA6IHNoYWRvd3MudHlwZSkgPT09ICdhY2N1bXVsYXRpdmUnO1xuICBjb25zdCBzaGFkb3dTcHJlYWQgPSB7XG4gICAgLi4uKHR5cGVvZiBzaGFkb3dzID09PSAnb2JqZWN0JyA/IHNoYWRvd3MgOiB7fSlcbiAgfTtcbiAgY29uc3QgZW52aXJvbm1lbnRQcm9wcyA9ICFlbnZpcm9ubWVudCA/IG51bGwgOiB0eXBlb2YgZW52aXJvbm1lbnQgPT09ICdzdHJpbmcnID8ge1xuICAgIHByZXNldDogZW52aXJvbm1lbnRcbiAgfSA6IGVudmlyb25tZW50O1xuICBjb25zdCBvbkNlbnRlcmVkID0gUmVhY3QudXNlQ2FsbGJhY2socHJvcHMgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgZGVwdGgsXG4gICAgICBib3VuZGluZ1NwaGVyZVxuICAgIH0gPSBwcm9wcztcbiAgICBzZXQoe1xuICAgICAgcmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGRlcHRoXG4gICAgfSk7XG4gICAgaWYgKGNlbnRlciAhPSBudWxsICYmIGNlbnRlci5vbkNlbnRlcmVkKSBjZW50ZXIub25DZW50ZXJlZChwcm9wcyk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImFtYmllbnRMaWdodFwiLCB7XG4gICAgaW50ZW5zaXR5OiBpbnRlbnNpdHkgLyAzXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwb3RMaWdodFwiLCB7XG4gICAgcGVudW1icmE6IDEsXG4gICAgcG9zaXRpb246IFtjb25maWcubWFpblswXSAqIHJhZGl1cywgY29uZmlnLm1haW5bMV0gKiByYWRpdXMsIGNvbmZpZy5tYWluWzJdICogcmFkaXVzXSxcbiAgICBpbnRlbnNpdHk6IGludGVuc2l0eSAqIDIsXG4gICAgY2FzdFNoYWRvdzogISFzaGFkb3dzLFxuICAgIFwic2hhZG93LWJpYXNcIjogc2hhZG93QmlhcyxcbiAgICBcInNoYWRvdy1ub3JtYWxCaWFzXCI6IG5vcm1hbEJpYXMsXG4gICAgXCJzaGFkb3ctbWFwU2l6ZVwiOiBzaGFkb3dTaXplXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBvaW50TGlnaHRcIiwge1xuICAgIHBvc2l0aW9uOiBbY29uZmlnLmZpbGxbMF0gKiByYWRpdXMsIGNvbmZpZy5maWxsWzFdICogcmFkaXVzLCBjb25maWcuZmlsbFsyXSAqIHJhZGl1c10sXG4gICAgaW50ZW5zaXR5OiBpbnRlbnNpdHlcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJvdW5kcywgX2V4dGVuZHMoe1xuICAgIGZpdDogISFhZGp1c3RDYW1lcmEsXG4gICAgY2xpcDogISFhZGp1c3RDYW1lcmEsXG4gICAgbWFyZ2luOiBOdW1iZXIoYWRqdXN0Q2FtZXJhKSxcbiAgICBvYnNlcnZlOiB0cnVlXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVmaXQsIHtcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBhZGp1c3RDYW1lcmE6IGFkanVzdENhbWVyYVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2VudGVyLCBfZXh0ZW5kcyh7fSwgY2VudGVyLCB7XG4gICAgcG9zaXRpb246IFswLCBzaGFkb3dPZmZzZXQgLyAyLCAwXSxcbiAgICBvbkNlbnRlcmVkOiBvbkNlbnRlcmVkXG4gIH0pLCBjaGlsZHJlbikpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHtcbiAgICBwb3NpdGlvbjogWzAsIC1oZWlnaHQgLyAyIC0gc2hhZG93T2Zmc2V0IC8gMiwgMF1cbiAgfSwgY29udGFjdFNoYWRvdyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb250YWN0U2hhZG93cywgX2V4dGVuZHMoe1xuICAgIHNjYWxlOiByYWRpdXMgKiA0LFxuICAgIGZhcjogcmFkaXVzLFxuICAgIGJsdXI6IDJcbiAgfSwgc2hhZG93U3ByZWFkKSksIGFjY3VtdWxhdGl2ZVNoYWRvdyAmJiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBY2N1bXVsYXRpdmVTaGFkb3dzLCBfZXh0ZW5kcyh7XG4gICAgdGVtcG9yYWw6IHRydWUsXG4gICAgZnJhbWVzOiAxMDAsXG4gICAgYWxwaGFUZXN0OiAwLjksXG4gICAgdG9uZU1hcHBlZDogdHJ1ZSxcbiAgICBzY2FsZTogcmFkaXVzICogNFxuICB9LCBzaGFkb3dTcHJlYWQpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSYW5kb21pemVkTGlnaHQsIHtcbiAgICBhbW91bnQ6IChfYW1vdW50ID0gc2hhZG93U3ByZWFkLmFtb3VudCkgIT09IG51bGwgJiYgX2Ftb3VudCAhPT0gdm9pZCAwID8gX2Ftb3VudCA6IDgsXG4gICAgcmFkaXVzOiAoX3JhZGl1cyA9IHNoYWRvd1NwcmVhZC5yYWRpdXMpICE9PSBudWxsICYmIF9yYWRpdXMgIT09IHZvaWQgMCA/IF9yYWRpdXMgOiByYWRpdXMsXG4gICAgYW1iaWVudDogKF9hbWJpZW50ID0gc2hhZG93U3ByZWFkLmFtYmllbnQpICE9PSBudWxsICYmIF9hbWJpZW50ICE9PSB2b2lkIDAgPyBfYW1iaWVudCA6IDAuNSxcbiAgICBpbnRlbnNpdHk6IChfaW50ZW5zaXR5ID0gc2hhZG93U3ByZWFkLmludGVuc2l0eSkgIT09IG51bGwgJiYgX2ludGVuc2l0eSAhPT0gdm9pZCAwID8gX2ludGVuc2l0eSA6IDEsXG4gICAgcG9zaXRpb246IFtjb25maWcubWFpblswXSAqIHJhZGl1cywgY29uZmlnLm1haW5bMV0gKiByYWRpdXMsIGNvbmZpZy5tYWluWzJdICogcmFkaXVzXSxcbiAgICBzaXplOiByYWRpdXMgKiA0LFxuICAgIGJpYXM6IC1zaGFkb3dCaWFzLFxuICAgIG1hcFNpemU6IHNoYWRvd1NpemVcbiAgfSkpKSwgZW52aXJvbm1lbnQgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRW52aXJvbm1lbnQsIGVudmlyb25tZW50UHJvcHMpKTtcbn1cblxuZXhwb3J0IHsgU3RhZ2UgfTtcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIlJlYWN0IiwiRW52aXJvbm1lbnQiLCJDb250YWN0U2hhZG93cyIsIkNlbnRlciIsIkFjY3VtdWxhdGl2ZVNoYWRvd3MiLCJSYW5kb21pemVkTGlnaHQiLCJCb3VuZHMiLCJ1c2VCb3VuZHMiLCJwcmVzZXRzIiwicmVtYnJhbmR0IiwibWFpbiIsImZpbGwiLCJwb3J0cmFpdCIsInVwZnJvbnQiLCJzb2Z0IiwiUmVmaXQiLCJyYWRpdXMiLCJhZGp1c3RDYW1lcmEiLCJhcGkiLCJ1c2VFZmZlY3QiLCJyZWZyZXNoIiwiY2xpcCIsImZpdCIsIlN0YWdlIiwiY2hpbGRyZW4iLCJjZW50ZXIiLCJpbnRlbnNpdHkiLCJzaGFkb3dzIiwiZW52aXJvbm1lbnQiLCJwcmVzZXQiLCJwcm9wcyIsIl9iaWFzIiwiX25vcm1hbEJpYXMiLCJfc2l6ZSIsIl9vZmZzZXQiLCJfYW1vdW50IiwiX3JhZGl1cyIsIl9hbWJpZW50IiwiX2ludGVuc2l0eSIsImNvbmZpZyIsImhlaWdodCIsInNldCIsInVzZVN0YXRlIiwid2lkdGgiLCJkZXB0aCIsInNoYWRvd0JpYXMiLCJiaWFzIiwibm9ybWFsQmlhcyIsInNoYWRvd1NpemUiLCJzaXplIiwic2hhZG93T2Zmc2V0Iiwib2Zmc2V0IiwiY29udGFjdFNoYWRvdyIsInR5cGUiLCJhY2N1bXVsYXRpdmVTaGFkb3ciLCJzaGFkb3dTcHJlYWQiLCJlbnZpcm9ubWVudFByb3BzIiwib25DZW50ZXJlZCIsInVzZUNhbGxiYWNrIiwiYm91bmRpbmdTcGhlcmUiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJwZW51bWJyYSIsInBvc2l0aW9uIiwiY2FzdFNoYWRvdyIsIm1hcmdpbiIsIk51bWJlciIsIm9ic2VydmUiLCJzY2FsZSIsImZhciIsImJsdXIiLCJ0ZW1wb3JhbCIsImZyYW1lcyIsImFscGhhVGVzdCIsInRvbmVNYXBwZWQiLCJhbW91bnQiLCJhbWJpZW50IiwibWFwU2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Stage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/shaderMaterial.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shaderMaterial: () => (/* binding */ shaderMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n    const material = class material extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n        constructor(parameters = {}){\n            const entries = Object.entries(uniforms);\n            // Create unforms and shaders\n            super({\n                uniforms: entries.reduce((acc, [name, value])=>{\n                    const uniform = three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone({\n                        [name]: {\n                            value\n                        }\n                    });\n                    return {\n                        ...acc,\n                        ...uniform\n                    };\n                }, {}),\n                vertexShader,\n                fragmentShader\n            });\n            // Create getter/setters\n            this.key = \"\";\n            entries.forEach(([name])=>Object.defineProperty(this, name, {\n                    get: ()=>this.uniforms[name].value,\n                    set: (v)=>this.uniforms[name].value = v\n                }));\n            // Assign parameters, this might include uniforms\n            Object.assign(this, parameters);\n            // Call onInit\n            if (onInit) onInit(this);\n        }\n    };\n    material.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n    return material;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFkZXJNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUUvQixTQUFTQyxlQUFlQyxRQUFRLEVBQUVDLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxNQUFNO0lBQ3BFLE1BQU1DLFdBQVcsTUFBTUEsaUJBQWlCTixpREFBb0I7UUFDMURRLFlBQVlDLGFBQWEsQ0FBQyxDQUFDLENBQUU7WUFDM0IsTUFBTUMsVUFBVUMsT0FBT0QsT0FBTyxDQUFDUjtZQUMvQiw2QkFBNkI7WUFDN0IsS0FBSyxDQUFDO2dCQUNKQSxVQUFVUSxRQUFRRSxNQUFNLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxNQUFNQyxNQUFNO29CQUMxQyxNQUFNQyxVQUFVaEIsZ0RBQW1CLENBQUNrQixLQUFLLENBQUM7d0JBQ3hDLENBQUNKLEtBQUssRUFBRTs0QkFDTkM7d0JBQ0Y7b0JBQ0Y7b0JBQ0EsT0FBTzt3QkFDTCxHQUFHRixHQUFHO3dCQUNOLEdBQUdHLE9BQU87b0JBQ1o7Z0JBQ0YsR0FBRyxDQUFDO2dCQUNKYjtnQkFDQUM7WUFDRjtZQUNBLHdCQUF3QjtZQUN4QixJQUFJLENBQUNlLEdBQUcsR0FBRztZQUNYVCxRQUFRVSxPQUFPLENBQUMsQ0FBQyxDQUFDTixLQUFLLEdBQUtILE9BQU9VLGNBQWMsQ0FBQyxJQUFJLEVBQUVQLE1BQU07b0JBQzVEUSxLQUFLLElBQU0sSUFBSSxDQUFDcEIsUUFBUSxDQUFDWSxLQUFLLENBQUNDLEtBQUs7b0JBQ3BDUSxLQUFLQyxDQUFBQSxJQUFLLElBQUksQ0FBQ3RCLFFBQVEsQ0FBQ1ksS0FBSyxDQUFDQyxLQUFLLEdBQUdTO2dCQUN4QztZQUVBLGlEQUFpRDtZQUNqRGIsT0FBT2MsTUFBTSxDQUFDLElBQUksRUFBRWhCO1lBQ3BCLGNBQWM7WUFDZCxJQUFJSixRQUFRQSxPQUFPLElBQUk7UUFDekI7SUFDRjtJQUNBQyxTQUFTYSxHQUFHLEdBQUduQiw0Q0FBZSxDQUFDMkIsWUFBWTtJQUMzQyxPQUFPckI7QUFDVDtBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFkZXJNYXRlcmlhbC5qcz83NzgzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcblxuZnVuY3Rpb24gc2hhZGVyTWF0ZXJpYWwodW5pZm9ybXMsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIG9uSW5pdCkge1xuICBjb25zdCBtYXRlcmlhbCA9IGNsYXNzIG1hdGVyaWFsIGV4dGVuZHMgVEhSRUUuU2hhZGVyTWF0ZXJpYWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHVuaWZvcm1zKTtcbiAgICAgIC8vIENyZWF0ZSB1bmZvcm1zIGFuZCBzaGFkZXJzXG4gICAgICBzdXBlcih7XG4gICAgICAgIHVuaWZvcm1zOiBlbnRyaWVzLnJlZHVjZSgoYWNjLCBbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgY29uc3QgdW5pZm9ybSA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoe1xuICAgICAgICAgICAgW25hbWVdOiB7XG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIC4uLnVuaWZvcm1cbiAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSksXG4gICAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJcbiAgICAgIH0pO1xuICAgICAgLy8gQ3JlYXRlIGdldHRlci9zZXR0ZXJzXG4gICAgICB0aGlzLmtleSA9ICcnO1xuICAgICAgZW50cmllcy5mb3JFYWNoKChbbmFtZV0pID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgIGdldDogKCkgPT4gdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZSxcbiAgICAgICAgc2V0OiB2ID0+IHRoaXMudW5pZm9ybXNbbmFtZV0udmFsdWUgPSB2XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIEFzc2lnbiBwYXJhbWV0ZXJzLCB0aGlzIG1pZ2h0IGluY2x1ZGUgdW5pZm9ybXNcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcGFyYW1ldGVycyk7XG4gICAgICAvLyBDYWxsIG9uSW5pdFxuICAgICAgaWYgKG9uSW5pdCkgb25Jbml0KHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgbWF0ZXJpYWwua2V5ID0gVEhSRUUuTWF0aFV0aWxzLmdlbmVyYXRlVVVJRCgpO1xuICByZXR1cm4gbWF0ZXJpYWw7XG59XG5cbmV4cG9ydCB7IHNoYWRlck1hdGVyaWFsIH07XG4iXSwibmFtZXMiOlsiVEhSRUUiLCJzaGFkZXJNYXRlcmlhbCIsInVuaWZvcm1zIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJvbkluaXQiLCJtYXRlcmlhbCIsIlNoYWRlck1hdGVyaWFsIiwiY29uc3RydWN0b3IiLCJwYXJhbWV0ZXJzIiwiZW50cmllcyIsIk9iamVjdCIsInJlZHVjZSIsImFjYyIsIm5hbWUiLCJ2YWx1ZSIsInVuaWZvcm0iLCJVbmlmb3Jtc1V0aWxzIiwiY2xvbmUiLCJrZXkiLCJmb3JFYWNoIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJzZXQiLCJ2IiwiYXNzaWduIiwiTWF0aFV0aWxzIiwiZ2VuZXJhdGVVVUlEIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useEnvironment.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useEnvironment: () => (/* binding */ useEnvironment)\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\");\n/* harmony import */ var _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/environment-assets.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\");\n/* harmony import */ var _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/deprecated.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js\");\n\n\n\n\n\nconst CUBEMAP_ROOT = \"https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/\";\nconst isArray = (arr)=>Array.isArray(arr);\nfunction useEnvironment({ files = [\n    \"/px.png\",\n    \"/nx.png\",\n    \"/py.png\",\n    \"/ny.png\",\n    \"/pz.png\",\n    \"/nz.png\"\n], path = \"\", preset = undefined, encoding = undefined, extensions } = {}) {\n    var _files$split$pop;\n    let loader = null;\n    let isCubeMap = false;\n    let extension;\n    if (preset) {\n        if (!(preset in _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj)) throw new Error(\"Preset must be one of: \" + Object.keys(_helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj).join(\", \"));\n        files = _helpers_environment_assets_js__WEBPACK_IMPORTED_MODULE_0__.presetsObj[preset];\n        path = CUBEMAP_ROOT;\n    }\n    // Everything else\n    isCubeMap = isArray(files);\n    extension = isArray(files) ? \"cube\" : files.startsWith(\"data:application/exr\") ? \"exr\" : files.startsWith(\"data:application/hdr\") ? \"hdr\" : (_files$split$pop = files.split(\".\").pop()) == null || (_files$split$pop = _files$split$pop.split(\"?\")) == null || (_files$split$pop = _files$split$pop.shift()) == null ? void 0 : _files$split$pop.toLowerCase();\n    loader = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeTextureLoader : extension === \"hdr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_2__.RGBELoader : extension === \"exr\" ? three_stdlib__WEBPACK_IMPORTED_MODULE_3__.EXRLoader : null;\n    if (!loader) throw new Error(\"useEnvironment: Unrecognized file extension: \" + files);\n    const loaderResult = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.H)(// @ts-expect-error\n    loader, isCubeMap ? [\n        files\n    ] : files, (loader)=>{\n        loader.setPath == null || loader.setPath(path);\n        if (extensions) extensions(loader);\n    });\n    const texture = isCubeMap ? // @ts-ignore\n    loaderResult[0] : loaderResult;\n    texture.mapping = isCubeMap ? three__WEBPACK_IMPORTED_MODULE_1__.CubeReflectionMapping : three__WEBPACK_IMPORTED_MODULE_1__.EquirectangularReflectionMapping;\n    if (\"colorSpace\" in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? \"srgb\" : \"srgb-linear\";\n    else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubeMap) ? _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_5__.sRGBEncoding : _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_5__.LinearEncoding;\n    return texture;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQStDO0FBQ29EO0FBQzlDO0FBQ1M7QUFDVTtBQUV4RSxNQUFNUyxlQUFlO0FBQ3JCLE1BQU1DLFVBQVVDLENBQUFBLE1BQU9DLE1BQU1GLE9BQU8sQ0FBQ0M7QUFDckMsU0FBU0UsZUFBZSxFQUN0QkMsUUFBUTtJQUFDO0lBQVc7SUFBVztJQUFXO0lBQVc7SUFBVztDQUFVLEVBQzFFQyxPQUFPLEVBQUUsRUFDVEMsU0FBU0MsU0FBUyxFQUNsQkMsV0FBV0QsU0FBUyxFQUNwQkUsVUFBVSxFQUNYLEdBQUcsQ0FBQyxDQUFDO0lBQ0osSUFBSUM7SUFDSixJQUFJQyxTQUFTO0lBQ2IsSUFBSUMsWUFBWTtJQUNoQixJQUFJQztJQUNKLElBQUlQLFFBQVE7UUFDVixJQUFJLENBQUVBLENBQUFBLFVBQVVWLHNFQUFTLEdBQUksTUFBTSxJQUFJa0IsTUFBTSw0QkFBNEJDLE9BQU9DLElBQUksQ0FBQ3BCLHNFQUFVQSxFQUFFcUIsSUFBSSxDQUFDO1FBQ3RHYixRQUFRUixzRUFBVSxDQUFDVSxPQUFPO1FBQzFCRCxPQUFPTjtJQUNUO0lBRUEsa0JBQWtCO0lBQ2xCYSxZQUFZWixRQUFRSTtJQUNwQlMsWUFBWWIsUUFBUUksU0FBUyxTQUFTQSxNQUFNYyxVQUFVLENBQUMsMEJBQTBCLFFBQVFkLE1BQU1jLFVBQVUsQ0FBQywwQkFBMEIsUUFBUSxDQUFDUixtQkFBbUJOLE1BQU1lLEtBQUssQ0FBQyxLQUFLQyxHQUFHLEVBQUMsS0FBTSxRQUFRLENBQUNWLG1CQUFtQkEsaUJBQWlCUyxLQUFLLENBQUMsSUFBRyxLQUFNLFFBQVEsQ0FBQ1QsbUJBQW1CQSxpQkFBaUJXLEtBQUssRUFBQyxLQUFNLE9BQU8sS0FBSyxJQUFJWCxpQkFBaUJZLFdBQVc7SUFDNVZYLFNBQVNDLFlBQVluQixvREFBaUJBLEdBQUdvQixjQUFjLFFBQVFuQixvREFBVUEsR0FBR21CLGNBQWMsUUFBUWxCLG1EQUFTQSxHQUFHO0lBQzlHLElBQUksQ0FBQ2dCLFFBQVEsTUFBTSxJQUFJRyxNQUFNLGtEQUFrRFY7SUFDL0UsTUFBTW1CLGVBQWVqQyxxREFBU0EsQ0FDOUIsbUJBQW1CO0lBQ25CcUIsUUFBUUMsWUFBWTtRQUFDUjtLQUFNLEdBQUdBLE9BQU9PLENBQUFBO1FBQ25DQSxPQUFPYSxPQUFPLElBQUksUUFBUWIsT0FBT2EsT0FBTyxDQUFDbkI7UUFDekMsSUFBSUksWUFBWUEsV0FBV0U7SUFDN0I7SUFDQSxNQUFNYyxVQUFVYixZQUNoQixhQUFhO0lBQ2JXLFlBQVksQ0FBQyxFQUFFLEdBQUdBO0lBQ2xCRSxRQUFRQyxPQUFPLEdBQUdkLFlBQVlyQix3REFBcUJBLEdBQUdDLG1FQUFnQ0E7SUFDdEYsSUFBSSxnQkFBZ0JpQyxTQUFTQSxRQUFRRSxVQUFVLEdBQUcsQ0FBQ25CLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVdJLFNBQVEsSUFBSyxTQUFTO1NBQW1CYSxRQUFRakIsUUFBUSxHQUFHLENBQUNBLGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUlBLFdBQVdJLFNBQVEsSUFBS2YsZ0VBQVlBLEdBQUdDLGtFQUFjQTtJQUN0USxPQUFPMkI7QUFDVDtBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VFbnZpcm9ubWVudC5qcz83MGM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUxvYWRlciB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBDdWJlUmVmbGVjdGlvbk1hcHBpbmcsIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nLCBDdWJlVGV4dHVyZUxvYWRlciB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFJHQkVMb2FkZXIsIEVYUkxvYWRlciB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5pbXBvcnQgeyBwcmVzZXRzT2JqIH0gZnJvbSAnLi4vaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMnO1xuaW1wb3J0IHsgc1JHQkVuY29kaW5nLCBMaW5lYXJFbmNvZGluZyB9IGZyb20gJy4uL2hlbHBlcnMvZGVwcmVjYXRlZC5qcyc7XG5cbmNvbnN0IENVQkVNQVBfUk9PVCA9ICdodHRwczovL3Jhdy5naXRoYWNrLmNvbS9wbW5kcnMvZHJlaS1hc3NldHMvNDU2MDYwYTI2YmJlYjhmZGY3OTMyNmYyMjRiNmQ5OWI4YmNjZTczNi9oZHJpLyc7XG5jb25zdCBpc0FycmF5ID0gYXJyID0+IEFycmF5LmlzQXJyYXkoYXJyKTtcbmZ1bmN0aW9uIHVzZUVudmlyb25tZW50KHtcbiAgZmlsZXMgPSBbJy9weC5wbmcnLCAnL254LnBuZycsICcvcHkucG5nJywgJy9ueS5wbmcnLCAnL3B6LnBuZycsICcvbnoucG5nJ10sXG4gIHBhdGggPSAnJyxcbiAgcHJlc2V0ID0gdW5kZWZpbmVkLFxuICBlbmNvZGluZyA9IHVuZGVmaW5lZCxcbiAgZXh0ZW5zaW9uc1xufSA9IHt9KSB7XG4gIHZhciBfZmlsZXMkc3BsaXQkcG9wO1xuICBsZXQgbG9hZGVyID0gbnVsbDtcbiAgbGV0IGlzQ3ViZU1hcCA9IGZhbHNlO1xuICBsZXQgZXh0ZW5zaW9uO1xuICBpZiAocHJlc2V0KSB7XG4gICAgaWYgKCEocHJlc2V0IGluIHByZXNldHNPYmopKSB0aHJvdyBuZXcgRXJyb3IoJ1ByZXNldCBtdXN0IGJlIG9uZSBvZjogJyArIE9iamVjdC5rZXlzKHByZXNldHNPYmopLmpvaW4oJywgJykpO1xuICAgIGZpbGVzID0gcHJlc2V0c09ialtwcmVzZXRdO1xuICAgIHBhdGggPSBDVUJFTUFQX1JPT1Q7XG4gIH1cblxuICAvLyBFdmVyeXRoaW5nIGVsc2VcbiAgaXNDdWJlTWFwID0gaXNBcnJheShmaWxlcyk7XG4gIGV4dGVuc2lvbiA9IGlzQXJyYXkoZmlsZXMpID8gJ2N1YmUnIDogZmlsZXMuc3RhcnRzV2l0aCgnZGF0YTphcHBsaWNhdGlvbi9leHInKSA/ICdleHInIDogZmlsZXMuc3RhcnRzV2l0aCgnZGF0YTphcHBsaWNhdGlvbi9oZHInKSA/ICdoZHInIDogKF9maWxlcyRzcGxpdCRwb3AgPSBmaWxlcy5zcGxpdCgnLicpLnBvcCgpKSA9PSBudWxsIHx8IChfZmlsZXMkc3BsaXQkcG9wID0gX2ZpbGVzJHNwbGl0JHBvcC5zcGxpdCgnPycpKSA9PSBudWxsIHx8IChfZmlsZXMkc3BsaXQkcG9wID0gX2ZpbGVzJHNwbGl0JHBvcC5zaGlmdCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2ZpbGVzJHNwbGl0JHBvcC50b0xvd2VyQ2FzZSgpO1xuICBsb2FkZXIgPSBpc0N1YmVNYXAgPyBDdWJlVGV4dHVyZUxvYWRlciA6IGV4dGVuc2lvbiA9PT0gJ2hkcicgPyBSR0JFTG9hZGVyIDogZXh0ZW5zaW9uID09PSAnZXhyJyA/IEVYUkxvYWRlciA6IG51bGw7XG4gIGlmICghbG9hZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUVudmlyb25tZW50OiBVbnJlY29nbml6ZWQgZmlsZSBleHRlbnNpb246ICcgKyBmaWxlcyk7XG4gIGNvbnN0IGxvYWRlclJlc3VsdCA9IHVzZUxvYWRlcihcbiAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICBsb2FkZXIsIGlzQ3ViZU1hcCA/IFtmaWxlc10gOiBmaWxlcywgbG9hZGVyID0+IHtcbiAgICBsb2FkZXIuc2V0UGF0aCA9PSBudWxsIHx8IGxvYWRlci5zZXRQYXRoKHBhdGgpO1xuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gIH0pO1xuICBjb25zdCB0ZXh0dXJlID0gaXNDdWJlTWFwID9cbiAgLy8gQHRzLWlnbm9yZVxuICBsb2FkZXJSZXN1bHRbMF0gOiBsb2FkZXJSZXN1bHQ7XG4gIHRleHR1cmUubWFwcGluZyA9IGlzQ3ViZU1hcCA/IEN1YmVSZWZsZWN0aW9uTWFwcGluZyA6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nO1xuICBpZiAoJ2NvbG9yU3BhY2UnIGluIHRleHR1cmUpIHRleHR1cmUuY29sb3JTcGFjZSA9IChlbmNvZGluZyAhPT0gbnVsbCAmJiBlbmNvZGluZyAhPT0gdm9pZCAwID8gZW5jb2RpbmcgOiBpc0N1YmVNYXApID8gJ3NyZ2InIDogJ3NyZ2ItbGluZWFyJztlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSAoZW5jb2RpbmcgIT09IG51bGwgJiYgZW5jb2RpbmcgIT09IHZvaWQgMCA/IGVuY29kaW5nIDogaXNDdWJlTWFwKSA/IHNSR0JFbmNvZGluZyA6IExpbmVhckVuY29kaW5nO1xuICByZXR1cm4gdGV4dHVyZTtcbn1cblxuZXhwb3J0IHsgdXNlRW52aXJvbm1lbnQgfTtcbiJdLCJuYW1lcyI6WyJ1c2VMb2FkZXIiLCJDdWJlUmVmbGVjdGlvbk1hcHBpbmciLCJFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyIsIkN1YmVUZXh0dXJlTG9hZGVyIiwiUkdCRUxvYWRlciIsIkVYUkxvYWRlciIsInByZXNldHNPYmoiLCJzUkdCRW5jb2RpbmciLCJMaW5lYXJFbmNvZGluZyIsIkNVQkVNQVBfUk9PVCIsImlzQXJyYXkiLCJhcnIiLCJBcnJheSIsInVzZUVudmlyb25tZW50IiwiZmlsZXMiLCJwYXRoIiwicHJlc2V0IiwidW5kZWZpbmVkIiwiZW5jb2RpbmciLCJleHRlbnNpb25zIiwiX2ZpbGVzJHNwbGl0JHBvcCIsImxvYWRlciIsImlzQ3ViZU1hcCIsImV4dGVuc2lvbiIsIkVycm9yIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJzdGFydHNXaXRoIiwic3BsaXQiLCJwb3AiLCJzaGlmdCIsInRvTG93ZXJDYXNlIiwibG9hZGVyUmVzdWx0Iiwic2V0UGF0aCIsInRleHR1cmUiLCJtYXBwaW5nIiwiY29sb3JTcGFjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useEnvironment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useGLTF.js":
/*!********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useGLTF.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useGLTF: () => (/* binding */ useGLTF)\n/* harmony export */ });\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/DRACOLoader.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/libs/MeshoptDecoder.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/loaders/GLTFLoader.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n\n\nlet dracoLoader = null;\nlet decoderPath = \"https://www.gstatic.com/draco/versioned/decoders/1.5.5/\";\nfunction extensions(useDraco, useMeshopt, extendLoader) {\n    return (loader)=>{\n        if (extendLoader) {\n            extendLoader(loader);\n        }\n        if (useDraco) {\n            if (!dracoLoader) {\n                dracoLoader = new three_stdlib__WEBPACK_IMPORTED_MODULE_0__.DRACOLoader();\n            }\n            dracoLoader.setDecoderPath(typeof useDraco === \"string\" ? useDraco : decoderPath);\n            loader.setDRACOLoader(dracoLoader);\n        }\n        if (useMeshopt) {\n            loader.setMeshoptDecoder(typeof three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder === \"function\" ? (0,three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder)() : three_stdlib__WEBPACK_IMPORTED_MODULE_1__.MeshoptDecoder);\n        }\n    };\n}\nfunction useGLTF(path, useDraco = true, useMeshOpt = true, extendLoader) {\n    return (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.H)(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\n}\nuseGLTF.preload = (path, useDraco = true, useMeshOpt = true, extendLoader)=>_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.H.preload(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, path, extensions(useDraco, useMeshOpt, extendLoader));\nuseGLTF.clear = (input)=>_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.H.clear(three_stdlib__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader, input);\nuseGLTF.setDecoderPath = (path)=>{\n    decoderPath = path;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VHTFRGLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVFO0FBQ3hCO0FBRS9DLElBQUlJLGNBQWM7QUFDbEIsSUFBSUMsY0FBYztBQUNsQixTQUFTQyxXQUFXQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsWUFBWTtJQUNwRCxPQUFPQyxDQUFBQTtRQUNMLElBQUlELGNBQWM7WUFDaEJBLGFBQWFDO1FBQ2Y7UUFDQSxJQUFJSCxVQUFVO1lBQ1osSUFBSSxDQUFDSCxhQUFhO2dCQUNoQkEsY0FBYyxJQUFJSCxxREFBV0E7WUFDL0I7WUFDQUcsWUFBWU8sY0FBYyxDQUFDLE9BQU9KLGFBQWEsV0FBV0EsV0FBV0Y7WUFDckVLLE9BQU9FLGNBQWMsQ0FBQ1I7UUFDeEI7UUFDQSxJQUFJSSxZQUFZO1lBQ2RFLE9BQU9HLGlCQUFpQixDQUFDLE9BQU9YLHdEQUFjQSxLQUFLLGFBQWFBLDREQUFjQSxLQUFLQSx3REFBY0E7UUFDbkc7SUFDRjtBQUNGO0FBQ0EsU0FBU1ksUUFBUUMsSUFBSSxFQUFFUixXQUFXLElBQUksRUFBRVMsYUFBYSxJQUFJLEVBQUVQLFlBQVk7SUFDckUsT0FBT04scURBQVNBLENBQUNILG9EQUFVQSxFQUFFZSxNQUFNVCxXQUFXQyxVQUFVUyxZQUFZUDtBQUN0RTtBQUNBSyxRQUFRRyxPQUFPLEdBQUcsQ0FBQ0YsTUFBTVIsV0FBVyxJQUFJLEVBQUVTLGFBQWEsSUFBSSxFQUFFUCxlQUFpQk4saURBQVNBLENBQUNjLE9BQU8sQ0FBQ2pCLG9EQUFVQSxFQUFFZSxNQUFNVCxXQUFXQyxVQUFVUyxZQUFZUDtBQUNuSkssUUFBUUksS0FBSyxHQUFHQyxDQUFBQSxRQUFTaEIsaURBQVNBLENBQUNlLEtBQUssQ0FBQ2xCLG9EQUFVQSxFQUFFbUI7QUFDckRMLFFBQVFILGNBQWMsR0FBR0ksQ0FBQUE7SUFDdkJWLGNBQWNVO0FBQ2hCO0FBRW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL3VzZUdMVEYuanM/MTExNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBHTFRGTG9hZGVyLCBEUkFDT0xvYWRlciwgTWVzaG9wdERlY29kZXIgfSBmcm9tICd0aHJlZS1zdGRsaWInO1xuaW1wb3J0IHsgdXNlTG9hZGVyIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcblxubGV0IGRyYWNvTG9hZGVyID0gbnVsbDtcbmxldCBkZWNvZGVyUGF0aCA9ICdodHRwczovL3d3dy5nc3RhdGljLmNvbS9kcmFjby92ZXJzaW9uZWQvZGVjb2RlcnMvMS41LjUvJztcbmZ1bmN0aW9uIGV4dGVuc2lvbnModXNlRHJhY28sIHVzZU1lc2hvcHQsIGV4dGVuZExvYWRlcikge1xuICByZXR1cm4gbG9hZGVyID0+IHtcbiAgICBpZiAoZXh0ZW5kTG9hZGVyKSB7XG4gICAgICBleHRlbmRMb2FkZXIobG9hZGVyKTtcbiAgICB9XG4gICAgaWYgKHVzZURyYWNvKSB7XG4gICAgICBpZiAoIWRyYWNvTG9hZGVyKSB7XG4gICAgICAgIGRyYWNvTG9hZGVyID0gbmV3IERSQUNPTG9hZGVyKCk7XG4gICAgICB9XG4gICAgICBkcmFjb0xvYWRlci5zZXREZWNvZGVyUGF0aCh0eXBlb2YgdXNlRHJhY28gPT09ICdzdHJpbmcnID8gdXNlRHJhY28gOiBkZWNvZGVyUGF0aCk7XG4gICAgICBsb2FkZXIuc2V0RFJBQ09Mb2FkZXIoZHJhY29Mb2FkZXIpO1xuICAgIH1cbiAgICBpZiAodXNlTWVzaG9wdCkge1xuICAgICAgbG9hZGVyLnNldE1lc2hvcHREZWNvZGVyKHR5cGVvZiBNZXNob3B0RGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IE1lc2hvcHREZWNvZGVyKCkgOiBNZXNob3B0RGVjb2Rlcik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdXNlR0xURihwYXRoLCB1c2VEcmFjbyA9IHRydWUsIHVzZU1lc2hPcHQgPSB0cnVlLCBleHRlbmRMb2FkZXIpIHtcbiAgcmV0dXJuIHVzZUxvYWRlcihHTFRGTG9hZGVyLCBwYXRoLCBleHRlbnNpb25zKHVzZURyYWNvLCB1c2VNZXNoT3B0LCBleHRlbmRMb2FkZXIpKTtcbn1cbnVzZUdMVEYucHJlbG9hZCA9IChwYXRoLCB1c2VEcmFjbyA9IHRydWUsIHVzZU1lc2hPcHQgPSB0cnVlLCBleHRlbmRMb2FkZXIpID0+IHVzZUxvYWRlci5wcmVsb2FkKEdMVEZMb2FkZXIsIHBhdGgsIGV4dGVuc2lvbnModXNlRHJhY28sIHVzZU1lc2hPcHQsIGV4dGVuZExvYWRlcikpO1xudXNlR0xURi5jbGVhciA9IGlucHV0ID0+IHVzZUxvYWRlci5jbGVhcihHTFRGTG9hZGVyLCBpbnB1dCk7XG51c2VHTFRGLnNldERlY29kZXJQYXRoID0gcGF0aCA9PiB7XG4gIGRlY29kZXJQYXRoID0gcGF0aDtcbn07XG5cbmV4cG9ydCB7IHVzZUdMVEYgfTtcbiJdLCJuYW1lcyI6WyJHTFRGTG9hZGVyIiwiRFJBQ09Mb2FkZXIiLCJNZXNob3B0RGVjb2RlciIsInVzZUxvYWRlciIsImRyYWNvTG9hZGVyIiwiZGVjb2RlclBhdGgiLCJleHRlbnNpb25zIiwidXNlRHJhY28iLCJ1c2VNZXNob3B0IiwiZXh0ZW5kTG9hZGVyIiwibG9hZGVyIiwic2V0RGVjb2RlclBhdGgiLCJzZXREUkFDT0xvYWRlciIsInNldE1lc2hvcHREZWNvZGVyIiwidXNlR0xURiIsInBhdGgiLCJ1c2VNZXNoT3B0IiwicHJlbG9hZCIsImNsZWFyIiwiaW5wdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useGLTF.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst getVersion = ()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nconst version = /* @__PURE__ */ getVersion();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFFakMsTUFBTUMsYUFBYSxJQUFNQyxTQUFTRiwyQ0FBUUEsQ0FBQ0csT0FBTyxDQUFDLFFBQVE7QUFDM0QsTUFBTUMsVUFBVSxhQUFhLEdBQUVIO0FBRVoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvY29uc3RhbnRzLmpzPzUwOTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUkVWSVNJT04gfSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IGdldFZlcnNpb24gPSAoKSA9PiBwYXJzZUludChSRVZJU0lPTi5yZXBsYWNlKC9cXEQrL2csICcnKSk7XG5jb25zdCB2ZXJzaW9uID0gLyogQF9fUFVSRV9fICovZ2V0VmVyc2lvbigpO1xuXG5leHBvcnQgeyB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOlsiUkVWSVNJT04iLCJnZXRWZXJzaW9uIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwidmVyc2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/deprecated.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinearEncoding: () => (/* binding */ LinearEncoding),\n/* harmony export */   sRGBEncoding: () => (/* binding */ sRGBEncoding),\n/* harmony export */   setUpdateRange: () => (/* binding */ setUpdateRange)\n/* harmony export */ });\n/**\n * Sets `BufferAttribute.updateRange` since r159.\n */ const setUpdateRange = (attribute, updateRange)=>{\n    if (\"updateRanges\" in attribute) {\n        // r159\n        // @ts-ignore\n        attribute.updateRanges[0] = updateRange;\n    } else {\n        attribute.updateRange = updateRange;\n    }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9kZXByZWNhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBQ0QsTUFBTUEsaUJBQWlCLENBQUNDLFdBQVdDO0lBQ2pDLElBQUksa0JBQWtCRCxXQUFXO1FBQy9CLE9BQU87UUFDUCxhQUFhO1FBQ2JBLFVBQVVFLFlBQVksQ0FBQyxFQUFFLEdBQUdEO0lBQzlCLE9BQU87UUFDTEQsVUFBVUMsV0FBVyxHQUFHQTtJQUMxQjtBQUNGO0FBQ0EsTUFBTUUsaUJBQWlCO0FBQ3ZCLE1BQU1DLGVBQWU7QUFFckI7O0NBRUMsR0FFdUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvZGVwcmVjYXRlZC5qcz9lMDA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2V0cyBgQnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlYCBzaW5jZSByMTU5LlxuICovXG5jb25zdCBzZXRVcGRhdGVSYW5nZSA9IChhdHRyaWJ1dGUsIHVwZGF0ZVJhbmdlKSA9PiB7XG4gIGlmICgndXBkYXRlUmFuZ2VzJyBpbiBhdHRyaWJ1dGUpIHtcbiAgICAvLyByMTU5XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGF0dHJpYnV0ZS51cGRhdGVSYW5nZXNbMF0gPSB1cGRhdGVSYW5nZTtcbiAgfSBlbHNlIHtcbiAgICBhdHRyaWJ1dGUudXBkYXRlUmFuZ2UgPSB1cGRhdGVSYW5nZTtcbiAgfVxufTtcbmNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbmNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5cbi8qKlxuICogVGV4dHVyZUVuY29kaW5nIHdhcyBkZXByZWNhdGVkIGluIHIxNTIsIGFuZCByZW1vdmVkIGluIHIxNjIuXG4gKi9cblxuZXhwb3J0IHsgTGluZWFyRW5jb2RpbmcsIHNSR0JFbmNvZGluZywgc2V0VXBkYXRlUmFuZ2UgfTtcbiJdLCJuYW1lcyI6WyJzZXRVcGRhdGVSYW5nZSIsImF0dHJpYnV0ZSIsInVwZGF0ZVJhbmdlIiwidXBkYXRlUmFuZ2VzIiwiTGluZWFyRW5jb2RpbmciLCJzUkdCRW5jb2RpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/deprecated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/environment-assets.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   presetsObj: () => (/* binding */ presetsObj)\n/* harmony export */ });\nconst presetsObj = {\n    apartment: \"lebombo_1k.hdr\",\n    city: \"potsdamer_platz_1k.hdr\",\n    dawn: \"kiara_1_dawn_1k.hdr\",\n    forest: \"forest_slope_1k.hdr\",\n    lobby: \"st_fagans_interior_1k.hdr\",\n    night: \"dikhololo_night_1k.hdr\",\n    park: \"rooitou_park_1k.hdr\",\n    studio: \"studio_small_03_1k.hdr\",\n    sunset: \"venice_sunset_1k.hdr\",\n    warehouse: \"empty_warehouse_01_1k.hdr\"\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLGFBQWE7SUFDakJDLFdBQVc7SUFDWEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFdBQVc7QUFDYjtBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9lbnZpcm9ubWVudC1hc3NldHMuanM/MTY1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwcmVzZXRzT2JqID0ge1xuICBhcGFydG1lbnQ6ICdsZWJvbWJvXzFrLmhkcicsXG4gIGNpdHk6ICdwb3RzZGFtZXJfcGxhdHpfMWsuaGRyJyxcbiAgZGF3bjogJ2tpYXJhXzFfZGF3bl8xay5oZHInLFxuICBmb3Jlc3Q6ICdmb3Jlc3Rfc2xvcGVfMWsuaGRyJyxcbiAgbG9iYnk6ICdzdF9mYWdhbnNfaW50ZXJpb3JfMWsuaGRyJyxcbiAgbmlnaHQ6ICdkaWtob2xvbG9fbmlnaHRfMWsuaGRyJyxcbiAgcGFyazogJ3Jvb2l0b3VfcGFya18xay5oZHInLFxuICBzdHVkaW86ICdzdHVkaW9fc21hbGxfMDNfMWsuaGRyJyxcbiAgc3Vuc2V0OiAndmVuaWNlX3N1bnNldF8xay5oZHInLFxuICB3YXJlaG91c2U6ICdlbXB0eV93YXJlaG91c2VfMDFfMWsuaGRyJ1xufTtcblxuZXhwb3J0IHsgcHJlc2V0c09iaiB9O1xuIl0sIm5hbWVzIjpbInByZXNldHNPYmoiLCJhcGFydG1lbnQiLCJjaXR5IiwiZGF3biIsImZvcmVzdCIsImxvYmJ5IiwibmlnaHQiLCJwYXJrIiwic3R1ZGlvIiwic3Vuc2V0Iiwid2FyZWhvdXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/environment-assets.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/materials/DiscardMaterial.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/drei/materials/DiscardMaterial.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DiscardMaterial: () => (/* binding */ DiscardMaterial)\n/* harmony export */ });\n/* harmony import */ var _core_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/shaderMaterial.js */ \"(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n\nconst DiscardMaterial = /* @__PURE__ */ (0,_core_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__.shaderMaterial)({}, \"void main() { }\", \"void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbWF0ZXJpYWxzL0Rpc2NhcmRNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyRDtBQUUzRCxNQUFNQyxrQkFBa0IsYUFBYSxHQUFFRCx1RUFBY0EsQ0FBQyxDQUFDLEdBQUcsbUJBQW1CO0FBRWxEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9tYXRlcmlhbHMvRGlzY2FyZE1hdGVyaWFsLmpzPzEzNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICcuLi9jb3JlL3NoYWRlck1hdGVyaWFsLmpzJztcblxuY29uc3QgRGlzY2FyZE1hdGVyaWFsID0gLyogQF9fUFVSRV9fICovc2hhZGVyTWF0ZXJpYWwoe30sICd2b2lkIG1haW4oKSB7IH0nLCAndm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7IGRpc2NhcmQ7ICB9Jyk7XG5cbmV4cG9ydCB7IERpc2NhcmRNYXRlcmlhbCB9O1xuIl0sIm5hbWVzIjpbInNoYWRlck1hdGVyaWFsIiwiRGlzY2FyZE1hdGVyaWFsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/materials/DiscardMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/web/PresentationControls.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/drei/web/PresentationControls.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PresentationControls: () => (/* binding */ PresentationControls)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var _react_spring_three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-spring/three */ \"(ssr)/./node_modules/@react-spring/three/dist/react-spring-three.esm.js\");\n/* harmony import */ var _use_gesture_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @use-gesture/react */ \"(ssr)/./node_modules/@use-gesture/react/dist/use-gesture-react.esm.js\");\n\n\n\n\n\n\nfunction PresentationControls({ enabled = true, snap, global, domElement, cursor = true, children, speed = 1, rotation = [\n    0,\n    0,\n    0\n], zoom = 1, polar = [\n    0,\n    Math.PI / 2\n], azimuth = [\n    -Infinity,\n    Infinity\n], config = {\n    mass: 1,\n    tension: 170,\n    friction: 26\n} }) {\n    const events = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)((state)=>state.events);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)((state)=>state.gl);\n    const explDomElement = domElement || events.connected || gl.domElement;\n    const { size } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.D)();\n    const rPolar = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            rotation[0] + polar[0],\n            rotation[0] + polar[1]\n        ], [\n        rotation[0],\n        polar[0],\n        polar[1]\n    ]);\n    const rAzimuth = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            rotation[1] + azimuth[0],\n            rotation[1] + azimuth[1]\n        ], [\n        rotation[1],\n        azimuth[0],\n        azimuth[1]\n    ]);\n    const rInitial = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>[\n            three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.clamp(rotation[0], ...rPolar),\n            three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.clamp(rotation[1], ...rAzimuth),\n            rotation[2]\n        ], [\n        rotation[0],\n        rotation[1],\n        rotation[2],\n        rPolar,\n        rAzimuth\n    ]);\n    const [spring, api] = (0,_react_spring_three__WEBPACK_IMPORTED_MODULE_2__.useSpring)(()=>({\n            scale: 1,\n            rotation: rInitial,\n            config\n        }));\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>void api.start({\n            scale: 1,\n            rotation: rInitial,\n            config\n        }), [\n        rInitial\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (global && cursor && enabled) {\n            explDomElement.style.cursor = \"grab\";\n            gl.domElement.style.cursor = \"\";\n            return ()=>{\n                explDomElement.style.cursor = \"default\";\n                gl.domElement.style.cursor = \"default\";\n            };\n        }\n    }, [\n        global,\n        cursor,\n        explDomElement,\n        enabled\n    ]);\n    const bind = (0,_use_gesture_react__WEBPACK_IMPORTED_MODULE_5__.useGesture)({\n        onHover: ({ last })=>{\n            if (cursor && !global && enabled) explDomElement.style.cursor = last ? \"auto\" : \"grab\";\n        },\n        onDrag: ({ down, delta: [x, y], memo: [oldY, oldX] = spring.rotation.animation.to || rInitial })=>{\n            if (!enabled) return [\n                y,\n                x\n            ];\n            if (cursor) explDomElement.style.cursor = down ? \"grabbing\" : \"grab\";\n            x = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.clamp(oldX + x / size.width * Math.PI * speed, ...rAzimuth);\n            y = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.clamp(oldY + y / size.height * Math.PI * speed, ...rPolar);\n            const sConfig = snap && !down && typeof snap !== \"boolean\" ? snap : config;\n            api.start({\n                scale: down && y > rPolar[1] / 2 ? zoom : 1,\n                rotation: snap && !down ? rInitial : [\n                    y,\n                    x,\n                    0\n                ],\n                config: (n)=>n === \"scale\" ? {\n                        ...sConfig,\n                        friction: sConfig.friction * 3\n                    } : sConfig\n            });\n            return [\n                y,\n                x\n            ];\n        }\n    }, {\n        target: global ? explDomElement : undefined\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(_react_spring_three__WEBPACK_IMPORTED_MODULE_2__.a.group, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, bind == null ? void 0 : bind(), spring), children);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvd2ViL1ByZXNlbnRhdGlvbkNvbnRyb2xzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ0c7QUFDWTtBQUNLO0FBQ0g7QUFFaEQsU0FBU08scUJBQXFCLEVBQzVCQyxVQUFVLElBQUksRUFDZEMsSUFBSSxFQUNKQyxNQUFNLEVBQ05DLFVBQVUsRUFDVkMsU0FBUyxJQUFJLEVBQ2JDLFFBQVEsRUFDUkMsUUFBUSxDQUFDLEVBQ1RDLFdBQVc7SUFBQztJQUFHO0lBQUc7Q0FBRSxFQUNwQkMsT0FBTyxDQUFDLEVBQ1JDLFFBQVE7SUFBQztJQUFHQyxLQUFLQyxFQUFFLEdBQUc7Q0FBRSxFQUN4QkMsVUFBVTtJQUFDLENBQUNDO0lBQVVBO0NBQVMsRUFDL0JDLFNBQVM7SUFDUEMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFVBQVU7QUFDWixDQUFDLEVBQ0Y7SUFDQyxNQUFNQyxTQUFTdkIscURBQVFBLENBQUN3QixDQUFBQSxRQUFTQSxNQUFNRCxNQUFNO0lBQzdDLE1BQU1FLEtBQUt6QixxREFBUUEsQ0FBQ3dCLENBQUFBLFFBQVNBLE1BQU1DLEVBQUU7SUFDckMsTUFBTUMsaUJBQWlCbEIsY0FBY2UsT0FBT0ksU0FBUyxJQUFJRixHQUFHakIsVUFBVTtJQUN0RSxNQUFNLEVBQ0pvQixJQUFJLEVBQ0wsR0FBRzVCLHFEQUFRQTtJQUNaLE1BQU02QixTQUFTL0IsMENBQWEsQ0FBQyxJQUFNO1lBQUNjLFFBQVEsQ0FBQyxFQUFFLEdBQUdFLEtBQUssQ0FBQyxFQUFFO1lBQUVGLFFBQVEsQ0FBQyxFQUFFLEdBQUdFLEtBQUssQ0FBQyxFQUFFO1NBQUMsRUFBRTtRQUFDRixRQUFRLENBQUMsRUFBRTtRQUFFRSxLQUFLLENBQUMsRUFBRTtRQUFFQSxLQUFLLENBQUMsRUFBRTtLQUFDO0lBQ3RILE1BQU1pQixXQUFXakMsMENBQWEsQ0FBQyxJQUFNO1lBQUNjLFFBQVEsQ0FBQyxF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YUFBRTtRQUNmO0lBQ0YsR0FBRztRQUNEVyxRQUFRbEQsU0FBU21CLGlCQUFpQmdDO0lBQ3BDO0lBQ0EsT0FBTyxXQUFXLEdBQUU1RCxnREFBbUIsQ0FBQ0ksa0RBQUNBLENBQUMwRCxLQUFLLEVBQUUvRCw4RUFBUUEsQ0FBQyxDQUFDLEdBQUcyQyxRQUFRLE9BQU8sS0FBSyxJQUFJQSxRQUFRTixTQUFTeEI7QUFDekc7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmFibG8tc3R1ZGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL3dlYi9QcmVzZW50YXRpb25Db250cm9scy5qcz8wNjFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1hdGhVdGlscyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IHVzZVNwcmluZywgYSB9IGZyb20gJ0ByZWFjdC1zcHJpbmcvdGhyZWUnO1xuaW1wb3J0IHsgdXNlR2VzdHVyZSB9IGZyb20gJ0B1c2UtZ2VzdHVyZS9yZWFjdCc7XG5cbmZ1bmN0aW9uIFByZXNlbnRhdGlvbkNvbnRyb2xzKHtcbiAgZW5hYmxlZCA9IHRydWUsXG4gIHNuYXAsXG4gIGdsb2JhbCxcbiAgZG9tRWxlbWVudCxcbiAgY3Vyc29yID0gdHJ1ZSxcbiAgY2hpbGRyZW4sXG4gIHNwZWVkID0gMSxcbiAgcm90YXRpb24gPSBbMCwgMCwgMF0sXG4gIHpvb20gPSAxLFxuICBwb2xhciA9IFswLCBNYXRoLlBJIC8gMl0sXG4gIGF6aW11dGggPSBbLUluZmluaXR5LCBJbmZpbml0eV0sXG4gIGNvbmZpZyA9IHtcbiAgICBtYXNzOiAxLFxuICAgIHRlbnNpb246IDE3MCxcbiAgICBmcmljdGlvbjogMjZcbiAgfVxufSkge1xuICBjb25zdCBldmVudHMgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5ldmVudHMpO1xuICBjb25zdCBnbCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmdsKTtcbiAgY29uc3QgZXhwbERvbUVsZW1lbnQgPSBkb21FbGVtZW50IHx8IGV2ZW50cy5jb25uZWN0ZWQgfHwgZ2wuZG9tRWxlbWVudDtcbiAgY29uc3Qge1xuICAgIHNpemVcbiAgfSA9IHVzZVRocmVlKCk7XG4gIGNvbnN0IHJQb2xhciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gW3JvdGF0aW9uWzBdICsgcG9sYXJbMF0sIHJvdGF0aW9uWzBdICsgcG9sYXJbMV1dLCBbcm90YXRpb25bMF0sIHBvbGFyWzBdLCBwb2xhclsxXV0pO1xuICBjb25zdCByQXppbXV0aCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gW3JvdGF0aW9uWzFdICsgYXppbXV0aFswXSwgcm90YXRpb25bMV0gKyBhemltdXRoWzFdXSwgW3JvdGF0aW9uWzFdLCBhemltdXRoWzBdLCBhemltdXRoWzFdXSk7XG4gIGNvbnN0IHJJbml0aWFsID0gUmVhY3QudXNlTWVtbygoKSA9PiBbTWF0aFV0aWxzLmNsYW1wKHJvdGF0aW9uWzBdLCAuLi5yUG9sYXIpLCBNYXRoVXRpbHMuY2xhbXAocm90YXRpb25bMV0sIC4uLnJBemltdXRoKSwgcm90YXRpb25bMl1dLCBbcm90YXRpb25bMF0sIHJvdGF0aW9uWzFdLCByb3RhdGlvblsyXSwgclBvbGFyLCByQXppbXV0aF0pO1xuICBjb25zdCBbc3ByaW5nLCBhcGldID0gdXNlU3ByaW5nKCgpID0+ICh7XG4gICAgc2NhbGU6IDEsXG4gICAgcm90YXRpb246IHJJbml0aWFsLFxuICAgIGNvbmZpZ1xuICB9KSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB2b2lkIGFwaS5zdGFydCh7XG4gICAgc2NhbGU6IDEsXG4gICAgcm90YXRpb246IHJJbml0aWFsLFxuICAgIGNvbmZpZ1xuICB9KSwgW3JJbml0aWFsXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGdsb2JhbCAmJiBjdXJzb3IgJiYgZW5hYmxlZCkge1xuICAgICAgZXhwbERvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gJ2dyYWInO1xuICAgICAgZ2wuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGV4cGxEb21FbGVtZW50LnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgZ2wuZG9tRWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2dsb2JhbCwgY3Vyc29yLCBleHBsRG9tRWxlbWVudCwgZW5hYmxlZF0pO1xuICBjb25zdCBiaW5kID0gdXNlR2VzdHVyZSh7XG4gICAgb25Ib3ZlcjogKHtcbiAgICAgIGxhc3RcbiAgICB9KSA9PiB7XG4gICAgICBpZiAoY3Vyc29yICYmICFnbG9iYWwgJiYgZW5hYmxlZCkgZXhwbERvbUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gbGFzdCA/ICdhdXRvJyA6ICdncmFiJztcbiAgICB9LFxuICAgIG9uRHJhZzogKHtcbiAgICAgIGRvd24sXG4gICAgICBkZWx0YTogW3gsIHldLFxuICAgICAgbWVtbzogW29sZFksIG9sZFhdID0gc3ByaW5nLnJvdGF0aW9uLmFuaW1hdGlvbi50byB8fCBySW5pdGlhbFxuICAgIH0pID0+IHtcbiAgICAgIGlmICghZW5hYmxlZCkgcmV0dXJuIFt5LCB4XTtcbiAgICAgIGlmIChjdXJzb3IpIGV4cGxEb21FbGVtZW50LnN0eWxlLmN1cnNvciA9IGRvd24gPyAnZ3JhYmJpbmcnIDogJ2dyYWInO1xuICAgICAgeCA9IE1hdGhVdGlscy5jbGFtcChvbGRYICsgeCAvIHNpemUud2lkdGggKiBNYXRoLlBJICogc3BlZWQsIC4uLnJBemltdXRoKTtcbiAgICAgIHkgPSBNYXRoVXRpbHMuY2xhbXAob2xkWSArIHkgLyBzaXplLmhlaWdodCAqIE1hdGguUEkgKiBzcGVlZCwgLi4uclBvbGFyKTtcbiAgICAgIGNvbnN0IHNDb25maWcgPSBzbmFwICYmICFkb3duICYmIHR5cGVvZiBzbmFwICE9PSAnYm9vbGVhbicgPyBzbmFwIDogY29uZmlnO1xuICAgICAgYXBpLnN0YXJ0KHtcbiAgICAgICAgc2NhbGU6IGRvd24gJiYgeSA+IHJQb2xhclsxXSAvIDIgPyB6b29tIDogMSxcbiAgICAgICAgcm90YXRpb246IHNuYXAgJiYgIWRvd24gPyBySW5pdGlhbCA6IFt5LCB4LCAwXSxcbiAgICAgICAgY29uZmlnOiBuID0+IG4gPT09ICdzY2FsZScgPyB7XG4gICAgICAgICAgLi4uc0NvbmZpZyxcbiAgICAgICAgICBmcmljdGlvbjogc0NvbmZpZy5mcmljdGlvbiAqIDNcbiAgICAgICAgfSA6IHNDb25maWdcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFt5LCB4XTtcbiAgICB9XG4gIH0sIHtcbiAgICB0YXJnZXQ6IGdsb2JhbCA/IGV4cGxEb21FbGVtZW50IDogdW5kZWZpbmVkXG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoYS5ncm91cCwgX2V4dGVuZHMoe30sIGJpbmQgPT0gbnVsbCA/IHZvaWQgMCA6IGJpbmQoKSwgc3ByaW5nKSwgY2hpbGRyZW4pO1xufVxuXG5leHBvcnQgeyBQcmVzZW50YXRpb25Db250cm9scyB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJNYXRoVXRpbHMiLCJ1c2VUaHJlZSIsInVzZVNwcmluZyIsImEiLCJ1c2VHZXN0dXJlIiwiUHJlc2VudGF0aW9uQ29udHJvbHMiLCJlbmFibGVkIiwic25hcCIsImdsb2JhbCIsImRvbUVsZW1lbnQiLCJjdXJzb3IiLCJjaGlsZHJlbiIsInNwZWVkIiwicm90YXRpb24iLCJ6b29tIiwicG9sYXIiLCJNYXRoIiwiUEkiLCJhemltdXRoIiwiSW5maW5pdHkiLCJjb25maWciLCJtYXNzIiwidGVuc2lvbiIsImZyaWN0aW9uIiwiZXZlbnRzIiwic3RhdGUiLCJnbCIsImV4cGxEb21FbGVtZW50IiwiY29ubmVjdGVkIiwic2l6ZSIsInJQb2xhciIsInVzZU1lbW8iLCJyQXppbXV0aCIsInJJbml0aWFsIiwiY2xhbXAiLCJzcHJpbmciLCJhcGkiLCJzY2FsZSIsInVzZUVmZmVjdCIsInN0YXJ0Iiwic3R5bGUiLCJiaW5kIiwib25Ib3ZlciIsImxhc3QiLCJvbkRyYWciLCJkb3duIiwiZGVsdGEiLCJ4IiwieSIsIm1lbW8iLCJvbGRZIiwib2xkWCIsImFuaW1hdGlvbiIsInRvIiwid2lkdGgiLCJoZWlnaHQiLCJzQ29uZmlnIiwibiIsInRhcmdldCIsInVuZGVmaW5lZCIsImNyZWF0ZUVsZW1lbnQiLCJncm91cCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/web/PresentationControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useInstanceHandle),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useStore),\n/* harmony export */   D: () => (/* binding */ useThree),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useFrame),\n/* harmony export */   G: () => (/* binding */ useGraph),\n/* harmony export */   H: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createPointerEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ createEvents),\n/* harmony export */   g: () => (/* binding */ context),\n/* harmony export */   h: () => (/* binding */ createPortal),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ reconciler),\n/* harmony export */   k: () => (/* binding */ applyProps),\n/* harmony export */   l: () => (/* binding */ dispose),\n/* harmony export */   m: () => (/* binding */ invalidate),\n/* harmony export */   n: () => (/* binding */ advance),\n/* harmony export */   o: () => (/* binding */ addEffect),\n/* harmony export */   p: () => (/* binding */ addAfterEffect),\n/* harmony export */   q: () => (/* binding */ addTail),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ flushSync),\n/* harmony export */   w: () => (/* binding */ getRootState),\n/* harmony export */   x: () => (/* binding */ act),\n/* harmony export */   y: () => (/* binding */ buildGraph),\n/* harmony export */   z: () => (/* binding */ roots)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance instanceof three__WEBPACK_IMPORTED_MODULE_5__.BufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_5__.Material) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                parentInstance.dispatchEvent({\n                    type: \"childadded\",\n                    child\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // @ts-expect-error\n                // Remove interactivity on the initial root\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(findInitialRoot(child), child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                const callback = ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                };\n                // Schedule async at runtime, flush sync in testing\n                if (typeof IS_REACT_ACT_ENVIRONMENT === \"undefined\") {\n                    (0,scheduler__WEBPACK_IMPORTED_MODULE_4__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_4__.unstable_IdlePriority, callback);\n                } else {\n                    callback();\n                }\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers on the initial root\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = findInitialRoot(newInstance).getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, make it no-op\n    const handleTextInstance = ()=>{};\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_3___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container on the initial root\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                findInitialRoot(instance).getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-expect-error\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\r\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\r\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\r\n * The current THREE.ColorManagement instance, if present.\r\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\r\n * An SSR-friendly useLayoutEffect.\r\n *\r\n * React currently throws a warning when using useLayoutEffect on the server.\r\n * To get around it, we can conditionally useEffect on the server (no-op) and\r\n * useLayoutEffect elsewhere.\r\n *\r\n * @see https://github.com/facebook/react/issues/14927\r\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\r\n * Returns instance root state\r\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n/**\r\n * Returns the instances initial (outmost) root\r\n */ function findInitialRoot(child) {\n    let root = child.__r3f.root;\n    while(root.getState().previousRoot)root = root.getState().previousRoot;\n    return root;\n}\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a) || is.boo(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n/**\r\n * Collects nodes and materials from a THREE.Object3D.\r\n */ function buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    const localState = instance.__r3f;\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f;\n        // Bail out on primitive object\n        if ((_instance$__r3f = instance.__r3f) != null && _instance$__r3f.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState != null && localState.memoizedProps && localState != null && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\nconst __DEV__ = typeof process !== \"undefined\" && \"development\" !== \"production\";\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f2;\n    // Filter equals, events and reserved props\n    const localState = instance.__r3f;\n    const root = localState == null ? void 0 : localState.root;\n    const rootState = root == null ? void 0 : root.getState == null ? void 0 : root.getState();\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState == null ? void 0 : localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-expect-error\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent && localState) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.\n            // Loosen to unminified names, ignoring descendents.\n            // https://github.com/pmndrs/react-three-fiber/issues/2856\n            // TODO: fix upstream and remove in v9\n            (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Color;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_5__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && rootState && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_5__.Texture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_5__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_5__.UnsignedByteType && rootState) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState && localState.parent && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Get the initial root state's internals\n        const internal = findInitialRoot(instance).getState().internal;\n        // Pre-emptively remove the instance from the interaction manager\n        const index = internal.interaction.indexOf(instance);\n        if (index > -1) internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f3, _instance$__r3f3$root;\n    const state = (_instance$__r3f3 = instance.__r3f) == null ? void 0 : (_instance$__r3f3$root = _instance$__r3f3.root) == null ? void 0 : _instance$__r3f3$root.getState == null ? void 0 : _instance$__r3f3$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\r\n * Release pointer captures.\r\n * This is called by releasePointerCapture in the API, and when an object is removed.\r\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\r\n        MAYBE TODO, DELETE IF NOT: \r\n          Check if the object is captured, captured events should not have intersects running in parallel\r\n          But wouldn't it be better to just replace capturedMap with a single entry?\r\n          Also, are we OK with straight up making picking up multiple objects impossible?\r\n          \r\n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \r\n        if (pointerId !== undefined) {\r\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\r\n          if (capturedMeshSet) {\r\n            const captured = capturedMeshSet.get(eventObject)\r\n            if (captured && captured.localState.stopped) return\r\n          }\r\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_5__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target instanceof three__WEBPACK_IMPORTED_MODULE_5__.Vector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_5__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_5__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\r\n * Adds a global render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\r\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\r\n * Adds a global after-render callback which is called each frame.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\r\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\r\n * Adds a global callback which is called when rendering stops.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\r\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let useFrameInProgress = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        useFrameInProgress = true;\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        useFrameInProgress = false;\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState(), frames));\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        if (frames > 1) {\n            // legacy support for people using frames parameters\n            // Increase frames, do not go higher than 60\n            state.internal.frames = Math.min(60, state.internal.frames + frames);\n        } else {\n            if (useFrameInProgress) {\n                //called from within a useFrame, it means the user wants an additional frame\n                state.internal.frames = 2;\n            } else {\n                //the user need a new frame, no need to increment further than 1\n                state.internal.frames = 1;\n            }\n        }\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        invalidate,\n        advance\n    };\n}\n/**\r\n * Exposes an object's {@link LocalState}.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\r\n *\r\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\r\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\r\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\r\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\r\n * Executes a callback before render in a shared frame loop.\r\n * Can order effects with render priority or manually render with a positive priority.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\r\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\r\n * Returns a node graph of an object with named nodes & materials.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\r\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        let loader = memoizedLoaders.get(Proto);\n        if (!loader) {\n            loader = new Proto();\n            memoizedLoaders.set(Proto, loader);\n        }\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`))))));\n    };\n}\n/**\r\n * Synchronously loads and caches assets with a three loader.\r\n *\r\n * Note: this hook's caller must be wrapped with `React.Suspense`\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\r\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\r\n * Preloads an asset into cache as a side-effect.\r\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\r\n * Removes a loaded asset from cache.\r\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_7__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_8__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    const defaultStyle = typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement;\n    if (defaultSize) {\n        const { width, height, top, left, updateStyle = defaultStyle } = defaultSize;\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle\n        };\n    } else if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle: defaultStyle\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n            updateStyle: defaultStyle\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_5__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_5__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_5__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) {\n                        applyProps(camera, cameraOptions);\n                        // Preserve user-defined frustum if possible\n                        // https://github.com/pmndrs/react-three-fiber/issues/3160\n                        if (\"aspect\" in cameraOptions || \"left\" in cameraOptions || \"right\" in cameraOptions || \"bottom\" in cameraOptions || \"top\" in cameraOptions) {\n                            camera.manual = true;\n                            camera.updateProjectionMatrix();\n                        }\n                    }\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_5__.Scene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_5__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_5__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_5__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_5__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_5__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            if (!configured) {\n                // Set color space and tonemapping preferences, once\n                const LinearEncoding = 3000;\n                const sRGBEncoding = 3001;\n                applyProps(gl, {\n                    outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                    toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_5__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_5__.ACESFilmicToneMapping\n                });\n            }\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(context.Provider, {\n        value: store,\n        children: children\n    });\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Portal, {\n        children: children,\n        container: container,\n        state: state\n    }, container.uuid);\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\r\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\r\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\r\n   *  <Canvas>\r\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_5__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_5__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_5__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>{\n            usePortalStore.destroy();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n        children: reconciler.createPortal(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(context.Provider, {\n            value: usePortalStore,\n            children: children\n        }), usePortalStore, null)\n    });\n}\n/**\r\n * Force React to flush any updates inside the provided callback synchronously and immediately.\r\n * All the same caveats documented for react-dom's `flushSync` apply here (see https://react.dev/reference/react-dom/flushSync).\r\n * Nevertheless, sometimes one needs to render synchronously, for example to keep DOM and 3D changes in lock-step without\r\n * having to revert to a non-React solution.\r\n */ function flushSync(fn) {\n    // `flushSync` implementation only takes one argument. I don't know what's up with the type declaration for it.\n    return reconciler.flushSync(fn, undefined);\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = createEvents(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvZXZlbnRzLTMyMWIwNWZiLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDMkI7QUFDTjtBQUNSO0FBQ21DO0FBRTdFLElBQUllLGFBQWEsV0FBVyxHQUFFQyxPQUFPQyxNQUFNLENBQUM7SUFDMUNDLFdBQVc7QUFDYjtBQUVBLE1BQU1DLFlBQVksQ0FBQztBQUNuQixNQUFNQyxTQUFTQyxDQUFBQSxVQUFXLEtBQUtMLE9BQU9NLE1BQU0sQ0FBQ0gsV0FBV0U7QUFDeEQsU0FBU0UsZUFBZUMsTUFBTSxFQUFFQyxpQkFBaUI7SUFDL0MsU0FBU0MsZUFBZUMsSUFBSSxFQUFFLEVBQzVCQyxPQUFPLEVBQUUsRUFDVEMsTUFBTSxFQUNOLEdBQUdDLE9BQ0osRUFBRUMsSUFBSTtRQUNMLElBQUlDLE9BQU8sQ0FBQyxFQUFFTCxJQUFJLENBQUMsRUFBRSxDQUFDTSxXQUFXLEdBQUcsRUFBRU4sS0FBS08sS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUNyRCxJQUFJQztRQUNKLElBQUlSLFNBQVMsYUFBYTtZQUN4QixJQUFJRyxNQUFNTSxNQUFNLEtBQUtDLFdBQVcsTUFBTSxJQUFJQyxNQUFNO1lBQ2hELE1BQU1GLFNBQVNOLE1BQU1NLE1BQU07WUFDM0JELFdBQVdJLFFBQVFILFFBQVE7Z0JBQ3pCVDtnQkFDQUk7Z0JBQ0FGO2dCQUNBVyxXQUFXO1lBQ2I7UUFDRixPQUFPO1lBQ0wsTUFBTUMsU0FBU3RCLFNBQVMsQ0FBQ2EsS0FBSztZQUM5QixJQUFJLENBQUNTLFFBQVE7Z0JBQ1gsTUFBTSxJQUFJSCxNQUFNLENBQUMsS0FBSyxFQUFFTixLQUFLLDRKQUE0SixDQUFDO1lBQzVMO1lBRUEsb0RBQW9EO1lBQ3BELElBQUksQ0FBQ1UsTUFBTUMsT0FBTyxDQUFDZixPQUFPLE1B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QixFQUFFLEVBQUVua0IsT0FBTyxDQUFDLENBQUMsQ0FBQzNDLE1BQU1xUyxNQUFNO29CQUMzRyxJQUFJbUMsVUFBVUEsT0FBT29GLFNBQVMsWUFBWW1OLGFBQWE7d0JBQ3JELE1BQU0sQ0FBQ0gsVUFBVSxHQUFHZCxVQUFVLENBQUM5bEIsS0FBSzt3QkFDcEN3VSxPQUFPb0YsU0FBUyxDQUFDOEksbUJBQW1CLENBQUNrRSxXQUFXdlU7b0JBQ2xEO2dCQUNGO2dCQUNBMUgsSUFBSUssQ0FBQUEsUUFBVTt3QkFDWndKLFFBQVE7NEJBQ04sR0FBR3hKLE1BQU13SixNQUFNOzRCQUNmb0YsV0FBV3ZaO3dCQUNiO29CQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFK2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvZGlzdC9ldmVudHMtMzIxYjA1ZmIuZXNtLmpzPzIyMDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IGNyZWF0ZSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IFJlY29uY2lsZXIgZnJvbSAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgeyB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLCB1bnN0YWJsZV9JZGxlUHJpb3JpdHkgfSBmcm9tICdzY2hlZHVsZXInO1xuXG52YXIgdGhyZWVUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgY2F0YWxvZ3VlID0ge307XG5jb25zdCBleHRlbmQgPSBvYmplY3RzID0+IHZvaWQgT2JqZWN0LmFzc2lnbihjYXRhbG9ndWUsIG9iamVjdHMpO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIoX3Jvb3RzLCBfZ2V0RXZlbnRQcmlvcml0eSkge1xuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCB7XG4gICAgYXJncyA9IFtdLFxuICAgIGF0dGFjaCxcbiAgICAuLi5wcm9wc1xuICB9LCByb290KSB7XG4gICAgbGV0IG5hbWUgPSBgJHt0eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpfWA7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmICh0eXBlID09PSAncHJpbWl0aXZlJykge1xuICAgICAgaWYgKHByb3BzLm9iamVjdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJSM0Y6IFByaW1pdGl2ZXMgd2l0aG91dCAnb2JqZWN0JyBhcmUgaW52YWxpZCFcIik7XG4gICAgICBjb25zdCBvYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUob2JqZWN0LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGF0dGFjaCxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW25hbWVdO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSM0Y6ICR7bmFtZX0gaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kPyBTZWU6IGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9vYmplY3RzI3VzaW5nLTNyZC1wYXJ0eS1vYmplY3RzLWRlY2xhcmF0aXZlbHlgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogVGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAvLyBJbnN0YW5jaWF0ZSBuZXcgb2JqZWN0LCBsaW5rIGl0IHRvIHRoZSByb290XG4gICAgICAvLyBBcHBlbmQgbWVtb2l6ZWQgcHJvcHMgd2l0aCBhcmdzIHNvIGl0J3Mgbm90IGZvcmdvdHRlblxuICAgICAgaW5zdGFuY2UgPSBwcmVwYXJlKG5ldyB0YXJnZXQoLi4uYXJncyksIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICAvLyBTYXZlIGFyZ3MgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IGxhdGVyIGZvciBITVJcbiAgICAgICAgbWVtb2l6ZWRQcm9wczoge1xuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXV0by1hdHRhY2ggZ2VvbWV0cmllcyBhbmQgbWF0ZXJpYWxzXG4gICAgaWYgKGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSkgaW5zdGFuY2UuX19yM2YuYXR0YWNoID0gJ2dlb21ldHJ5JztlbHNlIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLk1hdGVyaWFsKSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICAgIH1cblxuICAgIC8vIEl0IHNob3VsZCBOT1QgY2FsbCBvblVwZGF0ZSBvbiBvYmplY3QgaW5zdGFuY2lhdGlvbiwgYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGVcbiAgICAvLyB2aWV3IHlldC4gSWYgdGhlIGNhbGxiYWNrIHJlbGllcyBvbiByZWZlcmVuY2VzIGZvciBpbnN0YW5jZSwgdGhleSB3b24ndCBiZSByZWFkeSB5ZXQsIHRoaXMgaXNcbiAgICAvLyB3aHkgaXQgcGFzc2VzIFwidHJ1ZVwiIGhlcmVcbiAgICAvLyBUaGVyZSBpcyBubyByZWFzb24gdG8gYXBwbHkgcHJvcHMgdG8gaW5qZWN0c1xuICAgIGlmIChuYW1lICE9PSAnaW5qZWN0JykgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZiwgX3BhcmVudEluc3RhbmNlJF9fcjNmO1xuICAgICAgLy8gVGhlIGF0dGFjaCBhdHRyaWJ1dGUgaW1wbGllcyB0aGF0IHRoZSBvYmplY3QgYXR0YWNoZXMgaXRzZWxmIG9uIHRoZSBwYXJlbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgLy8gYWRkIGluIHRoZSB1c3VhbCBwYXJlbnQtY2hpbGQgd2F5XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmFkZChjaGlsZCk7XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGFueXRoaW5nIHRoYXQgdXNlZCBhdHRhY2gsIGFuZCBmb3Igbm9uLU9iamVjdDNEcyB0aGF0IGRvbid0IGdldCBhdHRhY2hlZCB0byBwcm9wcztcbiAgICAgIC8vIHRoYXQgaXMsIGFueXRoaW5nIHRoYXQncyBhIGNoaWxkIGluIFJlYWN0IGJ1dCBub3QgYSBjaGlsZCBpbiB0aGUgc2NlbmVncmFwaC5cbiAgICAgIGlmICghYWRkZWQpIChfcGFyZW50SW5zdGFuY2UkX19yM2YgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZjIsIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjI7XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YyLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdjaGlsZGFkZGVkJyxcbiAgICAgICAgICBjaGlsZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdFNpYmxpbmdzID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKHNpYmxpbmcgPT4gc2libGluZyAhPT0gY2hpbGQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4gPSBbLi4ucmVzdFNpYmxpbmdzLnNsaWNlKDAsIGluZGV4KSwgY2hpbGQsIC4uLnJlc3RTaWJsaW5ncy5zbGljZShpbmRleCldO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmMiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmMi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoYXJyYXksIHBhcmVudCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFycmF5KSBbLi4uYXJyYXldLmZvckVhY2goY2hpbGQgPT4gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgZGlzcG9zZSkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMsIF9jaGlsZCRfX3IzZjMsIF9jaGlsZCRfX3IzZjU7XG4gICAgICAvLyBDbGVhciB0aGUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgaWYgKGNoaWxkLl9fcjNmKSBjaGlsZC5fX3IzZi5wYXJlbnQgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyb20gdGhlIHBhcmVudHMgb2JqZWN0c1xuICAgICAgaWYgKChfcGFyZW50SW5zdGFuY2UkX19yM2YzID0gcGFyZW50SW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX3BhcmVudEluc3RhbmNlJF9fcjNmMy5vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cy5maWx0ZXIoeCA9PiB4ICE9PSBjaGlsZCk7XG4gICAgICAvLyBSZW1vdmUgYXR0YWNobWVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YzID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y0O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIC8vIFJlbW92ZSBpbnRlcmFjdGl2aXR5IG9uIHRoZSBpbml0aWFsIHJvb3RcbiAgICAgICAgaWYgKChfY2hpbGQkX19yM2Y0ID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmNC5yb290KSB7XG4gICAgICAgICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShmaW5kSW5pdGlhbFJvb3QoY2hpbGQpLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbHRvZ2V0aGVyIGJ5IHBhc3NpbmcgZGlzcG9zZT17bnVsbH1cbiAgICAgIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gICAgICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdCBoYXMgdG8gaGF2ZVxuICAgICAgLy8gICAtIGEgZGlzcG9zZSBtZXRob2QsXG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0J3Mgb3duIGFwaVxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGRpc3Bvc2FsIGlzIHJlY3Vyc2l2ZSwgd2UgY2FuIGNoZWNrIHRoZSBvcHRpb25hbCBkaXNwb3NlIGFyZywgd2hpY2ggd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgIC8vIHdoZW4gdGhlIHJlY29uY2lsZXIgY2FsbHMgaXQsIGJ1dCB0aGVuIGNhcnJ5IG91ciBvd24gY2hlY2sgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKF9jaGlsZCRfX3IzZjUgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjUucHJpbWl0aXZlO1xuICAgICAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9ICFpc1ByaW1pdGl2ZSAmJiAoZGlzcG9zZSA9PT0gdW5kZWZpbmVkID8gY2hpbGQuZGlzcG9zZSAhPT0gbnVsbCA6IGRpc3Bvc2UpO1xuXG4gICAgICAvLyBSZW1vdmUgbmVzdGVkIGNoaWxkIG9iamVjdHMuIFByaW1pdGl2ZXMgc2hvdWxkIG5vdCBoYXZlIG9iamVjdHMgYW5kIGNoaWxkcmVuIHRoYXQgYXJlXG4gICAgICAvLyBhdHRhY2hlZCB0byB0aGVtIGRlY2xhcmF0aXZlbHkgLi4uXG4gICAgICBpZiAoIWlzUHJpbWl0aXZlKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y2O1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoKF9jaGlsZCRfX3IzZjYgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjYub2JqZWN0cywgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgICByZW1vdmVSZWN1cnNpdmUoY2hpbGQuY2hpbGRyZW4sIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcbiAgICAgIGRlbGV0ZSBjaGlsZC5fX3IzZjtcblxuICAgICAgLy8gRGlzcG9zZSBpdGVtIHdoZW5ldmVyIHRoZSByZWNvbmNpbGVyIGZlZWxzIGxpa2UgaXRcbiAgICAgIGlmIChzaG91bGREaXNwb3NlICYmIGNoaWxkLmRpc3Bvc2UgJiYgY2hpbGQudHlwZSAhPT0gJ1NjZW5lJykge1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTY2hlZHVsZSBhc3luYyBhdCBydW50aW1lLCBmbHVzaCBzeW5jIGluIHRlc3RpbmdcbiAgICAgICAgaWYgKHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayh1bnN0YWJsZV9JZGxlUHJpb3JpdHksIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YucGFyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgY29uc3QgbmV3SW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgaW5zdGFuY2UuX19yM2Yucm9vdCk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xMzQ4XG4gICAgLy8gV2hlbiBhcmdzIGNoYW5nZSB0aGUgaW5zdGFuY2UgaGFzIHRvIGJlIHJlLWNvbnN0cnVjdGVkLCB3aGljaCB0aGVuXG4gICAgLy8gZm9yY2VzIHIzZiB0byByZS1wYXJlbnQgdGhlIGNoaWxkcmVuIGFuZCBub24tc2NlbmUgb2JqZWN0c1xuICAgIGlmIChpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQuX19yM2YpIGFwcGVuZENoaWxkKG5ld0luc3RhbmNlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5jaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuX19yM2YpO1xuICAgIH1cbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzLmZvckVhY2goY2hpbGQgPT4gYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKSk7XG4gICAgaW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IFtdO1xuICAgIGlmICghaW5zdGFuY2UuX19yM2YuYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQpIHtcbiAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAobmV3SW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBuZXdJbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCA9IHRydWU7XG4gICAgfVxuICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbmV3SW5zdGFuY2UpO1xuXG4gICAgLy8gUmUtYmluZCBldmVudCBoYW5kbGVycyBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgaWYgKG5ld0luc3RhbmNlLnJheWNhc3QgJiYgbmV3SW5zdGFuY2UuX19yM2YuZXZlbnRDb3VudCkge1xuICAgICAgY29uc3Qgcm9vdFN0YXRlID0gZmluZEluaXRpYWxSb290KG5ld0luc3RhbmNlKS5nZXRTdGF0ZSgpO1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIH1cbiAgICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGlmIChmaWJlci5yZWYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgbWFrZSBpdCBuby1vcFxuICBjb25zdCBoYW5kbGVUZXh0SW5zdGFuY2UgPSAoKSA9PiB7fTtcbiAgY29uc3QgcmVjb25jaWxlciA9IFJlY29uY2lsZXIoe1xuICAgIGNyZWF0ZUluc3RhbmNlLFxuICAgIHJlbW92ZUNoaWxkLFxuICAgIGFwcGVuZENoaWxkLFxuICAgIGFwcGVuZEluaXRpYWxDaGlsZDogYXBwZW5kQ2hpbGQsXG4gICAgaW5zZXJ0QmVmb3JlLFxuICAgIHN1cHBvcnRzTXV0YXRpb246IHRydWUsXG4gICAgaXNQcmltYXJ5UmVuZGVyZXI6IGZhbHNlLFxuICAgIHN1cHBvcnRzUGVyc2lzdGVuY2U6IGZhbHNlLFxuICAgIHN1cHBvcnRzSHlkcmF0aW9uOiBmYWxzZSxcbiAgICBub1RpbWVvdXQ6IC0xLFxuICAgIGFwcGVuZENoaWxkVG9Db250YWluZXI6IChjb250YWluZXIsIGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuXG4gICAgICAvLyBMaW5rIGN1cnJlbnQgcm9vdCB0byB0aGUgZGVmYXVsdCBzY2VuZVxuICAgICAgc2NlbmUuX19yM2Yucm9vdCA9IGNvbnRhaW5lcjtcbiAgICAgIGFwcGVuZENoaWxkKHNjZW5lLCBjaGlsZCk7XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXI6IChjb250YWluZXIsIGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkKSByZXR1cm47XG4gICAgICByZW1vdmVDaGlsZChjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IChjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCB8fCAhYmVmb3JlQ2hpbGQpIHJldHVybjtcblxuICAgICAgLy8gRG9uJ3QgYXBwZW5kIHRvIHVubW91bnRlZCBjb250YWluZXJcbiAgICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmU7XG4gICAgICBpZiAoIXNjZW5lLl9fcjNmKSByZXR1cm47XG4gICAgICBpbnNlcnRCZWZvcmUoc2NlbmUsIGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgfSxcbiAgICBnZXRSb290SG9zdENvbnRleHQ6ICgpID0+IG51bGwsXG4gICAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogcGFyZW50SG9zdENvbnRleHQgPT4gcGFyZW50SG9zdENvbnRleHQsXG4gICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2YyO1xuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YyID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmMiA6IHt9O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gUmV0dXJuaW5nIHRydWUgd2lsbCB0cmlnZ2VyIGNvbW1pdE1vdW50XG4gICAgICByZXR1cm4gQm9vbGVhbihsb2NhbFN0YXRlLmhhbmRsZXJzKTtcbiAgICB9LFxuICAgIHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIF90eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2YzO1xuICAgICAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmMyA6IHt9O1xuXG4gICAgICAvLyBDcmVhdGUgZGlmZi1zZXRzXG4gICAgICBpZiAobG9jYWxTdGF0ZS5wcmltaXRpdmUgJiYgbmV3UHJvcHMub2JqZWN0ICYmIG5ld1Byb3BzLm9iamVjdCAhPT0gaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIFt0cnVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkYXRhIG9iamVjdCwgbGV0J3MgZXh0cmFjdCBjcml0aWNhbCBpbmZvcm1hdGlvbiBhYm91dCBpdFxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJnczogYXJnc05ldyA9IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBjTixcbiAgICAgICAgICAuLi5yZXN0TmV3XG4gICAgICAgIH0gPSBuZXdQcm9wcztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NPbGQgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY08sXG4gICAgICAgICAgLi4ucmVzdE9sZFxuICAgICAgICB9ID0gb2xkUHJvcHM7XG5cbiAgICAgICAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnc05ldykpIHRocm93IG5ldyBFcnJvcignUjNGOiB0aGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgICAgLy8gSWYgaXQgaGFzIG5ldyBwcm9wcyBvciBhcmd1bWVudHMsIHRoZW4gaXQgbmVlZHMgdG8gYmUgcmUtaW5zdGFudGlhdGVkXG4gICAgICAgIGlmIChhcmdzTmV3LnNvbWUoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgIT09IGFyZ3NPbGRbaW5kZXhdKSkgcmV0dXJuIFt0cnVlXTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZGlmZi1zZXQsIGZsYWcgaWYgdGhlcmUgYXJlIGFueSBjaGFuZ2VzXG4gICAgICAgIGNvbnN0IGRpZmYgPSBkaWZmUHJvcHMoaW5zdGFuY2UsIHJlc3ROZXcsIHJlc3RPbGQsIHRydWUpO1xuICAgICAgICBpZiAoZGlmZi5jaGFuZ2VzLmxlbmd0aCkgcmV0dXJuIFtmYWxzZSwgZGlmZl07XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGRvIG5vdCB0b3VjaCB0aGUgaW5zdGFuY2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIFtyZWNvbnN0cnVjdCwgZGlmZl0sIHR5cGUsIF9vbGRQcm9wcywgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgICAvLyBSZWNvbnN0cnVjdCB3aGVuIGFyZ3Mgb3IgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gaGF2ZSBjaGFuZ2VzXG4gICAgICBpZiAocmVjb25zdHJ1Y3QpIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpO1xuICAgICAgLy8gT3RoZXJ3aXNlIGp1c3Qgb3ZlcndyaXRlIHByb3BzXG4gICAgICBlbHNlIGFwcGx5UHJvcHMkMShpbnN0YW5jZSwgZGlmZik7XG4gICAgfSxcbiAgICBjb21taXRNb3VudChpbnN0YW5jZSwgX3R5cGUsIF9wcm9wcywgX2ludCkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjQ7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4gICAgICAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIGV2ZW50cyBhcmUgb25seSBhZGRlZCBvbmNlIHRvIHRoZSBjZW50cmFsIGNvbnRhaW5lciBvbiB0aGUgaW5pdGlhbCByb290XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjQgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjQgOiB7fTtcbiAgICAgIGlmIChpbnN0YW5jZS5yYXljYXN0ICYmIGxvY2FsU3RhdGUuaGFuZGxlcnMgJiYgbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgICAgIGZpbmRJbml0aWFsUm9vdChpbnN0YW5jZSkuZ2V0U3RhdGUoKS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFB1YmxpY0luc3RhbmNlOiBpbnN0YW5jZSA9PiBpbnN0YW5jZSxcbiAgICBwcmVwYXJlRm9yQ29tbWl0OiAoKSA9PiBudWxsLFxuICAgIHByZXBhcmVQb3J0YWxNb3VudDogY29udGFpbmVyID0+IHByZXBhcmUoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUpLFxuICAgIHJlc2V0QWZ0ZXJDb21taXQ6ICgpID0+IHt9LFxuICAgIHNob3VsZFNldFRleHRDb250ZW50OiAoKSA9PiBmYWxzZSxcbiAgICBjbGVhckNvbnRhaW5lcjogKCkgPT4gZmFsc2UsXG4gICAgaGlkZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNTtcbiAgICAgIC8vIERldGFjaCB3aGlsZSB0aGUgaW5zdGFuY2UgaXMgaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjUgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgZGV0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QpIGluc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y2O1xuICAgICAgLy8gUmUtYXR0YWNoIHdoZW4gdGhlIGluc3RhbmNlIGlzIHVuaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjYgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjYgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgYXR0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QgJiYgcHJvcHMudmlzaWJsZSA9PSBudWxsIHx8IHByb3BzLnZpc2libGUpIGluc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIGhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICB1bmhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjM2MCNkaXNjdXNzaW9uX3I5MTYzNTY4NzRcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHk6ICgpID0+IF9nZXRFdmVudFByaW9yaXR5ID8gX2dldEV2ZW50UHJpb3JpdHkoKSA6IERlZmF1bHRFdmVudFByaW9yaXR5LFxuICAgIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjogKCkgPT4ge30sXG4gICAgYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZTogKCkgPT4ge30sXG4gICAgbm93OiB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIGlzLmZ1bihwZXJmb3JtYW5jZS5ub3cpID8gcGVyZm9ybWFuY2Uubm93IDogaXMuZnVuKERhdGUubm93KSA/IERhdGUubm93IDogKCkgPT4gMCxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjM2MCNkaXNjdXNzaW9uX3I5MjA4ODM1MDNcbiAgICBzY2hlZHVsZVRpbWVvdXQ6IGlzLmZ1bihzZXRUaW1lb3V0KSA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQsXG4gICAgY2FuY2VsVGltZW91dDogaXMuZnVuKGNsZWFyVGltZW91dCkgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWRcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcmVjb25jaWxlcixcbiAgICBhcHBseVByb3BzOiBhcHBseVByb3BzJDFcbiAgfTtcbn1cblxudmFyIF93aW5kb3ckZG9jdW1lbnQsIF93aW5kb3ckbmF2aWdhdG9yO1xuLyoqXHJcbiAqIFJldHVybnMgYHRydWVgIHdpdGggY29ycmVjdCBUUyB0eXBlIGluZmVyZW5jZSBpZiBhbiBvYmplY3QgaGFzIGEgY29uZmlndXJhYmxlIGNvbG9yIHNwYWNlIChzaW5jZSByMTUyKS5cclxuICovXG5jb25zdCBoYXNDb2xvclNwYWNlID0gb2JqZWN0ID0+ICdjb2xvclNwYWNlJyBpbiBvYmplY3QgfHwgJ291dHB1dENvbG9yU3BhY2UnIGluIG9iamVjdDtcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBUSFJFRS5Db2xvck1hbmFnZW1lbnQgaW5zdGFuY2UsIGlmIHByZXNlbnQuXHJcbiAqL1xuY29uc3QgZ2V0Q29sb3JNYW5hZ2VtZW50ID0gKCkgPT4ge1xuICB2YXIgX0NvbG9yTWFuYWdlbWVudDtcbiAgcmV0dXJuIChfQ29sb3JNYW5hZ2VtZW50ID0gY2F0YWxvZ3VlLkNvbG9yTWFuYWdlbWVudCkgIT0gbnVsbCA/IF9Db2xvck1hbmFnZW1lbnQgOiBudWxsO1xufTtcbmNvbnN0IGlzT3J0aG9ncmFwaGljQ2FtZXJhID0gZGVmID0+IGRlZiAmJiBkZWYuaXNPcnRob2dyYXBoaWNDYW1lcmE7XG5jb25zdCBpc1JlZiA9IG9iaiA9PiBvYmogJiYgb2JqLmhhc093blByb3BlcnR5KCdjdXJyZW50Jyk7XG5cbi8qKlxyXG4gKiBBbiBTU1ItZnJpZW5kbHkgdXNlTGF5b3V0RWZmZWN0LlxyXG4gKlxyXG4gKiBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxyXG4gKiBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxyXG4gKiB1c2VMYXlvdXRFZmZlY3QgZWxzZXdoZXJlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQ5MjdcclxuICovXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfd2luZG93JGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50KSAhPSBudWxsICYmIF93aW5kb3ckZG9jdW1lbnQuY3JlYXRlRWxlbWVudCB8fCAoKF93aW5kb3ckbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnKSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZU11dGFibGVDYWxsYmFjayhmbikge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoZm4pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKHJlZi5jdXJyZW50ID0gZm4pLCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn1cbmZ1bmN0aW9uIEJsb2NrKHtcbiAgc2V0XG59KSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHNldChuZXcgUHJvbWlzZSgoKSA9PiBudWxsKSk7XG4gICAgcmV0dXJuICgpID0+IHNldChmYWxzZSk7XG4gIH0sIFtzZXRdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycikge1xuICAgIHRoaXMucHJvcHMuc2V0KGVycik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yID8gbnVsbCA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn1cbkVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pO1xuY29uc3QgREVGQVVMVCA9ICdfX2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVFMgPSBuZXcgTWFwKCk7XG5jb25zdCBpc0RpZmZTZXQgPSBkZWYgPT4gZGVmICYmICEhZGVmLm1lbW9pemVkICYmICEhZGVmLmNoYW5nZXM7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcclxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXHJcbiAqL1xuY29uc3QgZ2V0Um9vdFN0YXRlID0gb2JqID0+IHtcbiAgdmFyIF9yM2Y7XG4gIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2Yucm9vdC5nZXRTdGF0ZSgpO1xufTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlcyBpbml0aWFsIChvdXRtb3N0KSByb290XHJcbiAqL1xuZnVuY3Rpb24gZmluZEluaXRpYWxSb290KGNoaWxkKSB7XG4gIGxldCByb290ID0gY2hpbGQuX19yM2Yucm9vdDtcbiAgd2hpbGUgKHJvb3QuZ2V0U3RhdGUoKS5wcmV2aW91c1Jvb3QpIHJvb3QgPSByb290LmdldFN0YXRlKCkucHJldmlvdXNSb290O1xuICByZXR1cm4gcm9vdDtcbn1cbi8vIEEgY29sbGVjdGlvbiBvZiBjb21wYXJlIGZ1bmN0aW9uc1xuY29uc3QgaXMgPSB7XG4gIG9iajogYSA9PiBhID09PSBPYmplY3QoYSkgJiYgIWlzLmFycihhKSAmJiB0eXBlb2YgYSAhPT0gJ2Z1bmN0aW9uJyxcbiAgZnVuOiBhID0+IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nLFxuICBzdHI6IGEgPT4gdHlwZW9mIGEgPT09ICdzdHJpbmcnLFxuICBudW06IGEgPT4gdHlwZW9mIGEgPT09ICdudW1iZXInLFxuICBib286IGEgPT4gdHlwZW9mIGEgPT09ICdib29sZWFuJyxcbiAgdW5kOiBhID0+IGEgPT09IHZvaWQgMCxcbiAgYXJyOiBhID0+IEFycmF5LmlzQXJyYXkoYSksXG4gIGVxdShhLCBiLCB7XG4gICAgYXJyYXlzID0gJ3NoYWxsb3cnLFxuICAgIG9iamVjdHMgPSAncmVmZXJlbmNlJyxcbiAgICBzdHJpY3QgPSB0cnVlXG4gIH0gPSB7fSkge1xuICAgIC8vIFdyb25nIHR5cGUgb3Igb25lIG9mIHRoZSB0d28gdW5kZWZpbmVkLCBkb2Vzbid0IG1hdGNoXG4gICAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYiB8fCAhIWEgIT09ICEhYikgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEF0b21pYywganVzdCBjb21wYXJlIGEgYWdhaW5zdCBiXG4gICAgaWYgKGlzLnN0cihhKSB8fCBpcy5udW0oYSkgfHwgaXMuYm9vKGEpKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc09iaiA9IGlzLm9iaihhKTtcbiAgICBpZiAoaXNPYmogJiYgb2JqZWN0cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzQXJyID0gaXMuYXJyKGEpO1xuICAgIGlmIChpc0FyciAmJiBhcnJheXMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBBcnJheSBvciBPYmplY3QsIHNoYWxsb3cgY29tcGFyZSBmaXJzdCB0byBzZWUgaWYgaXQncyBhIG1hdGNoXG4gICAgaWYgKChpc0FyciB8fCBpc09iaikgJiYgYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgLy8gTGFzdCByZXNvcnQsIGdvIHRocm91Z2gga2V5c1xuICAgIGxldCBpO1xuICAgIC8vIENoZWNrIGlmIGEgaGFzIGFsbCB0aGUga2V5cyBvZiBiXG4gICAgZm9yIChpIGluIGEpIGlmICghKGkgaW4gYikpIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB2YWx1ZXMgYmV0d2VlbiBrZXlzIG1hdGNoXG4gICAgaWYgKGlzT2JqICYmIGFycmF5cyA9PT0gJ3NoYWxsb3cnICYmIG9iamVjdHMgPT09ICdzaGFsbG93Jykge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoIWlzLmVxdShhW2ldLCBiW2ldLCB7XG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgb2JqZWN0czogJ3JlZmVyZW5jZSdcbiAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgaSBpcyB1bmRlZmluZWRcbiAgICBpZiAoaXMudW5kKGkpKSB7XG4gICAgICAvLyBJZiBib3RoIGFycmF5cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzQXJyICYmIGEubGVuZ3RoID09PSAwICYmIGIubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIElmIGJvdGggb2JqZWN0cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzT2JqICYmIE9iamVjdC5rZXlzKGEpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhiKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gT3RoZXJ3aXNlIG1hdGNoIHRoZW0gYnkgdmFsdWVcbiAgICAgIGlmIChhICE9PSBiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcclxuICogQ29sbGVjdHMgbm9kZXMgYW5kIG1hdGVyaWFscyBmcm9tIGEgVEhSRUUuT2JqZWN0M0QuXHJcbiAqL1xuZnVuY3Rpb24gYnVpbGRHcmFwaChvYmplY3QpIHtcbiAgY29uc3QgZGF0YSA9IHtcbiAgICBub2Rlczoge30sXG4gICAgbWF0ZXJpYWxzOiB7fVxuICB9O1xuICBpZiAob2JqZWN0KSB7XG4gICAgb2JqZWN0LnRyYXZlcnNlKG9iaiA9PiB7XG4gICAgICBpZiAob2JqLm5hbWUpIGRhdGEubm9kZXNbb2JqLm5hbWVdID0gb2JqO1xuICAgICAgaWYgKG9iai5tYXRlcmlhbCAmJiAhZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdKSBkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0gPSBvYmoubWF0ZXJpYWw7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIERpc3Bvc2VzIGFuIG9iamVjdCBhbmQgYWxsIGl0cyBwcm9wZXJ0aWVzXG5mdW5jdGlvbiBkaXNwb3NlKG9iaikge1xuICBpZiAob2JqLmRpc3Bvc2UgJiYgb2JqLnR5cGUgIT09ICdTY2VuZScpIG9iai5kaXNwb3NlKCk7XG4gIGZvciAoY29uc3QgcCBpbiBvYmopIHtcbiAgICBwLmRpc3Bvc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHAuZGlzcG9zZSgpO1xuICAgIGRlbGV0ZSBvYmpbcF07XG4gIH1cbn1cblxuLy8gRWFjaCBvYmplY3QgaW4gdGhlIHNjZW5lIGNhcnJpZXMgYSBzbWFsbCBMb2NhbFN0YXRlIGRlc2NyaXB0b3JcbmZ1bmN0aW9uIHByZXBhcmUob2JqZWN0LCBzdGF0ZSkge1xuICBjb25zdCBpbnN0YW5jZSA9IG9iamVjdDtcbiAgaW5zdGFuY2UuX19yM2YgPSB7XG4gICAgdHlwZTogJycsXG4gICAgcm9vdDogbnVsbCxcbiAgICBwcmV2aW91c0F0dGFjaDogbnVsbCxcbiAgICBtZW1vaXplZFByb3BzOiB7fSxcbiAgICBldmVudENvdW50OiAwLFxuICAgIGhhbmRsZXJzOiB7fSxcbiAgICBvYmplY3RzOiBbXSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgLi4uc3RhdGVcbiAgfTtcbiAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5zdGFuY2UsIGtleSkge1xuICBsZXQgdGFyZ2V0ID0gaW5zdGFuY2U7XG4gIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkge1xuICAgIGNvbnN0IGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjb25zdCBsYXN0ID0gZW50cmllcy5wb3AoKTtcbiAgICB0YXJnZXQgPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleTogbGFzdFxuICAgIH07XG4gIH0gZWxzZSByZXR1cm4ge1xuICAgIHRhcmdldCxcbiAgICBrZXlcbiAgfTtcbn1cblxuLy8gQ2hlY2tzIGlmIGEgZGFzaC1jYXNlZCBzdHJpbmcgZW5kcyB3aXRoIGFuIGludGVnZXJcbmNvbnN0IElOREVYX1JFR0VYID0gLy1cXGQrJC87XG5mdW5jdGlvbiBhdHRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgLy8gSWYgYXR0YWNoaW5nIGludG8gYW4gYXJyYXkgKGZvby0wKSwgY3JlYXRlIG9uZVxuICAgIGlmIChJTkRFWF9SRUdFWC50ZXN0KHR5cGUpKSB7XG4gICAgICBjb25zdCByb290ID0gdHlwZS5yZXBsYWNlKElOREVYX1JFR0VYLCAnJyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAga2V5XG4gICAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHJvb3QpO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldFtrZXldKSkgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHRhcmdldFtrZXldO1xuICAgIHRhcmdldFtrZXldID0gY2hpbGQ7XG4gIH0gZWxzZSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaCA9IHR5cGUocGFyZW50LCBjaGlsZCk7XG59XG5mdW5jdGlvbiBkZXRhY2gocGFyZW50LCBjaGlsZCwgdHlwZSkge1xuICB2YXIgX2NoaWxkJF9fcjNmLCBfY2hpbGQkX19yM2YyO1xuICBpZiAoaXMuc3RyKHR5cGUpKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5XG4gICAgfSA9IHJlc29sdmUocGFyZW50LCB0eXBlKTtcbiAgICBjb25zdCBwcmV2aW91cyA9IGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoO1xuICAgIC8vIFdoZW4gdGhlIHByZXZpb3VzIHZhbHVlIHdhcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoZSB2YWx1ZSB3YXMgbmV2ZXIgc2V0IHRvIGJlZ2luIHdpdGhcbiAgICBpZiAocHJldmlvdXMgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIC8vIE90aGVyd2lzZSBzZXQgdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgZWxzZSB0YXJnZXRba2V5XSA9IHByZXZpb3VzO1xuICB9IGVsc2UgKF9jaGlsZCRfX3IzZiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2gocGFyZW50LCBjaGlsZCk7XG4gIChfY2hpbGQkX19yM2YyID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB0cnVlIDogZGVsZXRlIF9jaGlsZCRfX3IzZjIucHJldmlvdXNBdHRhY2g7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGRpZmZQcm9wcyhpbnN0YW5jZSwge1xuICBjaGlsZHJlbjogY04sXG4gIGtleToga04sXG4gIHJlZjogck4sXG4gIC4uLnByb3BzXG59LCB7XG4gIGNoaWxkcmVuOiBjUCxcbiAga2V5OiBrUCxcbiAgcmVmOiByUCxcbiAgLi4ucHJldmlvdXNcbn0gPSB7fSwgcmVtb3ZlID0gZmFsc2UpIHtcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IGluc3RhbmNlLl9fcjNmO1xuICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gW107XG5cbiAgLy8gQ2F0Y2ggcmVtb3ZlZCBwcm9wcywgcHJlcGVuZCB0aGVtIHNvIHRoZXkgY2FuIGJlIHJlc2V0IG9yIHJlbW92ZWRcbiAgaWYgKHJlbW92ZSkge1xuICAgIGNvbnN0IHByZXZpb3VzS2V5cyA9IE9iamVjdC5rZXlzKHByZXZpb3VzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZpb3VzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcmV2aW91c0tleXNbaV0pKSBlbnRyaWVzLnVuc2hpZnQoW3ByZXZpb3VzS2V5c1tpXSwgREVGQVVMVCArICdyZW1vdmUnXSk7XG4gICAgfVxuICB9XG4gIGVudHJpZXMuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgICAvLyBCYWlsIG91dCBvbiBwcmltaXRpdmUgb2JqZWN0XG4gICAgaWYgKChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkX19yM2YucHJpbWl0aXZlICYmIGtleSA9PT0gJ29iamVjdCcpIHJldHVybjtcbiAgICAvLyBXaGVuIHByb3BzIG1hdGNoIGJhaWwgb3V0XG4gICAgaWYgKGlzLmVxdSh2YWx1ZSwgcHJldmlvdXNba2V5XSkpIHJldHVybjtcbiAgICAvLyBDb2xsZWN0IGhhbmRsZXJzIGFuZCBiYWlsIG91dFxuICAgIGlmICgvXm9uKFBvaW50ZXJ8Q2xpY2t8RG91YmxlQ2xpY2t8Q29udGV4dE1lbnV8V2hlZWwpLy50ZXN0KGtleSkpIHJldHVybiBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIHRydWUsIFtdXSk7XG4gICAgLy8gU3BsaXQgZGFzaGVkIHByb3BzXG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIGVudHJpZXMgPSBrZXkuc3BsaXQoJy0nKTtcbiAgICBjaGFuZ2VzLnB1c2goW2tleSwgdmFsdWUsIGZhbHNlLCBlbnRyaWVzXSk7XG5cbiAgICAvLyBSZXNldCBwaWVyY2VkIHByb3BzXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgICAgaWYgKHByb3Auc3RhcnRzV2l0aChgJHtrZXl9LWApKSBjaGFuZ2VzLnB1c2goW3Byb3AsIHZhbHVlLCBmYWxzZSwgcHJvcC5zcGxpdCgnLScpXSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgbWVtb2l6ZWQgPSB7XG4gICAgLi4ucHJvcHNcbiAgfTtcbiAgaWYgKGxvY2FsU3RhdGUgIT0gbnVsbCAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMgJiYgbG9jYWxTdGF0ZSAhPSBudWxsICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzKSBtZW1vaXplZC5hcmdzID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmFyZ3M7XG4gIGlmIChsb2NhbFN0YXRlICE9IG51bGwgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUgIT0gbnVsbCAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoKSBtZW1vaXplZC5hdHRhY2ggPSBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoO1xuICByZXR1cm4ge1xuICAgIG1lbW9pemVkLFxuICAgIGNoYW5nZXNcbiAgfTtcbn1cbmNvbnN0IF9fREVWX18gPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuLy8gVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRhdGEpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gIC8vIEZpbHRlciBlcXVhbHMsIGV2ZW50cyBhbmQgcmVzZXJ2ZWQgcHJvcHNcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IGluc3RhbmNlLl9fcjNmO1xuICBjb25zdCByb290ID0gbG9jYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogbG9jYWxTdGF0ZS5yb290O1xuICBjb25zdCByb290U3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlKCk7XG4gIGNvbnN0IHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH0gPSBpc0RpZmZTZXQoZGF0YSkgPyBkYXRhIDogZGlmZlByb3BzKGluc3RhbmNlLCBkYXRhKTtcbiAgY29uc3QgcHJldkhhbmRsZXJzID0gbG9jYWxTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogbG9jYWxTdGF0ZS5ldmVudENvdW50O1xuXG4gIC8vIFByZXBhcmUgbWVtb2l6ZWQgcHJvcHNcbiAgaWYgKGluc3RhbmNlLl9fcjNmKSBpbnN0YW5jZS5fX3IzZi5tZW1vaXplZFByb3BzID0gbWVtb2l6ZWQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBba2V5LCB2YWx1ZSwgaXNFdmVudCwga2V5c10gPSBjaGFuZ2VzW2ldO1xuXG4gICAgLy8gQWxpYXMgKG91dHB1dCllbmNvZGluZyA9PiAob3V0cHV0KWNvbG9yU3BhY2UgKHNpbmNlIHIxNTIpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI4MjlcbiAgICBpZiAoaGFzQ29sb3JTcGFjZShpbnN0YW5jZSkpIHtcbiAgICAgIGNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG4gICAgICBjb25zdCBTUkdCQ29sb3JTcGFjZSA9ICdzcmdiJztcbiAgICAgIGNvbnN0IExpbmVhclNSR0JDb2xvclNwYWNlID0gJ3NyZ2ItbGluZWFyJztcbiAgICAgIGlmIChrZXkgPT09ICdlbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ2NvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdvdXRwdXRFbmNvZGluZycpIHtcbiAgICAgICAga2V5ID0gJ291dHB1dENvbG9yU3BhY2UnO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBzUkdCRW5jb2RpbmcgPyBTUkdCQ29sb3JTcGFjZSA6IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgY3VycmVudEluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgbGV0IHRhcmdldFByb3AgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcblxuICAgIC8vIFJldm9sdmUgZGFzaGVkIHByb3BzXG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRQcm9wID0ga2V5cy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhdG9taWMsIGl0IGZvcmNlcyB1cyB0byBzd2l0Y2ggdGhlIHJvb3RcbiAgICAgIGlmICghKHRhcmdldFByb3AgJiYgdGFyZ2V0UHJvcC5zZXQpKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCAuLi5yZXZlcnNlRW50cmllc10gPSBrZXlzLnJldmVyc2UoKTtcbiAgICAgICAgY3VycmVudEluc3RhbmNlID0gcmV2ZXJzZUVudHJpZXMucmV2ZXJzZSgpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAgIGtleSA9IG5hbWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMjEyMDlcbiAgICAvLyBITVIvZmFzdC1yZWZyZXNoIHJlbGllcyBvbiB0aGUgYWJpbGl0eSB0byBjYW5jZWwgb3V0IHByb3BzLCBidXQgdGhyZWVqc1xuICAgIC8vIGhhcyBubyBtZWFucyB0byBkbyB0aGlzLiBIZW5jZSB3ZSBjdXJhdGUgYSBzbWFsbCBjb2xsZWN0aW9uIG9mIHZhbHVlLWNsYXNzZXNcbiAgICAvLyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29uc3RydWN0b3Ivc2V0IGFyZ3VtZW50c1xuICAgIC8vIEZvciByZW1vdmVkIHByb3BzLCB0cnkgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCBpZiBwb3NzaWJsZVxuICAgIGlmICh2YWx1ZSA9PT0gREVGQVVMVCArICdyZW1vdmUnKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIGJsYW5rIHNsYXRlIG9mIHRoZSBpbnN0YW5jZSBhbmQgY29weSB0aGUgcGFydGljdWxhciBwYXJhbWV0ZXIuXG4gICAgICAgIGxldCBjdG9yID0gREVGQVVMVFMuZ2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmICghY3Rvcikge1xuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICBjdG9yID0gbmV3IGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvcigpO1xuICAgICAgICAgIERFRkFVTFRTLnNldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IsIGN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gY3RvcltrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBjb25zdHJ1Y3RvciwganVzdCBzZXQgaXQgdG8gMFxuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVhbCB3aXRoIHBvaW50ZXIgZXZlbnRzIC4uLlxuICAgIGlmIChpc0V2ZW50ICYmIGxvY2FsU3RhdGUpIHtcbiAgICAgIGlmICh2YWx1ZSkgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldID0gdmFsdWU7ZWxzZSBkZWxldGUgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldO1xuICAgICAgbG9jYWxTdGF0ZS5ldmVudENvdW50ID0gT2JqZWN0LmtleXMobG9jYWxTdGF0ZS5oYW5kbGVycykubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yIHNldC9jb3B5LCBhbmQgbGF5ZXJzXG4gICAgZWxzZSBpZiAodGFyZ2V0UHJvcCAmJiB0YXJnZXRQcm9wLnNldCAmJiAodGFyZ2V0UHJvcC5jb3B5IHx8IHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMpKSB7XG4gICAgICAvLyBJZiB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICh0YXJnZXRQcm9wLmZyb21BcnJheSkgdGFyZ2V0UHJvcC5mcm9tQXJyYXkodmFsdWUpO2Vsc2UgdGFyZ2V0UHJvcC5zZXQoLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gVGVzdCBhZ2FpbiB0YXJnZXQuY29weShjbGFzcykgbmV4dCAuLi5cbiAgICAgIGVsc2UgaWYgKHRhcmdldFByb3AuY29weSAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiAoXG4gICAgICAvLyBTb21lIGVudmlyb25tZW50cyBtYXkgYnJlYWsgc3RyaWN0IGlkZW50aXR5IGNoZWNrcyBieSBkdXBsaWNhdGluZyB2ZXJzaW9ucyBvZiB0aHJlZS5qcy5cbiAgICAgIC8vIExvb3NlbiB0byB1bm1pbmlmaWVkIG5hbWVzLCBpZ25vcmluZyBkZXNjZW5kZW50cy5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI4NTZcbiAgICAgIC8vIFRPRE86IGZpeCB1cHN0cmVhbSBhbmQgcmVtb3ZlIGluIHY5XG4gICAgICBfX0RFVl9fID8gdGFyZ2V0UHJvcC5jb25zdHJ1Y3Rvci5uYW1lID09PSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIDogdGFyZ2V0UHJvcC5jb25zdHJ1Y3RvciA9PT0gdmFsdWUuY29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRhcmdldFByb3AuY29weSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBub3RoaW5nIGVsc2UgZml0cywganVzdCBzZXQgdGhlIHNpbmdsZSB2YWx1ZSwgaWdub3JlIHVuZGVmaW5lZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjc0XG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGlzQ29sb3IgPSB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuQ29sb3I7XG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgYXJyYXkgc2NhbGFyc1xuICAgICAgICBpZiAoIWlzQ29sb3IgJiYgdGFyZ2V0UHJvcC5zZXRTY2FsYXIpIHRhcmdldFByb3Auc2V0U2NhbGFyKHZhbHVlKTtcbiAgICAgICAgLy8gTGF5ZXJzIGhhdmUgbm8gY29weSBmdW5jdGlvbiwgd2UgbXVzdCB0aGVyZWZvcmUgY29weSB0aGUgbWFzayBwcm9wZXJ0eVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzICYmIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSB0YXJnZXRQcm9wLm1hc2sgPSB2YWx1ZS5tYXNrO1xuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBzZXQgLi4uXG4gICAgICAgIGVsc2UgdGFyZ2V0UHJvcC5zZXQodmFsdWUpO1xuICAgICAgICAvLyBGb3IgdmVyc2lvbnMgb2YgdGhyZWUgd2hpY2ggZG9uJ3Qgc3VwcG9ydCBUSFJFRS5Db2xvck1hbmFnZW1lbnQsXG4gICAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIGNvbG9yc1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgICAgaWYgKCFnZXRDb2xvck1hbmFnZW1lbnQoKSAmJiByb290U3RhdGUgJiYgIXJvb3RTdGF0ZS5saW5lYXIgJiYgaXNDb2xvcikgdGFyZ2V0UHJvcC5jb252ZXJ0U1JHQlRvTGluZWFyKCk7XG4gICAgICB9XG4gICAgICAvLyBFbHNlLCBqdXN0IG92ZXJ3cml0ZSB0aGUgdmFsdWVcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0gPSB2YWx1ZTtcblxuICAgICAgLy8gQXV0by1jb252ZXJ0IHNSR0IgdGV4dHVyZXMsIGZvciBub3cgLi4uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgIGlmIChjdXJyZW50SW5zdGFuY2Vba2V5XSBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgJiZcbiAgICAgIC8vIHNSR0IgdGV4dHVyZXMgbXVzdCBiZSBSR0JBOCBzaW5jZSByMTM3IGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvcHVsbC8yMzEyOVxuICAgICAgY3VycmVudEluc3RhbmNlW2tleV0uZm9ybWF0ID09PSBUSFJFRS5SR0JBRm9ybWF0ICYmIGN1cnJlbnRJbnN0YW5jZVtrZXldLnR5cGUgPT09IFRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgJiYgcm9vdFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBjdXJyZW50SW5zdGFuY2Vba2V5XTtcbiAgICAgICAgaWYgKGhhc0NvbG9yU3BhY2UodGV4dHVyZSkgJiYgaGFzQ29sb3JTcGFjZShyb290U3RhdGUuZ2wpKSB0ZXh0dXJlLmNvbG9yU3BhY2UgPSByb290U3RhdGUuZ2wub3V0cHV0Q29sb3JTcGFjZTtlbHNlIHRleHR1cmUuZW5jb2RpbmcgPSByb290U3RhdGUuZ2wub3V0cHV0RW5jb2Rpbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIH1cbiAgaWYgKGxvY2FsU3RhdGUgJiYgbG9jYWxTdGF0ZS5wYXJlbnQgJiYgaW5zdGFuY2UucmF5Y2FzdCAmJiBwcmV2SGFuZGxlcnMgIT09IGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgIC8vIEdldCB0aGUgaW5pdGlhbCByb290IHN0YXRlJ3MgaW50ZXJuYWxzXG4gICAgY29uc3QgaW50ZXJuYWwgPSBmaW5kSW5pdGlhbFJvb3QoaW5zdGFuY2UpLmdldFN0YXRlKCkuaW50ZXJuYWw7XG4gICAgLy8gUHJlLWVtcHRpdmVseSByZW1vdmUgdGhlIGluc3RhbmNlIGZyb20gdGhlIGludGVyYWN0aW9uIG1hbmFnZXJcbiAgICBjb25zdCBpbmRleCA9IGludGVybmFsLmludGVyYWN0aW9uLmluZGV4T2YoaW5zdGFuY2UpO1xuICAgIGlmIChpbmRleCA+IC0xKSBpbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChsb2NhbFN0YXRlLmV2ZW50Q291bnQpIGludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICB9XG5cbiAgLy8gQ2FsbCB0aGUgdXBkYXRlIGxpZmVjeWNsZSB3aGVuIGl0IGlzIGJlaW5nIHVwZGF0ZWQsIGJ1dCBvbmx5IHdoZW4gaXQgaXMgcGFydCBvZiB0aGUgc2NlbmUuXG4gIC8vIFNraXAgdXBkYXRlcyB0byB0aGUgYG9uVXBkYXRlYCBwcm9wIGl0c2VsZlxuICBjb25zdCBpc0NpcmN1bGFyID0gY2hhbmdlcy5sZW5ndGggPT09IDEgJiYgY2hhbmdlc1swXVswXSA9PT0gJ29uVXBkYXRlJztcbiAgaWYgKCFpc0NpcmN1bGFyICYmIGNoYW5nZXMubGVuZ3RoICYmIChfaW5zdGFuY2UkX19yM2YyID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmMi5wYXJlbnQpIHVwZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2YzLCBfaW5zdGFuY2UkX19yM2YzJHJvb3Q7XG4gIGNvbnN0IHN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IChfaW5zdGFuY2UkX19yM2YzJHJvb3QgPSBfaW5zdGFuY2UkX19yM2YzLnJvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YzJHJvb3QuZ2V0U3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZjMkcm9vdC5nZXRTdGF0ZSgpO1xuICBpZiAoc3RhdGUgJiYgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID09PSAwKSBzdGF0ZS5pbnZhbGlkYXRlKCk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5vblVwZGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2Uub25VcGRhdGUoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy85MlxuICAvLyBEbyBub3QgbWVzcyB3aXRoIHRoZSBjYW1lcmEgaWYgaXQgYmVsb25ncyB0byB0aGUgdXNlclxuICBpZiAoIWNhbWVyYS5tYW51YWwpIHtcbiAgICBpZiAoaXNPcnRob2dyYXBoaWNDYW1lcmEoY2FtZXJhKSkge1xuICAgICAgY2FtZXJhLmxlZnQgPSBzaXplLndpZHRoIC8gLTI7XG4gICAgICBjYW1lcmEucmlnaHQgPSBzaXplLndpZHRoIC8gMjtcbiAgICAgIGNhbWVyYS50b3AgPSBzaXplLmhlaWdodCAvIDI7XG4gICAgICBjYW1lcmEuYm90dG9tID0gc2l6ZS5oZWlnaHQgLyAtMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FtZXJhLmFzcGVjdCA9IHNpemUud2lkdGggLyBzaXplLmhlaWdodDtcbiAgICB9XG4gICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xNzhcbiAgICAvLyBVcGRhdGUgbWF0cml4IHdvcmxkIHNpbmNlIHRoZSByZW5kZXJlciBpcyBhIGZyYW1lIGxhdGVcbiAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWQoZXZlbnQpIHtcbiAgcmV0dXJuIChldmVudC5ldmVudE9iamVjdCB8fCBldmVudC5vYmplY3QpLnV1aWQgKyAnLycgKyBldmVudC5pbmRleCArIGV2ZW50Lmluc3RhbmNlSWQ7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC90cmVlL21haW4vcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlciNnZXRjdXJyZW50ZXZlbnRwcmlvcml0eVxuLy8gR2l2ZXMgUmVhY3QgYSBjbHVlIGFzIHRvIGhvdyBpbXBvcnQgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb24gaXNcbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoKSB7XG4gIHZhciBfZ2xvYmFsU2NvcGUkZXZlbnQ7XG4gIC8vIEdldCBhIGhhbmRsZSB0byB0aGUgY3VycmVudCBnbG9iYWwgc2NvcGUgaW4gd2luZG93IGFuZCB3b3JrZXIgY29udGV4dHMgaWYgYWJsZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjQ5M1xuICBjb25zdCBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmIHx8IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdztcbiAgaWYgKCFnbG9iYWxTY29wZSkgcmV0dXJuIERlZmF1bHRFdmVudFByaW9yaXR5O1xuICBjb25zdCBuYW1lID0gKF9nbG9iYWxTY29wZSRldmVudCA9IGdsb2JhbFNjb3BlLmV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbFNjb3BlJGV2ZW50LnR5cGU7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ2NsaWNrJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnZGJsY2xpY2snOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgcmV0dXJuIERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbiAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgY2FzZSAncG9pbnRlcm91dCc6XG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJlbnRlcic6XG4gICAgY2FzZSAncG9pbnRlcmxlYXZlJzpcbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxufVxuXG4vKipcclxuICogUmVsZWFzZSBwb2ludGVyIGNhcHR1cmVzLlxyXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXHJcbiAqL1xuZnVuY3Rpb24gcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoY2FwdHVyZWRNYXAsIG9iaiwgY2FwdHVyZXMsIHBvaW50ZXJJZCkge1xuICBjb25zdCBjYXB0dXJlRGF0YSA9IGNhcHR1cmVzLmdldChvYmopO1xuICBpZiAoY2FwdHVyZURhdGEpIHtcbiAgICBjYXB0dXJlcy5kZWxldGUob2JqKTtcbiAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBjYXB0dXJpbmcgb2JqZWN0IGZvciB0aGlzIHBvaW50ZXJcbiAgICBpZiAoY2FwdHVyZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgY2FwdHVyZWRNYXAuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICBjYXB0dXJlRGF0YS50YXJnZXQucmVsZWFzZVBvaW50ZXJDYXB0dXJlKHBvaW50ZXJJZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZW1vdmVJbnRlcmFjdGl2aXR5KHN0b3JlLCBvYmplY3QpIHtcbiAgY29uc3Qge1xuICAgIGludGVybmFsXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAvLyBSZW1vdmVzIGV2ZXJ5IHRyYWNlIG9mIGFuIG9iamVjdCBmcm9tIHRoZSBkYXRhIHN0b3JlXG4gIGludGVybmFsLmludGVyYWN0aW9uID0gaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaW5pdGlhbEhpdHMgPSBpbnRlcm5hbC5pbml0aWFsSGl0cy5maWx0ZXIobyA9PiBvICE9PSBvYmplY3QpO1xuICBpbnRlcm5hbC5ob3ZlcmVkLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuZXZlbnRPYmplY3QgPT09IG9iamVjdCB8fCB2YWx1ZS5vYmplY3QgPT09IG9iamVjdCkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgaW50ZXJuYWwuaG92ZXJlZC5kZWxldGUoa2V5KTtcbiAgICB9XG4gIH0pO1xuICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5mb3JFYWNoKChjYXB0dXJlcywgcG9pbnRlcklkKSA9PiB7XG4gICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIG9iamVjdCwgY2FwdHVyZXMsIHBvaW50ZXJJZCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnRzKHN0b3JlKSB7XG4gIC8qKiBDYWxjdWxhdGVzIGRlbHRhICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkeCA9IGV2ZW50Lm9mZnNldFggLSBpbnRlcm5hbC5pbml0aWFsQ2xpY2tbMF07XG4gICAgY29uc3QgZHkgPSBldmVudC5vZmZzZXRZIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzFdO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhbiBpbnN0YW5jZSBoYXMgYSB2YWxpZCBwb2ludGVyLWV2ZW50IHJlZ2lzdGVyZWQsIHRoaXMgZXhjbHVkZXMgc2Nyb2xsLCBjbGlja3MgZXRjICovXG4gIGZ1bmN0aW9uIGZpbHRlclBvaW50ZXJFdmVudHMob2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzLmZpbHRlcihvYmogPT4gWydNb3ZlJywgJ092ZXInLCAnRW50ZXInLCAnT3V0JywgJ0xlYXZlJ10uc29tZShuYW1lID0+IHtcbiAgICAgIHZhciBfcjNmO1xuICAgICAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5oYW5kbGVyc1snb25Qb2ludGVyJyArIG5hbWVdO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcikge1xuICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBkdXBsaWNhdGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICAvLyBBbGxvdyBjYWxsZXJzIHRvIGVsaW1pbmF0ZSBldmVudCBvYmplY3RzXG4gICAgY29uc3QgZXZlbnRzT2JqZWN0cyA9IGZpbHRlciA/IGZpbHRlcihzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbikgOiBzdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbjtcbiAgICAvLyBSZXNldCBhbGwgcmF5Y2FzdGVyIGNhbWVyYXMgdG8gdW5kZWZpbmVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHNPYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShldmVudHNPYmplY3RzW2ldKTtcbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXN0YXRlLnByZXZpb3VzUm9vdCkge1xuICAgICAgLy8gTWFrZSBzdXJlIHJvb3QtbGV2ZWwgcG9pbnRlciBhbmQgcmF5IGFyZSBzZXQgdXBcbiAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVSYXljYXN0KG9iaikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUob2JqKTtcbiAgICAgIC8vIFNraXAgZXZlbnQgaGFuZGxpbmcgd2hlbiBub0V2ZW50cyBpcyBzZXQsIG9yIHdoZW4gdGhlIHJheWNhc3RlcnMgY2FtZXJhIGlzIG51bGxcbiAgICAgIGlmICghc3RhdGUgfHwgIXN0YXRlLmV2ZW50cy5lbmFibGVkIHx8IHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IG51bGwpIHJldHVybiBbXTtcblxuICAgICAgLy8gV2hlbiB0aGUgY2FtZXJhIGlzIHVuZGVmaW5lZCB3ZSBoYXZlIHRvIGNhbGwgdGhlIGV2ZW50IGxheWVycyB1cGRhdGUgZnVuY3Rpb25cbiAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRwcmV2aW91c1Jvb3Q7XG4gICAgICAgIHN0YXRlLmV2ZW50cy5jb21wdXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuY29tcHV0ZShldmVudCwgc3RhdGUsIChfc3RhdGUkcHJldmlvdXNSb290ID0gc3RhdGUucHJldmlvdXNSb290KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gSWYgdGhlIGNhbWVyYSBpcyBzdGlsbCB1bmRlZmluZWQgd2UgaGF2ZSB0byBza2lwIHRoaXMgbGF5ZXIgZW50aXJlbHlcbiAgICAgICAgaWYgKHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPT09IHVuZGVmaW5lZCkgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVyc2VjdCBvYmplY3QgYnkgb2JqZWN0XG4gICAgICByZXR1cm4gc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA/IHN0YXRlLnJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3Qob2JqLCB0cnVlKSA6IFtdO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXZlbnRzXG4gICAgbGV0IGhpdHMgPSBldmVudHNPYmplY3RzXG4gICAgLy8gSW50ZXJzZWN0IG9iamVjdHNcbiAgICAuZmxhdE1hcChoYW5kbGVSYXljYXN0KVxuICAgIC8vIFNvcnQgYnkgZXZlbnQgcHJpb3JpdHkgYW5kIGRpc3RhbmNlXG4gICAgLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGdldFJvb3RTdGF0ZShhLm9iamVjdCk7XG4gICAgICBjb25zdCBiU3RhdGUgPSBnZXRSb290U3RhdGUoYi5vYmplY3QpO1xuICAgICAgaWYgKCFhU3RhdGUgfHwgIWJTdGF0ZSkgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgICAgcmV0dXJuIGJTdGF0ZS5ldmVudHMucHJpb3JpdHkgLSBhU3RhdGUuZXZlbnRzLnByaW9yaXR5IHx8IGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuICAgIH0pXG4gICAgLy8gRmlsdGVyIG91dCBkdXBsaWNhdGVzXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbWFrZUlkKGl0ZW0pO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMuaGFzKGlkKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHVwbGljYXRlcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xNjAzMVxuICAgIC8vIEFsbG93IGN1c3RvbSB1c2VybGFuZCBpbnRlcnNlY3Qgc29ydCBvcmRlciwgdGhpcyBsaWtlbHkgb25seSBtYWtlcyBzZW5zZSBvbiB0aGUgcm9vdCBmaWx0ZXJcbiAgICBpZiAoc3RhdGUuZXZlbnRzLmZpbHRlcikgaGl0cyA9IHN0YXRlLmV2ZW50cy5maWx0ZXIoaGl0cywgc3RhdGUpO1xuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBldmVudHMsIGZpbmQgdGhlIGV2ZW50IHNvdXJjZSAoZXZlbnRPYmplY3QpXG4gICAgZm9yIChjb25zdCBoaXQgb2YgaGl0cykge1xuICAgICAgbGV0IGV2ZW50T2JqZWN0ID0gaGl0Lm9iamVjdDtcbiAgICAgIC8vIEJ1YmJsZSBldmVudCB1cFxuICAgICAgd2hpbGUgKGV2ZW50T2JqZWN0KSB7XG4gICAgICAgIHZhciBfcjNmMjtcbiAgICAgICAgaWYgKChfcjNmMiA9IGV2ZW50T2JqZWN0Ll9fcjNmKSAhPSBudWxsICYmIF9yM2YyLmV2ZW50Q291bnQpIGludGVyc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgLi4uaGl0LFxuICAgICAgICAgIGV2ZW50T2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudE9iamVjdCA9IGV2ZW50T2JqZWN0LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaW50ZXJhY3Rpb24gaXMgY2FwdHVyZWQsIG1ha2UgYWxsIGNhcHR1cmluZyB0YXJnZXRzIHBhcnQgb2YgdGhlIGludGVyc2VjdC5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgc3RhdGUuaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgIGZvciAobGV0IGNhcHR1cmVEYXRhIG9mIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghZHVwbGljYXRlcy5oYXMobWFrZUlkKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbikpKSBpbnRlcnNlY3Rpb25zLnB1c2goY2FwdHVyZURhdGEuaW50ZXJzZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cblxuICAvKiogIEhhbmRsZXMgaW50ZXJzZWN0aW9ucyBieSBmb3J3YXJkaW5nIHRoZW0gdG8gaGFuZGxlcnMgKi9cbiAgZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0cyhpbnRlcnNlY3Rpb25zLCBldmVudCwgZGVsdGEsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgIC8vIElmIGFueXRoaW5nIGhhcyBiZWVuIGZvdW5kLCBmb3J3YXJkIGl0IHRvIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICBpZiAoaW50ZXJzZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSB7XG4gICAgICAgIHN0b3BwZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBoaXQgb2YgaW50ZXJzZWN0aW9ucykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldFJvb3RTdGF0ZShoaXQub2JqZWN0KSB8fCByb290U3RhdGU7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBjYW1lcmEsXG4gICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB1bnByb2plY3RlZFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjMocG9pbnRlci54LCBwb2ludGVyLnksIDApLnVucHJvamVjdChjYW1lcmEpO1xuICAgICAgICBjb25zdCBoYXNQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICB2YXIgX2ludGVybmFsJGNhcHR1cmVkTWFwLCBfaW50ZXJuYWwkY2FwdHVyZWRNYXAyO1xuICAgICAgICAgIHJldHVybiAoX2ludGVybmFsJGNhcHR1cmVkTWFwID0gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX2ludGVybmFsJGNhcHR1cmVkTWFwMi5oYXMoaGl0LmV2ZW50T2JqZWN0KSkgIT0gbnVsbCA/IF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA6IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRQb2ludGVyQ2FwdHVyZSA9IGlkID0+IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlRGF0YSA9IHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbjogaGl0LFxuICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBhZGQgdGhlIGhpdCB0byB0aGVcbiAgICAgICAgICAgIC8vIGV2ZW50IGNhcHR1cmVkTWFwLlxuICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKS5zZXQoaGl0LmV2ZW50T2JqZWN0LCBjYXB0dXJlRGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwb2ludGVySWQgd2FzIG5vdCBwcmV2aW91c2x5IGNhcHR1cmVkLCB3ZSBjcmVhdGUgYSBtYXBcbiAgICAgICAgICAgIC8vIGNvbnRhaW5pbmcgdGhlIGhpdE9iamVjdCwgYW5kIHRoZSBoaXQuIGhpdE9iamVjdCBpcyB1c2VkIGZvclxuICAgICAgICAgICAgLy8gZmFzdGVyIGFjY2Vzcy5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLnNldChpZCwgbmV3IE1hcChbW2hpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGFdXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0UG9pbnRlckNhcHR1cmUoaWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZWxlYXNlUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZXMgPSBpbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgcmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUoaW50ZXJuYWwuY2FwdHVyZWRNYXAsIGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZXMsIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIG5hdGl2ZSBldmVudCBwcm9wc1xuICAgICAgICBsZXQgZXh0cmFjdEV2ZW50UHJvcHMgPSB7fTtcbiAgICAgICAgLy8gVGhpcyBpdGVyYXRlcyBvdmVyIHRoZSBldmVudCdzIHByb3BlcnRpZXMgaW5jbHVkaW5nIHRoZSBpbmhlcml0ZWQgb25lcy4gTmF0aXZlIFBvaW50ZXJFdmVudHMgaGF2ZSBtb3N0IG9mIHRoZWlyIHByb3BzIGFzIGdldHRlcnMgd2hpY2ggYXJlIGluaGVyaXRlZCwgYnV0IHBvbHlmaWxsZWQgUG9pbnRlckV2ZW50cyBoYXZlIHRoZW0gYWxsIGFzIHRoZWlyIG93biBwcm9wZXJ0aWVzIChpLmUuIG5vdCBpbmhlcml0ZWQpLiBXZSBjYW4ndCB1c2UgT2JqZWN0LmtleXMoKSBvciBPYmplY3QuZW50cmllcygpIGFzIHRoZXkgb25seSByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzOyBub3IgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV2ZW50KSBhcyB0aGF0ICpkb2Vzbid0KiByZXR1cm4gXCJvd25cIiBwcm9wZXJ0aWVzLCBvbmx5IGluaGVyaXRlZCBvbmVzLlxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIGV2ZW50KSB7XG4gICAgICAgICAgbGV0IHByb3BlcnR5ID0gZXZlbnRbcHJvcF07XG4gICAgICAgICAgLy8gT25seSBjb3B5IG92ZXIgYXRvbWljcywgbGVhdmUgZnVuY3Rpb25zIGFsb25lIGFzIHRoZXNlIHNob3VsZCBiZVxuICAgICAgICAgIC8vIGNhbGxlZCBhcyBldmVudC5uYXRpdmVFdmVudC5mbigpXG4gICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJykgZXh0cmFjdEV2ZW50UHJvcHNbcHJvcF0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF5Y2FzdEV2ZW50ID0ge1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICAuLi5leHRyYWN0RXZlbnRQcm9wcyxcbiAgICAgICAgICBwb2ludGVyLFxuICAgICAgICAgIGludGVyc2VjdGlvbnMsXG4gICAgICAgICAgc3RvcHBlZDogbG9jYWxTdGF0ZS5zdG9wcGVkLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIHVucHJvamVjdGVkUG9pbnQsXG4gICAgICAgICAgcmF5OiByYXljYXN0ZXIucmF5LFxuICAgICAgICAgIGNhbWVyYTogY2FtZXJhLFxuICAgICAgICAgIC8vIEhpamFjayBzdG9wUHJvcGFnYXRpb24sIHdoaWNoIGp1c3Qgc2V0cyBhIGZsYWdcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy81OTZcbiAgICAgICAgICAgIC8vIEV2ZW50cyBhcmUgbm90IGFsbG93ZWQgdG8gc3RvcCBwcm9wYWdhdGlvbiBpZiB0aGUgcG9pbnRlciBoYXMgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZXNGb3JQb2ludGVyID0gJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYXV0aG9yaXplIHN0b3BQcm9wYWdhdGlvbi4uLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gLi4uaWYgdGhpcyBwb2ludGVyIGhhc24ndCBiZWVuIGNhcHR1cmVkXG4gICAgICAgICAgICAhY2FwdHVyZXNGb3JQb2ludGVyIHx8XG4gICAgICAgICAgICAvLyAuLi4gb3IgaWYgdGhlIGhpdCBvYmplY3QgaXMgY2FwdHVyaW5nIHRoZSBwb2ludGVyXG4gICAgICAgICAgICBjYXB0dXJlc0ZvclBvaW50ZXIuaGFzKGhpdC5ldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmF5Y2FzdEV2ZW50LnN0b3BwZWQgPSBsb2NhbFN0YXRlLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBQcm9wYWdhdGlvbiBpcyBzdG9wcGVkLCByZW1vdmUgYWxsIG90aGVyIGhvdmVyIHJlY29yZHNcbiAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgaGFuZGxlciBpcyBvbmx5IGFsbG93ZWQgdG8gZmx1c2ggb3RoZXIgaGFuZGxlcnMgaWYgaXQgaXMgaG92ZXJlZCBpdHNlbGZcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmhvdmVyZWQuc2l6ZSAmJiBBcnJheS5mcm9tKGludGVybmFsLmhvdmVyZWQudmFsdWVzKCkpLmZpbmQoaSA9PiBpLmV2ZW50T2JqZWN0ID09PSBoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gT2JqZWN0cyBjYW5ub3QgZmx1c2ggb3V0IGhpZ2hlciB1cCBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGNhdWdodCB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBoaWdoZXIgPSBpbnRlcnNlY3Rpb25zLnNsaWNlKDAsIGludGVyc2VjdGlvbnMuaW5kZXhPZihoaXQpKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxQb2ludGVyKFsuLi5oaWdoZXIsIGhpdF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHRhcmdldCBhbmQgY3VycmVudFRhcmdldFxuICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDoge1xuICAgICAgICAgICAgaGFzUG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICBzZXRQb2ludGVyQ2FwdHVyZSxcbiAgICAgICAgICAgIHJlbGVhc2VQb2ludGVyQ2FwdHVyZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF0aXZlRXZlbnQ6IGV2ZW50XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbCBzdWJzY3JpYmVyc1xuICAgICAgICBjYWxsYmFjayhyYXljYXN0RXZlbnQpO1xuICAgICAgICAvLyBFdmVudCBidWJibGluZyBtYXkgYmUgaW50ZXJydXB0ZWQgYnkgc3RvcFByb3BhZ2F0aW9uXG4gICAgICAgIGlmIChsb2NhbFN0YXRlLnN0b3BwZWQgPT09IHRydWUpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxQb2ludGVyKGludGVyc2VjdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcm5hbFxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGZvciAoY29uc3QgaG92ZXJlZE9iaiBvZiBpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKSB7XG4gICAgICAvLyBXaGVuIG5vIG9iamVjdHMgd2VyZSBoaXQgb3IgdGhlIHRoZSBob3ZlcmVkIG9iamVjdCB3YXNuJ3QgZm91bmQgdW5kZXJuZWF0aCB0aGUgY3Vyc29yXG4gICAgICAvLyB3ZSBjYWxsIG9uUG9pbnRlck91dCBhbmQgZGVsZXRlIHRoZSBvYmplY3QgZnJvbSB0aGUgaG92ZXJlZC1lbGVtZW50cyBtYXBcbiAgICAgIGlmICghaW50ZXJzZWN0aW9ucy5sZW5ndGggfHwgIWludGVyc2VjdGlvbnMuZmluZChoaXQgPT4gaGl0Lm9iamVjdCA9PT0gaG92ZXJlZE9iai5vYmplY3QgJiYgaGl0LmluZGV4ID09PSBob3ZlcmVkT2JqLmluZGV4ICYmIGhpdC5pbnN0YW5jZUlkID09PSBob3ZlcmVkT2JqLmluc3RhbmNlSWQpKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gaG92ZXJlZE9iai5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG4gICAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKG1ha2VJZChob3ZlcmVkT2JqKSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgICAvLyBDbGVhciBvdXQgaW50ZXJzZWN0cywgdGhleSBhcmUgb3V0ZGF0ZWQgYnkgbm93XG4gICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIC4uLmhvdmVyZWRPYmosXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdXQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlck91dChkYXRhKTtcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJMZWF2ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTGVhdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnRlck1pc3NlZChldmVudCwgb2JqZWN0cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3RzW2ldLl9fcjNmO1xuICAgICAgaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZCA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnMub25Qb2ludGVyTWlzc2VkKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlcihuYW1lKSB7XG4gICAgLy8gRGVhbCB3aXRoIGNhbmNlbGF0aW9uXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdvblBvaW50ZXJMZWF2ZSc6XG4gICAgICBjYXNlICdvblBvaW50ZXJDYW5jZWwnOlxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICBjYXNlICdvbkxvc3RQb2ludGVyQ2FwdHVyZSc6XG4gICAgICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaW50ZXJuYWxcbiAgICAgICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZXZlbnQgJiYgaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGV2ZW50LnBvaW50ZXJJZCkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgZXZlbnQgaW50ZXJmYWNlIGhhZCBvbkxvc3RQb2ludGVyQ2FwdHVyZSwgd2UnZCBjYWxsIGl0IGhlcmUgb24gZXZlcnlcbiAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0J3MgZ2V0dGluZyByZW1vdmVkLiBXZSBjYWxsIGl0IG9uIHRoZSBuZXh0IGZyYW1lIGJlY2F1c2Ugb25Mb3N0UG9pbnRlckNhcHR1cmVcbiAgICAgICAgICAgIC8vIGZpcmVzIGJlZm9yZSBvblBvaW50ZXJVcC4gT3RoZXJ3aXNlIHBvaW50ZXJVcCB3b3VsZCBuZXZlciBiZSBjYWxsZWQgaWYgdGhlIGV2ZW50IGRpZG4ndFxuICAgICAgICAgICAgLy8gaGFwcGVuIGluIHRoZSBvYmplY3QgaXQgb3JpZ2luYXRlZCBmcm9tLCBsZWF2aW5nIGNvbXBvbmVudHMgaW4gYSBpbi1iZXR3ZWVuIHN0YXRlLlxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgLy8gT25seSByZWxlYXNlIGlmIHBvaW50ZXItdXAgZGlkbid0IGRvIGl0IGFscmVhZHlcbiAgICAgICAgICAgICAgaWYgKGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZGVsZXRlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBbnkgb3RoZXIgcG9pbnRlciBnb2VzIGhlcmUgLi4uXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZCxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBwcmVwYXJlUmF5KGV2ZW50KVxuICAgICAgaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQgPSBldmVudDtcblxuICAgICAgLy8gR2V0IGZyZXNoIGludGVyc2VjdHNcbiAgICAgIGNvbnN0IGlzUG9pbnRlck1vdmUgPSBuYW1lID09PSAnb25Qb2ludGVyTW92ZSc7XG4gICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBuYW1lID09PSAnb25DbGljaycgfHwgbmFtZSA9PT0gJ29uQ29udGV4dE1lbnUnIHx8IG5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJztcbiAgICAgIGNvbnN0IGZpbHRlciA9IGlzUG9pbnRlck1vdmUgPyBmaWx0ZXJQb2ludGVyRXZlbnRzIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaGl0cyA9IGludGVyc2VjdChldmVudCwgZmlsdGVyKTtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXNDbGlja0V2ZW50ID8gY2FsY3VsYXRlRGlzdGFuY2UoZXZlbnQpIDogMDtcblxuICAgICAgLy8gU2F2ZSBpbml0aWFsIGNvb3JkaW5hdGVzIG9uIHBvaW50ZXItZG93blxuICAgICAgaWYgKG5hbWUgPT09ICdvblBvaW50ZXJEb3duJykge1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsQ2xpY2sgPSBbZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gICAgICAgIGludGVybmFsLmluaXRpYWxIaXRzID0gaGl0cy5tYXAoaGl0ID0+IGhpdC5ldmVudE9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgY2xpY2sgeWllbGRzIG5vIHJlc3VsdHMsIHBhc3MgaXQgYmFjayB0byB0aGUgdXNlciBhcyBhIG1pc3NcbiAgICAgIC8vIE1pc3NlZCBldmVudHMgaGF2ZSB0byBjb21lIGZpcnN0IGluIG9yZGVyIHRvIGVzdGFibGlzaCB1c2VyLWxhbmQgc2lkZS1lZmZlY3QgY2xlYW4gdXBcbiAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgIWhpdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkZWx0YSA8PSAyKSB7XG4gICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIGlmIChvblBvaW50ZXJNaXNzZWQpIG9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRha2UgY2FyZSBvZiB1bmhvdmVyXG4gICAgICBpZiAoaXNQb2ludGVyTW92ZSkgY2FuY2VsUG9pbnRlcihoaXRzKTtcbiAgICAgIGZ1bmN0aW9uIG9uSW50ZXJzZWN0KGRhdGEpIHtcbiAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBkYXRhLmV2ZW50T2JqZWN0O1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGV2ZW50T2JqZWN0Ll9fcjNmO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycztcblxuICAgICAgICAvLyBDaGVjayBwcmVzZW5jZSBvZiBoYW5kbGVyc1xuICAgICAgICBpZiAoIShpbnN0YW5jZSAhPSBudWxsICYmIGluc3RhbmNlLmV2ZW50Q291bnQpKSByZXR1cm47XG5cbiAgICAgICAgLypcclxuICAgICAgICBNQVlCRSBUT0RPLCBERUxFVEUgSUYgTk9UOiBcclxuICAgICAgICAgIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgY2FwdHVyZWQsIGNhcHR1cmVkIGV2ZW50cyBzaG91bGQgbm90IGhhdmUgaW50ZXJzZWN0cyBydW5uaW5nIGluIHBhcmFsbGVsXHJcbiAgICAgICAgICBCdXQgd291bGRuJ3QgaXQgYmUgYmV0dGVyIHRvIGp1c3QgcmVwbGFjZSBjYXB0dXJlZE1hcCB3aXRoIGEgc2luZ2xlIGVudHJ5P1xyXG4gICAgICAgICAgQWxzbywgYXJlIHdlIE9LIHdpdGggc3RyYWlnaHQgdXAgbWFraW5nIHBpY2tpbmcgdXAgbXVsdGlwbGUgb2JqZWN0cyBpbXBvc3NpYmxlP1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcG9pbnRlcklkID0gKGRhdGEgYXMgVGhyZWVFdmVudDxQb2ludGVyRXZlbnQ+KS5wb2ludGVySWQgICAgICAgIFxyXG4gICAgICAgIGlmIChwb2ludGVySWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgY29uc3QgY2FwdHVyZWRNZXNoU2V0ID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KHBvaW50ZXJJZClcclxuICAgICAgICAgIGlmIChjYXB0dXJlZE1lc2hTZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlZE1lc2hTZXQuZ2V0KGV2ZW50T2JqZWN0KVxyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZWQgJiYgY2FwdHVyZWQubG9jYWxTdGF0ZS5zdG9wcGVkKSByZXR1cm5cclxuICAgICAgICAgIH1cclxuICAgICAgICB9Ki9cblxuICAgICAgICBpZiAoaXNQb2ludGVyTW92ZSkge1xuICAgICAgICAgIC8vIE1vdmUgZXZlbnQgLi4uXG4gICAgICAgICAgaWYgKGhhbmRsZXJzLm9uUG9pbnRlck92ZXIgfHwgaGFuZGxlcnMub25Qb2ludGVyRW50ZXIgfHwgaGFuZGxlcnMub25Qb2ludGVyT3V0IHx8IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKSB7XG4gICAgICAgICAgICAvLyBXaGVuIGVudGVyIG9yIG91dCBpcyBwcmVzZW50IHRha2UgY2FyZSBvZiBob3Zlci1zdGF0ZVxuICAgICAgICAgICAgY29uc3QgaWQgPSBtYWtlSWQoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBob3ZlcmVkSXRlbSA9IGludGVybmFsLmhvdmVyZWQuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmICghaG92ZXJlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXNuJ3QgcHJldmlvdXNseSBob3ZlcmVkLCBib29rIGl0IGFuZCBjYWxsIGl0cyBoYW5kbGVyXG4gICAgICAgICAgICAgIGludGVybmFsLmhvdmVyZWQuc2V0KGlkLCBkYXRhKTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3ZlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyT3ZlcihkYXRhKTtcbiAgICAgICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyRW50ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckVudGVyKGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbS5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3Qgd2FzIHByZXZpb3VzbHkgaG92ZXJlZCBhbmQgc3RvcHBlZCwgd2Ugc2hvdWxkbid0IGFsbG93IG90aGVyIGl0ZW1zIHRvIHByb2NlZWRcbiAgICAgICAgICAgICAgZGF0YS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2FsbCBtb3VzZSBtb3ZlXG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTW92ZSA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyTW92ZShkYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbGwgb3RoZXIgZXZlbnRzIC4uLlxuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1tuYW1lXTtcbiAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgLy8gRm9yd2FyZCBhbGwgZXZlbnRzIGJhY2sgdG8gdGhlaXIgcmVzcGVjdGl2ZSBoYW5kbGVycyB3aXRoIHRoZSBleGNlcHRpb24gb2YgY2xpY2sgZXZlbnRzLFxuICAgICAgICAgICAgLy8gd2hpY2ggbXVzdCB1c2UgdGhlIGluaXRpYWwgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoIWlzQ2xpY2tFdmVudCB8fCBpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhldmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgLy8gTWlzc2VkIGV2ZW50cyBoYXZlIHRvIGNvbWUgZmlyc3RcbiAgICAgICAgICAgICAgcG9pbnRlck1pc3NlZChldmVudCwgaW50ZXJuYWwuaW50ZXJhY3Rpb24uZmlsdGVyKG9iamVjdCA9PiAhaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMob2JqZWN0KSkpO1xuICAgICAgICAgICAgICAvLyBOb3cgY2FsbCB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICBoYW5kbGVyKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIG9uUG9pbnRlck1pc3NlZCBvbiBhbGwgZWxlbWVudHMgdGhhdCBoYXZlIHBvaW50ZXIgb3Zlci9vdXQgaGFuZGxlcnMsIGJ1dCBub3QgY2xpY2sgYW5kIHdlcmVuJ3QgaGl0XG4gICAgICAgICAgICBpZiAoaXNDbGlja0V2ZW50ICYmIGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBoYW5kbGVJbnRlcnNlY3RzKGhpdHMsIGV2ZW50LCBkZWx0YSwgb25JbnRlcnNlY3QpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH07XG59XG5cbi8vIEtleXMgdGhhdCBzaG91bGRuJ3QgYmUgY29waWVkIGJldHdlZW4gUjNGIHN0b3Jlc1xuY29uc3QgcHJpdmF0ZUtleXMgPSBbJ3NldCcsICdnZXQnLCAnc2V0U2l6ZScsICdzZXRGcmFtZWxvb3AnLCAnc2V0RHByJywgJ2V2ZW50cycsICdpbnZhbGlkYXRlJywgJ2FkdmFuY2UnLCAnc2l6ZScsICd2aWV3cG9ydCddO1xuY29uc3QgaXNSZW5kZXJlciA9IGRlZiA9PiAhIShkZWYgIT0gbnVsbCAmJiBkZWYucmVuZGVyKTtcbmNvbnN0IGNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IGNyZWF0ZVN0b3JlID0gKGludmFsaWRhdGUsIGFkdmFuY2UpID0+IHtcbiAgY29uc3Qgcm9vdFN0YXRlID0gY3JlYXRlKChzZXQsIGdldCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCBkZWZhdWx0VGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBjb25zdCB0ZW1wVGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhID0gZ2V0KCkuY2FtZXJhLCB0YXJnZXQgPSBkZWZhdWx0VGFyZ2V0LCBzaXplID0gZ2V0KCkuc2l6ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB0b3AsXG4gICAgICAgIGxlZnRcbiAgICAgIH0gPSBzaXplO1xuICAgICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMykgdGVtcFRhcmdldC5jb3B5KHRhcmdldCk7ZWxzZSB0ZW1wVGFyZ2V0LnNldCguLi50YXJnZXQpO1xuICAgICAgY29uc3QgZGlzdGFuY2UgPSBjYW1lcmEuZ2V0V29ybGRQb3NpdGlvbihwb3NpdGlvbikuZGlzdGFuY2VUbyh0ZW1wVGFyZ2V0KTtcbiAgICAgIGlmIChpc09ydGhvZ3JhcGhpY0NhbWVyYShjYW1lcmEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoIC8gY2FtZXJhLnpvb20sXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IDEsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmb3YgPSBjYW1lcmEuZm92ICogTWF0aC5QSSAvIDE4MDsgLy8gY29udmVydCB2ZXJ0aWNhbCBmb3YgdG8gcmFkaWFuc1xuICAgICAgICBjb25zdCBoID0gMiAqIE1hdGgudGFuKGZvdiAvIDIpICogZGlzdGFuY2U7IC8vIHZpc2libGUgaGVpZ2h0XG4gICAgICAgIGNvbnN0IHcgPSBoICogKHdpZHRoIC8gaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgZmFjdG9yOiB3aWR0aCAvIHcsXG4gICAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgICAgYXNwZWN0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwZXJmb3JtYW5jZVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc2V0UGVyZm9ybWFuY2VDdXJyZW50ID0gY3VycmVudCA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgIHBlcmZvcm1hbmNlOiB7XG4gICAgICAgIC4uLnN0YXRlLnBlcmZvcm1hbmNlLFxuICAgICAgICBjdXJyZW50XG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBvaW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHtcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIE1vY2sgb2JqZWN0cyB0aGF0IGhhdmUgdG8gYmUgY29uZmlndXJlZFxuICAgICAgZ2w6IG51bGwsXG4gICAgICBjYW1lcmE6IG51bGwsXG4gICAgICByYXljYXN0ZXI6IG51bGwsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgcHJpb3JpdHk6IDEsXG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGNvbm5lY3RlZDogZmFsc2VcbiAgICAgIH0sXG4gICAgICB4cjogbnVsbCxcbiAgICAgIHNjZW5lOiBudWxsLFxuICAgICAgaW52YWxpZGF0ZTogKGZyYW1lcyA9IDEpID0+IGludmFsaWRhdGUoZ2V0KCksIGZyYW1lcyksXG4gICAgICBhZHZhbmNlOiAodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzKSA9PiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cywgZ2V0KCkpLFxuICAgICAgbGVnYWN5OiBmYWxzZSxcbiAgICAgIGxpbmVhcjogZmFsc2UsXG4gICAgICBmbGF0OiBmYWxzZSxcbiAgICAgIGNvbnRyb2xzOiBudWxsLFxuICAgICAgY2xvY2s6IG5ldyBUSFJFRS5DbG9jaygpLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgZnJhbWVsb29wOiAnYWx3YXlzJyxcbiAgICAgIG9uUG9pbnRlck1pc3NlZDogdW5kZWZpbmVkLFxuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgY3VycmVudDogMSxcbiAgICAgICAgbWluOiAwLjUsXG4gICAgICAgIG1heDogMSxcbiAgICAgICAgZGVib3VuY2U6IDIwMCxcbiAgICAgICAgcmVncmVzczogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gZ2V0KCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGltZW91dFxuICAgICAgICAgIGlmIChwZXJmb3JtYW5jZVRpbWVvdXQpIGNsZWFyVGltZW91dChwZXJmb3JtYW5jZVRpbWVvdXQpO1xuICAgICAgICAgIC8vIFNldCBsb3dlciBib3VuZCBwZXJmb3JtYW5jZVxuICAgICAgICAgIGlmIChzdGF0ZS5wZXJmb3JtYW5jZS5jdXJyZW50ICE9PSBzdGF0ZS5wZXJmb3JtYW5jZS5taW4pIHNldFBlcmZvcm1hbmNlQ3VycmVudChzdGF0ZS5wZXJmb3JtYW5jZS5taW4pO1xuICAgICAgICAgIC8vIEdvIGJhY2sgdG8gdXBwZXIgYm91bmQgcGVyZm9ybWFuY2UgYWZ0ZXIgYSB3aGlsZSB1bmxlc3Mgc29tZXRoaW5nIHJlZ3Jlc3NlcyBtZWFud2hpbGVcbiAgICAgICAgICBwZXJmb3JtYW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldFBlcmZvcm1hbmNlQ3VycmVudChnZXQoKS5wZXJmb3JtYW5jZS5tYXgpLCBzdGF0ZS5wZXJmb3JtYW5jZS5kZWJvdW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgaW5pdGlhbERwcjogMCxcbiAgICAgICAgZHByOiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIGFzcGVjdDogMCxcbiAgICAgICAgZGlzdGFuY2U6IDAsXG4gICAgICAgIGZhY3RvcjogMCxcbiAgICAgICAgZ2V0Q3VycmVudFZpZXdwb3J0XG4gICAgICB9LFxuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKSxcbiAgICAgIHNldFNpemU6ICh3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSwgdG9wLCBsZWZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGdldCgpLmNhbWVyYTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgdG9wOiB0b3AgfHwgMCxcbiAgICAgICAgICBsZWZ0OiBsZWZ0IHx8IDAsXG4gICAgICAgICAgdXBkYXRlU3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgICAgc2l6ZSxcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAuLi5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBkZWZhdWx0VGFyZ2V0LCBzaXplKVxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHNldERwcjogZHByID0+IHNldChzdGF0ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gY2FsY3VsYXRlRHByKGRwcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgICAgZHByOiByZXNvbHZlZCxcbiAgICAgICAgICAgIGluaXRpYWxEcHI6IHN0YXRlLnZpZXdwb3J0LmluaXRpYWxEcHIgfHwgcmVzb2x2ZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSxcbiAgICAgIHNldEZyYW1lbG9vcDogKGZyYW1lbG9vcCA9ICdhbHdheXMnKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gZ2V0KCkuY2xvY2s7XG5cbiAgICAgICAgLy8gaWYgZnJhbWVsb29wID09PSBcIm5ldmVyXCIgY2xvY2suZWxhcHNlZFRpbWUgaXMgdXBkYXRlZCB1c2luZyBhZHZhbmNlKHRpbWVzdGFtcClcbiAgICAgICAgY2xvY2suc3RvcCgpO1xuICAgICAgICBjbG9jay5lbGFwc2VkVGltZSA9IDA7XG4gICAgICAgIGlmIChmcmFtZWxvb3AgIT09ICduZXZlcicpIHtcbiAgICAgICAgICBjbG9jay5zdGFydCgpO1xuICAgICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgICBmcmFtZWxvb3BcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIHByZXZpb3VzUm9vdDogdW5kZWZpbmVkLFxuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgcHJpb3JpdHk6IDAsXG4gICAgICAgIGZyYW1lczogMCxcbiAgICAgICAgbGFzdEV2ZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCksXG4gICAgICAgIGludGVyYWN0aW9uOiBbXSxcbiAgICAgICAgaG92ZXJlZDogbmV3IE1hcCgpLFxuICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgIGluaXRpYWxDbGljazogWzAsIDBdLFxuICAgICAgICBpbml0aWFsSGl0czogW10sXG4gICAgICAgIGNhcHR1cmVkTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZTogKHJlZiwgcHJpb3JpdHksIHN0b3JlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJuYWwgPSBnZXQoKS5pbnRlcm5hbDtcbiAgICAgICAgICAvLyBJZiB0aGlzIHN1YnNjcmlwdGlvbiB3YXMgZ2l2ZW4gYSBwcmlvcml0eSwgaXQgdGFrZXMgcmVuZGVyaW5nIGludG8gaXRzIG93biBoYW5kc1xuICAgICAgICAgIC8vIEZvciB0aGF0IHJlYXNvbiB3ZSBzd2l0Y2ggb2ZmIGF1dG9tYXRpYyByZW5kZXJpbmcgYW5kIGluY3JlYXNlIHRoZSBtYW51YWwgZmxhZ1xuICAgICAgICAgIC8vIEFzIGxvbmcgYXMgdGhpcyBmbGFnIGlzIHBvc2l0aXZlIHRoZXJlIGNhbiBiZSBubyBpbnRlcm5hbCByZW5kZXJpbmcgYXQgYWxsXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSByZW5kZXIgc3Vic2NyaXB0aW9uc1xuICAgICAgICAgIGludGVybmFsLnByaW9yaXR5ID0gaW50ZXJuYWwucHJpb3JpdHkgKyAocHJpb3JpdHkgPiAwID8gMSA6IDApO1xuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzLnB1c2goe1xuICAgICAgICAgICAgcmVmLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICBzdG9yZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIFJlZ2lzdGVyIHN1YnNjcmliZXIgYW5kIHNvcnQgbGF5ZXJzIGZyb20gbG93ZXN0IHRvIGhpZ2hlc3QsIG1lYW5pbmcsXG4gICAgICAgICAgLy8gaGlnaGVzdCBwcmlvcml0eSByZW5kZXJzIGxhc3QgKG9uIHRvcCBvZiB0aGUgb3RoZXIgZnJhbWVzKVxuICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgICAgaWYgKGludGVybmFsICE9IG51bGwgJiYgaW50ZXJuYWwuc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgICAgLy8gRGVjcmVhc2UgbWFudWFsIGZsYWcgaWYgdGhpcyBzdWJzY3JpcHRpb24gaGFkIGEgcHJpb3JpdHlcbiAgICAgICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSAtIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSBzdWJzY3JpYmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICBpbnRlcm5hbC5zdWJzY3JpYmVycyA9IGludGVybmFsLnN1YnNjcmliZXJzLmZpbHRlcihzID0+IHMucmVmICE9PSByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByb290U3RhdGU7XG4gIH0pO1xuICBjb25zdCBzdGF0ZSA9IHJvb3RTdGF0ZS5nZXRTdGF0ZSgpO1xuICBsZXQgb2xkU2l6ZSA9IHN0YXRlLnNpemU7XG4gIGxldCBvbGREcHIgPSBzdGF0ZS52aWV3cG9ydC5kcHI7XG4gIGxldCBvbGRDYW1lcmEgPSBzdGF0ZS5jYW1lcmE7XG4gIHJvb3RTdGF0ZS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbWVyYSxcbiAgICAgIHNpemUsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGdsLFxuICAgICAgc2V0XG4gICAgfSA9IHJvb3RTdGF0ZS5nZXRTdGF0ZSgpO1xuXG4gICAgLy8gUmVzaXplIGNhbWVyYSBhbmQgcmVuZGVyZXIgb24gY2hhbmdlcyB0byBzaXplIGFuZCBwaXhlbHJhdGlvXG4gICAgaWYgKHNpemUud2lkdGggIT09IG9sZFNpemUud2lkdGggfHwgc2l6ZS5oZWlnaHQgIT09IG9sZFNpemUuaGVpZ2h0IHx8IHZpZXdwb3J0LmRwciAhPT0gb2xkRHByKSB7XG4gICAgICB2YXIgX3NpemUkdXBkYXRlU3R5bGU7XG4gICAgICBvbGRTaXplID0gc2l6ZTtcbiAgICAgIG9sZERwciA9IHZpZXdwb3J0LmRwcjtcbiAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgJiByZW5kZXJlclxuICAgICAgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgICBnbC5zZXRQaXhlbFJhdGlvKHZpZXdwb3J0LmRwcik7XG4gICAgICBjb25zdCB1cGRhdGVTdHlsZSA9IChfc2l6ZSR1cGRhdGVTdHlsZSA9IHNpemUudXBkYXRlU3R5bGUpICE9IG51bGwgPyBfc2l6ZSR1cGRhdGVTdHlsZSA6IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2wuZG9tRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgZ2wuc2V0U2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdXBkYXRlU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3cG9ydCBvbmNlIHRoZSBjYW1lcmEgY2hhbmdlc1xuICAgIGlmIChjYW1lcmEgIT09IG9sZENhbWVyYSkge1xuICAgICAgb2xkQ2FtZXJhID0gY2FtZXJhO1xuICAgICAgLy8gVXBkYXRlIHZpZXdwb3J0XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhKVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbnZhbGlkYXRlIG9uIGFueSBjaGFuZ2VcbiAgcm9vdFN0YXRlLnN1YnNjcmliZShzdGF0ZSA9PiBpbnZhbGlkYXRlKHN0YXRlKSk7XG5cbiAgLy8gUmV0dXJuIHJvb3Qgc3RhdGVcbiAgcmV0dXJuIHJvb3RTdGF0ZTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YnMoY2FsbGJhY2ssIHN1YnMpIHtcbiAgY29uc3Qgc3ViID0ge1xuICAgIGNhbGxiYWNrXG4gIH07XG4gIHN1YnMuYWRkKHN1Yik7XG4gIHJldHVybiAoKSA9PiB2b2lkIHN1YnMuZGVsZXRlKHN1Yik7XG59XG5sZXQgaTtcbmxldCBnbG9iYWxFZmZlY3RzID0gbmV3IFNldCgpO1xubGV0IGdsb2JhbEFmdGVyRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxUYWlsRWZmZWN0cyA9IG5ldyBTZXQoKTtcblxuLyoqXHJcbiAqIEFkZHMgYSBnbG9iYWwgcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkRWZmZWN0XHJcbiAqL1xuY29uc3QgYWRkRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsRWZmZWN0cyk7XG5cbi8qKlxyXG4gKiBBZGRzIGEgZ2xvYmFsIGFmdGVyLXJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEFmdGVyRWZmZWN0XHJcbiAqL1xuY29uc3QgYWRkQWZ0ZXJFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxBZnRlckVmZmVjdHMpO1xuXG4vKipcclxuICogQWRkcyBhIGdsb2JhbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRUYWlsXHJcbiAqL1xuY29uc3QgYWRkVGFpbCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbFRhaWxFZmZlY3RzKTtcbmZ1bmN0aW9uIHJ1bihlZmZlY3RzLCB0aW1lc3RhbXApIHtcbiAgaWYgKCFlZmZlY3RzLnNpemUpIHJldHVybjtcbiAgZm9yIChjb25zdCB7XG4gICAgY2FsbGJhY2tcbiAgfSBvZiBlZmZlY3RzLnZhbHVlcygpKSB7XG4gICAgY2FsbGJhY2sodGltZXN0YW1wKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hHbG9iYWxFZmZlY3RzKHR5cGUsIHRpbWVzdGFtcCkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdiZWZvcmUnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ2FmdGVyJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsQWZ0ZXJFZmZlY3RzLCB0aW1lc3RhbXApO1xuICAgIGNhc2UgJ3RhaWwnOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxUYWlsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgfVxufVxubGV0IHN1YnNjcmliZXJzO1xubGV0IHN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKSB7XG4gIC8vIFJ1biBsb2NhbCBlZmZlY3RzXG4gIGxldCBkZWx0YSA9IHN0YXRlLmNsb2NrLmdldERlbHRhKCk7XG4gIC8vIEluIGZyYW1lbG9vcD0nbmV2ZXInIG1vZGUsIGNsb2NrIHRpbWVzIGFyZSB1cGRhdGVkIHVzaW5nIHRoZSBwcm92aWRlZCB0aW1lc3RhbXBcbiAgaWYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJyAmJiB0eXBlb2YgdGltZXN0YW1wID09PSAnbnVtYmVyJykge1xuICAgIGRlbHRhID0gdGltZXN0YW1wIC0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2sub2xkVGltZSA9IHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lID0gdGltZXN0YW1wO1xuICB9XG4gIC8vIENhbGwgc3Vic2NyaWJlcnMgKHVzZUZyYW1lKVxuICBzdWJzY3JpYmVycyA9IHN0YXRlLmludGVybmFsLnN1YnNjcmliZXJzO1xuICBmb3IgKGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVyc1tpXTtcbiAgICBzdWJzY3JpcHRpb24ucmVmLmN1cnJlbnQoc3Vic2NyaXB0aW9uLnN0b3JlLmdldFN0YXRlKCksIGRlbHRhLCBmcmFtZSk7XG4gIH1cbiAgLy8gUmVuZGVyIGNvbnRlbnRcbiAgaWYgKCFzdGF0ZS5pbnRlcm5hbC5wcmlvcml0eSAmJiBzdGF0ZS5nbC5yZW5kZXIpIHN0YXRlLmdsLnJlbmRlcihzdGF0ZS5zY2VuZSwgc3RhdGUuY2FtZXJhKTtcbiAgLy8gRGVjcmVhc2UgZnJhbWUgY291bnRcbiAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5tYXgoMCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzIC0gMSk7XG4gIHJldHVybiBzdGF0ZS5mcmFtZWxvb3AgPT09ICdhbHdheXMnID8gMSA6IHN0YXRlLmludGVybmFsLmZyYW1lcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvb3Aocm9vdHMpIHtcbiAgbGV0IHJ1bm5pbmcgPSBmYWxzZTtcbiAgbGV0IHVzZUZyYW1lSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICBsZXQgcmVwZWF0O1xuICBsZXQgZnJhbWU7XG4gIGxldCBzdGF0ZTtcbiAgZnVuY3Rpb24gbG9vcCh0aW1lc3RhbXApIHtcbiAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICByZXBlYXQgPSAwO1xuXG4gICAgLy8gUnVuIGVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBSZW5kZXIgYWxsIHJvb3RzXG4gICAgdXNlRnJhbWVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHtcbiAgICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgICBzdGF0ZSA9IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHRoZSBmcmFtZWxvb3AgaXMgaW52YWxpZGF0ZWQsIGRvIG5vdCBydW4gYW5vdGhlciBmcmFtZVxuICAgICAgaWYgKHN0YXRlLmludGVybmFsLmFjdGl2ZSAmJiAoc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyB8fCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPiAwKSAmJiAhKChfc3RhdGUkZ2wkeHIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIuaXNQcmVzZW50aW5nKSkge1xuICAgICAgICByZXBlYXQgKz0gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVzZUZyYW1lSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gUnVuIGFmdGVyLWVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgbm90aGluZyBpbnZhbGlkYXRlcyBpdFxuICAgIGlmIChyZXBlYXQgPT09IDApIHtcbiAgICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICAgIGZsdXNoR2xvYmFsRWZmZWN0cygndGFpbCcsIHRpbWVzdGFtcCk7XG5cbiAgICAgIC8vIEZsYWcgZW5kIG9mIG9wZXJhdGlvblxuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShzdGF0ZSwgZnJhbWVzID0gMSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHIyO1xuICAgIGlmICghc3RhdGUpIHJldHVybiByb290cy5mb3JFYWNoKHJvb3QgPT4gaW52YWxpZGF0ZShyb290LnN0b3JlLmdldFN0YXRlKCksIGZyYW1lcykpO1xuICAgIGlmICgoX3N0YXRlJGdsJHhyMiA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4cjIuaXNQcmVzZW50aW5nIHx8ICFzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgfHwgc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgaWYgKGZyYW1lcyA+IDEpIHtcbiAgICAgIC8vIGxlZ2FjeSBzdXBwb3J0IGZvciBwZW9wbGUgdXNpbmcgZnJhbWVzIHBhcmFtZXRlcnNcbiAgICAgIC8vIEluY3JlYXNlIGZyYW1lcywgZG8gbm90IGdvIGhpZ2hlciB0aGFuIDYwXG4gICAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHVzZUZyYW1lSW5Qcm9ncmVzcykge1xuICAgICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiBhIHVzZUZyYW1lLCBpdCBtZWFucyB0aGUgdXNlciB3YW50cyBhbiBhZGRpdGlvbmFsIGZyYW1lXG4gICAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL3RoZSB1c2VyIG5lZWQgYSBuZXcgZnJhbWUsIG5vIG5lZWQgdG8gaW5jcmVtZW50IGZ1cnRoZXIgdGhhbiAxXG4gICAgICAgIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHJlbmRlci1sb29wIGlzbid0IGFjdGl2ZSwgc3RhcnQgaXRcbiAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cyA9IHRydWUsIHN0YXRlLCBmcmFtZSkge1xuICAgIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG4gICAgaWYgKCFzdGF0ZSkgZm9yIChjb25zdCByb290IG9mIHJvb3RzLnZhbHVlcygpKSByZW5kZXIkMSh0aW1lc3RhbXAsIHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSk7ZWxzZSByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSk7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiB7XG4gICAgbG9vcCxcbiAgICBpbnZhbGlkYXRlLFxuICAgIGFkdmFuY2VcbiAgfTtcbn1cblxuLyoqXHJcbiAqIEV4cG9zZXMgYW4gb2JqZWN0J3Mge0BsaW5rIExvY2FsU3RhdGV9LlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjdXNlSW5zdGFuY2VIYW5kbGVcclxuICpcclxuICogKipOb3RlKio6IHRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIHRvIHJlYWN0LWludGVybmFsIGZpZWxkcy4gRXhwZWN0IHRoaXMgdG8gY2hhbmdlIHNpZ25pZmljYW50bHkgYmV0d2VlbiB2ZXJzaW9ucy5cclxuICovXG5mdW5jdGlvbiB1c2VJbnN0YW5jZUhhbmRsZShyZWYpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAoaW5zdGFuY2UuY3VycmVudCA9IHJlZi5jdXJyZW50Ll9fcjNmKSwgW3JlZl0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXHJcbiAqIEFjY2Vzc2VzIFIzRidzIGludGVybmFsIHN0YXRlLCBjb250YWluaW5nIHJlbmRlcmVyLCBjYW52YXMsIHNjZW5lLCBldGMuXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXHJcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxyXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIGJlZm9yZSByZW5kZXIgaW4gYSBzaGFyZWQgZnJhbWUgbG9vcC5cclxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcclxuICovXG5mdW5jdGlvbiB1c2VGcmFtZShjYWxsYmFjaywgcmVuZGVyUHJpb3JpdHkgPSAwKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gc3RvcmUuZ2V0U3RhdGUoKS5pbnRlcm5hbC5zdWJzY3JpYmU7XG4gIC8vIE1lbW9pemUgcmVmXG4gIGNvbnN0IHJlZiA9IHVzZU11dGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gIC8vIFN1YnNjcmliZSBvbiBtb3VudCwgdW5zdWJzY3JpYmUgb24gdW5tb3VudFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShyZWYsIHJlbmRlclByaW9yaXR5LCBzdG9yZSksIFtyZW5kZXJQcmlvcml0eSwgc3Vic2NyaWJlLCBzdG9yZV0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxyXG4gKi9cbmZ1bmN0aW9uIHVzZUdyYXBoKG9iamVjdCkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBidWlsZEdyYXBoKG9iamVjdCksIFtvYmplY3RdKTtcbn1cbmNvbnN0IG1lbW9pemVkTG9hZGVycyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICByZXR1cm4gZnVuY3Rpb24gKFByb3RvLCAuLi5pbnB1dCkge1xuICAgIC8vIENvbnN0cnVjdCBuZXcgbG9hZGVyIGFuZCBydW4gZXh0ZW5zaW9uc1xuICAgIGxldCBsb2FkZXIgPSBtZW1vaXplZExvYWRlcnMuZ2V0KFByb3RvKTtcbiAgICBpZiAoIWxvYWRlcikge1xuICAgICAgbG9hZGVyID0gbmV3IFByb3RvKCk7XG4gICAgICBtZW1vaXplZExvYWRlcnMuc2V0KFByb3RvLCBsb2FkZXIpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5zaW9ucykgZXh0ZW5zaW9ucyhsb2FkZXIpO1xuICAgIC8vIEdvIHRocm91Z2ggdGhlIHVybHMgYW5kIGxvYWQgdGhlbVxuICAgIHJldHVybiBQcm9taXNlLmFsbChpbnB1dC5tYXAoaW5wdXQgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqZWN0KSA9PiBsb2FkZXIubG9hZChpbnB1dCwgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS5zY2VuZSkgT2JqZWN0LmFzc2lnbihkYXRhLCBidWlsZEdyYXBoKGRhdGEuc2NlbmUpKTtcbiAgICAgIHJlcyhkYXRhKTtcbiAgICB9LCBvblByb2dyZXNzLCBlcnJvciA9PiByZWplY3QobmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCAke2lucHV0fTogJHtlcnJvciA9PSBudWxsID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZX1gKSkpKSkpO1xuICB9O1xufVxuLyoqXHJcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgYW5kIGNhY2hlcyBhc3NldHMgd2l0aCBhIHRocmVlIGxvYWRlci5cclxuICpcclxuICogTm90ZTogdGhpcyBob29rJ3MgY2FsbGVyIG11c3QgYmUgd3JhcHBlZCB3aXRoIGBSZWFjdC5TdXNwZW5zZWBcclxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlbG9hZGVyXHJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICAvLyBVc2Ugc3VzcGVuc2UgdG8gbG9hZCBhc3luYyBhc3NldHNcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICBjb25zdCByZXN1bHRzID0gc3VzcGVuZChsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcyksIFtQcm90bywgLi4ua2V5c10sIHtcbiAgICBlcXVhbDogaXMuZXF1XG4gIH0pO1xuICAvLyBSZXR1cm4gdGhlIG9iamVjdC9zXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGlucHV0KSA/IHJlc3VsdHMgOiByZXN1bHRzWzBdO1xufVxuXG4vKipcclxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxyXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBwcmVsb2FkKGxvYWRpbmdGbihleHRlbnNpb25zKSwgW1Byb3RvLCAuLi5rZXlzXSk7XG59O1xuXG4vKipcclxuICogUmVtb3ZlcyBhIGxvYWRlZCBhc3NldCBmcm9tIGNhY2hlLlxyXG4gKi9cbnVzZUxvYWRlci5jbGVhciA9IGZ1bmN0aW9uIChQcm90bywgaW5wdXQpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gY2xlYXIoW1Byb3RvLCAuLi5rZXlzXSk7XG59O1xuXG5jb25zdCByb290cyA9IG5ldyBNYXAoKTtcbmNvbnN0IHtcbiAgaW52YWxpZGF0ZSxcbiAgYWR2YW5jZVxufSA9IGNyZWF0ZUxvb3Aocm9vdHMpO1xuY29uc3Qge1xuICByZWNvbmNpbGVyLFxuICBhcHBseVByb3BzXG59ID0gY3JlYXRlUmVuZGVyZXIocm9vdHMsIGdldEV2ZW50UHJpb3JpdHkpO1xuY29uc3Qgc2hhbGxvd0xvb3NlID0ge1xuICBvYmplY3RzOiAnc2hhbGxvdycsXG4gIHN0cmljdDogZmFsc2Vcbn07XG5jb25zdCBjcmVhdGVSZW5kZXJlckluc3RhbmNlID0gKGdsLCBjYW52YXMpID0+IHtcbiAgY29uc3QgY3VzdG9tUmVuZGVyZXIgPSB0eXBlb2YgZ2wgPT09ICdmdW5jdGlvbicgPyBnbChjYW52YXMpIDogZ2w7XG4gIGlmIChpc1JlbmRlcmVyKGN1c3RvbVJlbmRlcmVyKSkgcmV0dXJuIGN1c3RvbVJlbmRlcmVyO2Vsc2UgcmV0dXJuIG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICBwb3dlclByZWZlcmVuY2U6ICdoaWdoLXBlcmZvcm1hbmNlJyxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgYWxwaGE6IHRydWUsXG4gICAgLi4uZ2xcbiAgfSk7XG59O1xuZnVuY3Rpb24gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgZGVmYXVsdFNpemUpIHtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgaWYgKGRlZmF1bHRTaXplKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGUgPSBkZWZhdWx0U3R5bGVcbiAgICB9ID0gZGVmYXVsdFNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0XG4gICAgfSA9IGNhbnZhcy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB1cGRhdGVTdHlsZTogZGVmYXVsdFN0eWxlXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUm9vdChjYW52YXMpIHtcbiAgLy8gQ2hlY2sgYWdhaW5zdCBtaXN0YWtlbiB1c2Ugb2YgY3JlYXRlUm9vdFxuICBjb25zdCBwcmV2Um9vdCA9IHJvb3RzLmdldChjYW52YXMpO1xuICBjb25zdCBwcmV2RmliZXIgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3QuZmliZXI7XG4gIGNvbnN0IHByZXZTdG9yZSA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5zdG9yZTtcbiAgaWYgKHByZXZSb290KSBjb25zb2xlLndhcm4oJ1IzRi5jcmVhdGVSb290IHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIScpO1xuXG4gIC8vIFJlcG9ydCB3aGVuIGFuIGVycm9yIHdhcyBkZXRlY3RlZCBpbiBhIHByZXZpb3VzIHJlbmRlclxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjI2MVxuICBjb25zdCBsb2dSZWNvdmVyYWJsZUVycm9yID0gdHlwZW9mIHJlcG9ydEVycm9yID09PSAnZnVuY3Rpb24nID9cbiAgLy8gSW4gbW9kZXJuIGJyb3dzZXJzLCByZXBvcnRFcnJvciB3aWxsIGRpc3BhdGNoIGFuIGVycm9yIGV2ZW50LFxuICAvLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbiAgcmVwb3J0RXJyb3IgOlxuICAvLyBJbiBvbGRlciBicm93c2VycyBhbmQgdGVzdCBlbnZpcm9ubWVudHMsIGZhbGxiYWNrIHRvIGNvbnNvbGUuZXJyb3IuXG4gIGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gQ3JlYXRlIHN0b3JlXG4gIGNvbnN0IHN0b3JlID0gcHJldlN0b3JlIHx8IGNyZWF0ZVN0b3JlKGludmFsaWRhdGUsIGFkdmFuY2UpO1xuICAvLyBDcmVhdGUgcmVuZGVyZXJcbiAgY29uc3QgZmliZXIgPSBwcmV2RmliZXIgfHwgcmVjb25jaWxlci5jcmVhdGVDb250YWluZXIoc3RvcmUsIENvbmN1cnJlbnRSb290LCBudWxsLCBmYWxzZSwgbnVsbCwgJycsIGxvZ1JlY292ZXJhYmxlRXJyb3IsIG51bGwpO1xuICAvLyBNYXAgaXRcbiAgaWYgKCFwcmV2Um9vdCkgcm9vdHMuc2V0KGNhbnZhcywge1xuICAgIGZpYmVyLFxuICAgIHN0b3JlXG4gIH0pO1xuXG4gIC8vIExvY2Fsc1xuICBsZXQgb25DcmVhdGVkO1xuICBsZXQgY29uZmlndXJlZCA9IGZhbHNlO1xuICBsZXQgbGFzdENhbWVyYTtcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmUocHJvcHMgPSB7fSkge1xuICAgICAgbGV0IHtcbiAgICAgICAgZ2w6IGdsQ29uZmlnLFxuICAgICAgICBzaXplOiBwcm9wc1NpemUsXG4gICAgICAgIHNjZW5lOiBzY2VuZU9wdGlvbnMsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgb25DcmVhdGVkOiBvbkNyZWF0ZWRDYWxsYmFjayxcbiAgICAgICAgc2hhZG93cyA9IGZhbHNlLFxuICAgICAgICBsaW5lYXIgPSBmYWxzZSxcbiAgICAgICAgZmxhdCA9IGZhbHNlLFxuICAgICAgICBsZWdhY3kgPSBmYWxzZSxcbiAgICAgICAgb3J0aG9ncmFwaGljID0gZmFsc2UsXG4gICAgICAgIGZyYW1lbG9vcCA9ICdhbHdheXMnLFxuICAgICAgICBkcHIgPSBbMSwgMl0sXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RPcHRpb25zLFxuICAgICAgICBjYW1lcmE6IGNhbWVyYU9wdGlvbnMsXG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSA9IHByb3BzO1xuICAgICAgbGV0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gU2V0IHVwIHJlbmRlcmVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCBnbCA9IHN0YXRlLmdsO1xuICAgICAgaWYgKCFzdGF0ZS5nbCkgc3RhdGUuc2V0KHtcbiAgICAgICAgZ2w6IGdsID0gY3JlYXRlUmVuZGVyZXJJbnN0YW5jZShnbENvbmZpZywgY2FudmFzKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCB1cCByYXljYXN0ZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IHJheWNhc3RlciA9IHN0YXRlLnJheWNhc3RlcjtcbiAgICAgIGlmICghcmF5Y2FzdGVyKSBzdGF0ZS5zZXQoe1xuICAgICAgICByYXljYXN0ZXI6IHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIoKVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCByYXljYXN0ZXIgb3B0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXJhbXMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0gPSByYXljYXN0T3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghaXMuZXF1KG9wdGlvbnMsIHJheWNhc3Rlciwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgICBpZiAoIWlzLmVxdShwYXJhbXMsIHJheWNhc3Rlci5wYXJhbXMsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIC4uLnJheWNhc3Rlci5wYXJhbXMsXG4gICAgICAgICAgLi4ucGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgZGVmYXVsdCBjYW1lcmEsIGRvbid0IG92ZXJ3cml0ZSBhbnkgdXNlci1zZXQgc3RhdGVcbiAgICAgIGlmICghc3RhdGUuY2FtZXJhIHx8IHN0YXRlLmNhbWVyYSA9PT0gbGFzdENhbWVyYSAmJiAhaXMuZXF1KGxhc3RDYW1lcmEsIGNhbWVyYU9wdGlvbnMsIHNoYWxsb3dMb29zZSkpIHtcbiAgICAgICAgbGFzdENhbWVyYSA9IGNhbWVyYU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzQ2FtZXJhID0gY2FtZXJhT3B0aW9ucyBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYTtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gaXNDYW1lcmEgPyBjYW1lcmFPcHRpb25zIDogb3J0aG9ncmFwaGljID8gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSgwLCAwLCAwLCAwLCAwLjEsIDEwMDApIDogbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDc1LCAwLCAwLjEsIDEwMDApO1xuICAgICAgICBpZiAoIWlzQ2FtZXJhKSB7XG4gICAgICAgICAgY2FtZXJhLnBvc2l0aW9uLnogPSA1O1xuICAgICAgICAgIGlmIChjYW1lcmFPcHRpb25zKSB7XG4gICAgICAgICAgICBhcHBseVByb3BzKGNhbWVyYSwgY2FtZXJhT3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSB1c2VyLWRlZmluZWQgZnJ1c3R1bSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMzE2MFxuICAgICAgICAgICAgaWYgKCdhc3BlY3QnIGluIGNhbWVyYU9wdGlvbnMgfHwgJ2xlZnQnIGluIGNhbWVyYU9wdGlvbnMgfHwgJ3JpZ2h0JyBpbiBjYW1lcmFPcHRpb25zIHx8ICdib3R0b20nIGluIGNhbWVyYU9wdGlvbnMgfHwgJ3RvcCcgaW4gY2FtZXJhT3B0aW9ucykge1xuICAgICAgICAgICAgICBjYW1lcmEubWFudWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWx3YXlzIGxvb2sgYXQgY2VudGVyIGJ5IGRlZmF1bHRcbiAgICAgICAgICBpZiAoIXN0YXRlLmNhbWVyYSAmJiAhKGNhbWVyYU9wdGlvbnMgIT0gbnVsbCAmJiBjYW1lcmFPcHRpb25zLnJvdGF0aW9uKSkgY2FtZXJhLmxvb2tBdCgwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIGNhbWVyYVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb25maWd1cmUgcmF5Y2FzdGVyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QteHIvaXNzdWVzLzMwMFxuICAgICAgICByYXljYXN0ZXIuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgc2NlbmUgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS5zY2VuZSkge1xuICAgICAgICBsZXQgc2NlbmU7XG4gICAgICAgIGlmIChzY2VuZU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRS5TY2VuZSkge1xuICAgICAgICAgIHNjZW5lID0gc2NlbmVPcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgICAgaWYgKHNjZW5lT3B0aW9ucykgYXBwbHlQcm9wcyhzY2VuZSwgc2NlbmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5zZXQoe1xuICAgICAgICAgIHNjZW5lOiBwcmVwYXJlKHNjZW5lKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIFhSIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGlmICghc3RhdGUueHIpIHtcbiAgICAgICAgdmFyIF9nbCR4cjtcbiAgICAgICAgLy8gSGFuZGxlIGZyYW1lIGJlaGF2aW9yIGluIFdlYlhSXG4gICAgICAgIGNvbnN0IGhhbmRsZVhSRnJhbWUgPSAodGltZXN0YW1wLCBmcmFtZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgICAgICAgYWR2YW5jZSh0aW1lc3RhbXAsIHRydWUsIHN0YXRlLCBmcmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVG9nZ2xlIHJlbmRlciBzd2l0Y2hpbmcgb24gc2Vzc2lvblxuICAgICAgICBjb25zdCBoYW5kbGVTZXNzaW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBzdGF0ZS5nbC54ci5lbmFibGVkID0gc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLnNldEFuaW1hdGlvbkxvb3Aoc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nID8gaGFuZGxlWFJGcmFtZSA6IG51bGwpO1xuICAgICAgICAgIGlmICghc3RhdGUuZ2wueHIuaXNQcmVzZW50aW5nKSBpbnZhbGlkYXRlKHN0YXRlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBXZWJYUiBzZXNzaW9uIG1hbmFnZXJcbiAgICAgICAgY29uc3QgeHIgPSB7XG4gICAgICAgICAgY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RvcmUuZ2V0U3RhdGUoKS5nbDtcbiAgICAgICAgICAgIGdsLnhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RvcmUuZ2V0U3RhdGUoKS5nbDtcbiAgICAgICAgICAgIGdsLnhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Nlc3Npb25zdGFydCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbmVuZCcsIGhhbmRsZVNlc3Npb25DaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gV2ViWFIgc2Vzc2lvbiBldmVudHNcbiAgICAgICAgaWYgKHR5cGVvZiAoKF9nbCR4ciA9IGdsLnhyKSA9PSBudWxsID8gdm9pZCAwIDogX2dsJHhyLmFkZEV2ZW50TGlzdGVuZXIpID09PSAnZnVuY3Rpb24nKSB4ci5jb25uZWN0KCk7XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgeHJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBzaGFkb3dtYXBcbiAgICAgIGlmIChnbC5zaGFkb3dNYXApIHtcbiAgICAgICAgY29uc3Qgb2xkRW5hYmxlZCA9IGdsLnNoYWRvd01hcC5lbmFibGVkO1xuICAgICAgICBjb25zdCBvbGRUeXBlID0gZ2wuc2hhZG93TWFwLnR5cGU7XG4gICAgICAgIGdsLnNoYWRvd01hcC5lbmFibGVkID0gISFzaGFkb3dzO1xuICAgICAgICBpZiAoaXMuYm9vKHNoYWRvd3MpKSB7XG4gICAgICAgICAgZ2wuc2hhZG93TWFwLnR5cGUgPSBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwO1xuICAgICAgICB9IGVsc2UgaWYgKGlzLnN0cihzaGFkb3dzKSkge1xuICAgICAgICAgIHZhciBfdHlwZXMkc2hhZG93cztcbiAgICAgICAgICBjb25zdCB0eXBlcyA9IHtcbiAgICAgICAgICAgIGJhc2ljOiBUSFJFRS5CYXNpY1NoYWRvd01hcCxcbiAgICAgICAgICAgIHBlcmNlbnRhZ2U6IFRIUkVFLlBDRlNoYWRvd01hcCxcbiAgICAgICAgICAgIHNvZnQ6IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAsXG4gICAgICAgICAgICB2YXJpYW5jZTogVEhSRUUuVlNNU2hhZG93TWFwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IChfdHlwZXMkc2hhZG93cyA9IHR5cGVzW3NoYWRvd3NdKSAhPSBudWxsID8gX3R5cGVzJHNoYWRvd3MgOiBUSFJFRS5QQ0ZTb2Z0U2hhZG93TWFwO1xuICAgICAgICB9IGVsc2UgaWYgKGlzLm9iaihzaGFkb3dzKSkge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oZ2wuc2hhZG93TWFwLCBzaGFkb3dzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkRW5hYmxlZCAhPT0gZ2wuc2hhZG93TWFwLmVuYWJsZWQgfHwgb2xkVHlwZSAhPT0gZ2wuc2hhZG93TWFwLnR5cGUpIGdsLnNoYWRvd01hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhZmVseSBzZXQgY29sb3IgbWFuYWdlbWVudCBpZiBhdmFpbGFibGUuXG4gICAgICAvLyBBdm9pZCBhY2Nlc3NpbmcgVEhSRUUuQ29sb3JNYW5hZ2VtZW50IHRvIHBsYXkgbmljZSB3aXRoIG9sZGVyIHZlcnNpb25zXG4gICAgICBjb25zdCBDb2xvck1hbmFnZW1lbnQgPSBnZXRDb2xvck1hbmFnZW1lbnQoKTtcbiAgICAgIGlmIChDb2xvck1hbmFnZW1lbnQpIHtcbiAgICAgICAgaWYgKCdlbmFibGVkJyBpbiBDb2xvck1hbmFnZW1lbnQpIENvbG9yTWFuYWdlbWVudC5lbmFibGVkID0gIWxlZ2FjeTtlbHNlIGlmICgnbGVnYWN5TW9kZScgaW4gQ29sb3JNYW5hZ2VtZW50KSBDb2xvck1hbmFnZW1lbnQubGVnYWN5TW9kZSA9IGxlZ2FjeTtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlndXJlZCkge1xuICAgICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzLCBvbmNlXG4gICAgICAgIGNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICAgICAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgICAgICAgYXBwbHlQcm9wcyhnbCwge1xuICAgICAgICAgIG91dHB1dEVuY29kaW5nOiBsaW5lYXIgPyBMaW5lYXJFbmNvZGluZyA6IHNSR0JFbmNvZGluZyxcbiAgICAgICAgICB0b25lTWFwcGluZzogZmxhdCA/IFRIUkVFLk5vVG9uZU1hcHBpbmcgOiBUSFJFRS5BQ0VTRmlsbWljVG9uZU1hcHBpbmdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xvciBtYW5hZ2VtZW50IHN0YXRlXG4gICAgICBpZiAoc3RhdGUubGVnYWN5ICE9PSBsZWdhY3kpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsZWdhY3lcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5saW5lYXIgIT09IGxpbmVhcikgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxpbmVhclxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmZsYXQgIT09IGZsYXQpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBmbGF0XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBnbCBwcm9wc1xuICAgICAgaWYgKGdsQ29uZmlnICYmICFpcy5mdW4oZ2xDb25maWcpICYmICFpc1JlbmRlcmVyKGdsQ29uZmlnKSAmJiAhaXMuZXF1KGdsQ29uZmlnLCBnbCwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhnbCwgZ2xDb25maWcpO1xuICAgICAgLy8gU3RvcmUgZXZlbnRzIGludGVybmFsbHlcbiAgICAgIGlmIChldmVudHMgJiYgIXN0YXRlLmV2ZW50cy5oYW5kbGVycykgc3RhdGUuc2V0KHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMoc3RvcmUpXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHNpemUsIGFsbG93IGl0IHRvIHRha2Ugb24gY29udGFpbmVyIGJvdW5kcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IHNpemUgPSBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBwcm9wc1NpemUpO1xuICAgICAgaWYgKCFpcy5lcXUoc2l6ZSwgc3RhdGUuc2l6ZSwgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBzdGF0ZS5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBzaXplLnVwZGF0ZVN0eWxlLCBzaXplLnRvcCwgc2l6ZS5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHBpeGVscmF0aW9cbiAgICAgIGlmIChkcHIgJiYgc3RhdGUudmlld3BvcnQuZHByICE9PSBjYWxjdWxhdGVEcHIoZHByKSkgc3RhdGUuc2V0RHByKGRwcik7XG4gICAgICAvLyBDaGVjayBmcmFtZWxvb3BcbiAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgIT09IGZyYW1lbG9vcCkgc3RhdGUuc2V0RnJhbWVsb29wKGZyYW1lbG9vcCk7XG4gICAgICAvLyBDaGVjayBwb2ludGVyIG1pc3NlZFxuICAgICAgaWYgKCFzdGF0ZS5vblBvaW50ZXJNaXNzZWQpIHN0YXRlLnNldCh7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZVxuICAgICAgaWYgKHBlcmZvcm1hbmNlICYmICFpcy5lcXUocGVyZm9ybWFuY2UsIHN0YXRlLnBlcmZvcm1hbmNlLCBzaGFsbG93TG9vc2UpKSBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAuLi5wZXJmb3JtYW5jZVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBsb2NhbHNcbiAgICAgIG9uQ3JlYXRlZCA9IG9uQ3JlYXRlZENhbGxiYWNrO1xuICAgICAgY29uZmlndXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbmRlcihjaGlsZHJlbikge1xuICAgICAgLy8gVGhlIHJvb3QgaGFzIHRvIGJlIGNvbmZpZ3VyZWQgYmVmb3JlIGl0IGNhbiBiZSByZW5kZXJlZFxuICAgICAgaWYgKCFjb25maWd1cmVkKSB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIoIC8qI19fUFVSRV9fKi9qc3goUHJvdmlkZXIsIHtcbiAgICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkLFxuICAgICAgICByb290RWxlbWVudDogY2FudmFzXG4gICAgICB9KSwgZmliZXIsIG51bGwsICgpID0+IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gc3RvcmU7XG4gICAgfSxcbiAgICB1bm1vdW50KCkge1xuICAgICAgdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihjaGlsZHJlbiwgY2FudmFzLCBjb25maWcpIHtcbiAgY29uc29sZS53YXJuKCdSM0YucmVuZGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgaW4gUmVhY3QgMTguIFVzZSBjcmVhdGVSb290IGluc3RlYWQhJyk7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gIHJvb3QuY29uZmlndXJlKGNvbmZpZyk7XG4gIHJldHVybiByb290LnJlbmRlcihjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBQcm92aWRlcih7XG4gIHN0b3JlLFxuICBjaGlsZHJlbixcbiAgb25DcmVhdGVkLFxuICByb290RWxlbWVudFxufSkge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gRmxhZyB0aGUgY2FudmFzIGFjdGl2ZSwgcmVuZGVyaW5nIHdpbGwgbm93IGJlZ2luXG4gICAgc3RhdGUuc2V0KHN0YXRlID0+ICh7XG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICAuLi5zdGF0ZS5pbnRlcm5hbCxcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9XG4gICAgfSkpO1xuICAgIC8vIE5vdGlmaXkgdGhhdCBpbml0IGlzIGNvbXBsZXRlZCwgdGhlIHNjZW5lIGdyYXBoIGV4aXN0cywgYnV0IG5vdGhpbmcgaGFzIHlldCByZW5kZXJlZFxuICAgIGlmIChvbkNyZWF0ZWQpIG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgLy8gQ29ubmVjdCBldmVudHMgdG8gdGhlIHRhcmdldHMgcGFyZW50LCB0aGlzIGlzIGRvbmUgdG8gZW5zdXJlIGV2ZW50cyBhcmUgcmVnaXN0ZXJlZCBvblxuICAgIC8vIGEgc2hhcmVkIHRhcmdldCwgYW5kIG5vdCBvbiB0aGUgY2FudmFzIGl0c2VsZlxuICAgIGlmICghc3RvcmUuZ2V0U3RhdGUoKS5ldmVudHMuY29ubmVjdGVkKSBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3Qocm9vdEVsZW1lbnQpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHN0b3JlLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzLCBjYWxsYmFjaykge1xuICBjb25zdCByb290ID0gcm9vdHMuZ2V0KGNhbnZhcyk7XG4gIGNvbnN0IGZpYmVyID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5maWJlcjtcbiAgaWYgKGZpYmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlKSBzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgPSBmYWxzZTtcbiAgICByZWNvbmNpbGVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCBmaWJlciwgbnVsbCwgKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3N0YXRlJGdsLCBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMsIF9zdGF0ZSRnbDIsIF9zdGF0ZSRnbDM7XG4gICAgICAgICAgICBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IChfc3RhdGUkZ2wkcmVuZGVyTGlzdHMgPSBfc3RhdGUkZ2wucmVuZGVyTGlzdHMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsJHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIChfc3RhdGUkZ2wyID0gc3RhdGUuZ2wpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wyLmZvcmNlQ29udGV4dExvc3MgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcygpO1xuICAgICAgICAgICAgaWYgKChfc3RhdGUkZ2wzID0gc3RhdGUuZ2wpICE9IG51bGwgJiYgX3N0YXRlJGdsMy54cikgc3RhdGUueHIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGlzcG9zZShzdGF0ZSk7XG4gICAgICAgICAgICByb290cy5kZWxldGUoY2FudmFzKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soY2FudmFzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiAuLi4gKi9cbiAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyLCBzdGF0ZSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChQb3J0YWwsIHtcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgc3RhdGU6IHN0YXRlXG4gIH0sIGNvbnRhaW5lci51dWlkKTtcbn1cbmZ1bmN0aW9uIFBvcnRhbCh7XG4gIHN0YXRlID0ge30sXG4gIGNoaWxkcmVuLFxuICBjb250YWluZXJcbn0pIHtcbiAgLyoqIFRoaXMgaGFzIHRvIGJlIGEgY29tcG9uZW50IGJlY2F1c2UgaXQgd291bGQgbm90IGJlIGFibGUgdG8gY2FsbCB1c2VUaHJlZS91c2VTdG9yZSBvdGhlcndpc2Ugc2luY2VcclxuICAgKiAgaWYgdGhpcyBpcyBvdXIgZW52aXJvbm1lbnQsIHRoZW4gd2UgYXJlIG5vdCBpbiByM2YncyByZW5kZXJlciBidXQgaW4gcmVhY3QtZG9tLCBpdCB3b3VsZCB0cmlnZ2VyXHJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxyXG4gICAqICA8Q2FudmFzPlxyXG4gICAqICAgIHtjcmVhdGVQb3J0YWwoLi4uKX0gKi9cbiAgY29uc3Qge1xuICAgIGV2ZW50cyxcbiAgICBzaXplLFxuICAgIC4uLnJlc3RcbiAgfSA9IHN0YXRlO1xuICBjb25zdCBwcmV2aW91c1Jvb3QgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBbcmF5Y2FzdGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5SYXljYXN0ZXIoKSk7XG4gIGNvbnN0IFtwb2ludGVyXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUSFJFRS5WZWN0b3IyKCkpO1xuICBjb25zdCBpbmplY3QgPSBSZWFjdC51c2VDYWxsYmFjaygocm9vdFN0YXRlLCBpbmplY3RTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IHtcbiAgICAgIC4uLnJvb3RTdGF0ZVxuICAgIH07IC8vIGFsbCBwcmV2IHN0YXRlIHByb3BzXG5cbiAgICAvLyBPbmx5IHRoZSBmaWVsZHMgb2YgXCJyb290U3RhdGVcIiB0aGF0IGRvIG5vdCBkaWZmZXIgZnJvbSBpbmplY3RTdGF0ZVxuICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAvLyBPdGhlcndpc2UgZmlsdGVyIG91dCB0aGUgcHJvcHMgdGhhdCBhcmUgZGlmZmVyZW50IGFuZCBsZXQgdGhlIGluamVjdCBsYXllciB0YWtlIHByZWNlZGVuY2VcbiAgICBPYmplY3Qua2V5cyhyb290U3RhdGUpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChcbiAgICAgIC8vIFNvbWUgcHJvcHMgc2hvdWxkIGJlIG9mZi1saW1pdHNcbiAgICAgIHByaXZhdGVLZXlzLmluY2x1ZGVzKGtleSkgfHxcbiAgICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgICAgLy8gVW5sZXNzIHRoZSBpbmplY3QgbGF5ZXIgcHJvcHMgaXMgdW5kZWZpbmVkLCB0aGVuIHdlIGtlZXAgdGhlIHJvb3QgbGF5ZXJcbiAgICAgIHJvb3RTdGF0ZVtrZXldICE9PSBpbmplY3RTdGF0ZVtrZXldICYmIGluamVjdFN0YXRlW2tleV0pIHtcbiAgICAgICAgZGVsZXRlIGludGVyc2VjdFtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB2aWV3cG9ydCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5qZWN0U3RhdGUgJiYgc2l6ZSkge1xuICAgICAgY29uc3QgY2FtZXJhID0gaW5qZWN0U3RhdGUuY2FtZXJhO1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVycmlkZSB2aWV3cG9ydCwgaWYgcHJlc2VudFxuICAgICAgdmlld3BvcnQgPSByb290U3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgc2l6ZSk7XG4gICAgICAvLyBVcGRhdGUgdGhlIHBvcnRhbCBjYW1lcmEsIGlmIGl0IGRpZmZlcnMgZnJvbSB0aGUgcHJldmlvdXMgbGF5ZXJcbiAgICAgIGlmIChjYW1lcmEgIT09IHJvb3RTdGF0ZS5jYW1lcmEpIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLy8gVGhlIGludGVyc2VjdCBjb25zaXN0cyBvZiB0aGUgcHJldmlvdXMgcm9vdCBzdGF0ZVxuICAgICAgLi4uaW50ZXJzZWN0LFxuICAgICAgLy8gUG9ydGFscyBoYXZlIHRoZWlyIG93biBzY2VuZSwgd2hpY2ggZm9ybXMgdGhlIHJvb3QsIGEgcmF5Y2FzdGVyIGFuZCBhIHBvaW50ZXJcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICAvLyBUaGVpciBwcmV2aW91cyByb290IGlzIHRoZSBsYXllciBiZWZvcmUgaXRcbiAgICAgIHByZXZpb3VzUm9vdCxcbiAgICAgIC8vIEV2ZW50cywgc2l6ZSBhbmQgdmlld3BvcnQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGluamVjdCBsYXllclxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLihpbmplY3RTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogaW5qZWN0U3RhdGUuZXZlbnRzKSxcbiAgICAgICAgLi4uZXZlbnRzXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICAuLi5yb290U3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgLi4udmlld3BvcnRcbiAgICAgIH0sXG4gICAgICAuLi5yZXN0XG4gICAgfTtcbiAgfSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbc3RhdGVdKTtcbiAgY29uc3QgW3VzZVBvcnRhbFN0b3JlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBtaXJyb3JlZCBzdG9yZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIHJvb3Qgd2l0aCBhIGZldyBvdmVycmlkZXMgLi4uXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlKChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC4uLnByZXZpb3VzU3RhdGUsXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIC4uLnJlc3QsXG4gICAgICAvLyBTZXQgYW5kIGdldCByZWZlciB0byB0aGlzIHJvb3Qtc3RhdGVcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIExheWVycyBhcmUgYWxsb3dlZCB0byBvdmVycmlkZSBldmVudHNcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJldmlvdXMgcm9vdC1zdGF0ZSBhbmQgY29weSBjaGFuZ2VzIG92ZXIgdG8gdGhlIG1pcnJvcmVkIHBvcnRhbC1zdGF0ZVxuICAgIGNvbnN0IHVuc3ViID0gcHJldmlvdXNSb290LnN1YnNjcmliZShwcmV2ID0+IHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKHN0YXRlID0+IGluamVjdChwcmV2LCBzdGF0ZSkpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2luamVjdF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKGluamVjdFN0YXRlID0+IGluamVjdChwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSwgaW5qZWN0U3RhdGUpKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtpbmplY3RdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdXNlUG9ydGFsU3RvcmUuZGVzdHJveSgpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IHJlY29uY2lsZXIuY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovanN4KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB1c2VQb3J0YWxTdG9yZSxcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pLCB1c2VQb3J0YWxTdG9yZSwgbnVsbClcbiAgfSk7XG59XG5cbi8qKlxyXG4gKiBGb3JjZSBSZWFjdCB0byBmbHVzaCBhbnkgdXBkYXRlcyBpbnNpZGUgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIHN5bmNocm9ub3VzbHkgYW5kIGltbWVkaWF0ZWx5LlxyXG4gKiBBbGwgdGhlIHNhbWUgY2F2ZWF0cyBkb2N1bWVudGVkIGZvciByZWFjdC1kb20ncyBgZmx1c2hTeW5jYCBhcHBseSBoZXJlIChzZWUgaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0LWRvbS9mbHVzaFN5bmMpLlxyXG4gKiBOZXZlcnRoZWxlc3MsIHNvbWV0aW1lcyBvbmUgbmVlZHMgdG8gcmVuZGVyIHN5bmNocm9ub3VzbHksIGZvciBleGFtcGxlIHRvIGtlZXAgRE9NIGFuZCAzRCBjaGFuZ2VzIGluIGxvY2stc3RlcCB3aXRob3V0XHJcbiAqIGhhdmluZyB0byByZXZlcnQgdG8gYSBub24tUmVhY3Qgc29sdXRpb24uXHJcbiAqL1xuZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gIC8vIGBmbHVzaFN5bmNgIGltcGxlbWVudGF0aW9uIG9ubHkgdGFrZXMgb25lIGFyZ3VtZW50LiBJIGRvbid0IGtub3cgd2hhdCdzIHVwIHdpdGggdGhlIHR5cGUgZGVjbGFyYXRpb24gZm9yIGl0LlxuICByZXR1cm4gcmVjb25jaWxlci5mbHVzaFN5bmMoZm4sIHVuZGVmaW5lZCk7XG59XG5yZWNvbmNpbGVyLmluamVjdEludG9EZXZUb29scyh7XG4gIGJ1bmRsZVR5cGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAwIDogMSxcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ0ByZWFjdC10aHJlZS9maWJlcicsXG4gIHZlcnNpb246IFJlYWN0LnZlcnNpb25cbn0pO1xuY29uc3QgYWN0ID0gUmVhY3QudW5zdGFibGVfYWN0O1xuXG5jb25zdCBET01fRVZFTlRTID0ge1xuICBvbkNsaWNrOiBbJ2NsaWNrJywgZmFsc2VdLFxuICBvbkNvbnRleHRNZW51OiBbJ2NvbnRleHRtZW51JywgZmFsc2VdLFxuICBvbkRvdWJsZUNsaWNrOiBbJ2RibGNsaWNrJywgZmFsc2VdLFxuICBvbldoZWVsOiBbJ3doZWVsJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckRvd246IFsncG9pbnRlcmRvd24nLCB0cnVlXSxcbiAgb25Qb2ludGVyVXA6IFsncG9pbnRlcnVwJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckxlYXZlOiBbJ3BvaW50ZXJsZWF2ZScsIHRydWVdLFxuICBvblBvaW50ZXJNb3ZlOiBbJ3BvaW50ZXJtb3ZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckNhbmNlbDogWydwb2ludGVyY2FuY2VsJywgdHJ1ZV0sXG4gIG9uTG9zdFBvaW50ZXJDYXB0dXJlOiBbJ2xvc3Rwb2ludGVyY2FwdHVyZScsIHRydWVdXG59O1xuXG4vKiogRGVmYXVsdCBSM0YgZXZlbnQgbWFuYWdlciBmb3Igd2ViICovXG5mdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnRzKHN0b3JlKSB7XG4gIGNvbnN0IHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH0gPSBjcmVhdGVFdmVudHMoc3RvcmUpO1xuICByZXR1cm4ge1xuICAgIHByaW9yaXR5OiAxLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgY29tcHV0ZShldmVudCwgc3RhdGUsIHByZXZpb3VzKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvNzgyXG4gICAgICAvLyBFdmVudHMgdHJpZ2dlciBvdXRzaWRlIG9mIGNhbnZhcyB3aGVuIG1vdmVkLCB1c2Ugb2Zmc2V0WC9ZIGJ5IGRlZmF1bHQgYW5kIGFsbG93IG92ZXJyaWRlc1xuICAgICAgc3RhdGUucG9pbnRlci5zZXQoZXZlbnQub2Zmc2V0WCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLShldmVudC5vZmZzZXRZIC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICB9LFxuICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkLFxuICAgIGhhbmRsZXJzOiBPYmplY3Qua2V5cyhET01fRVZFTlRTKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tleV06IGhhbmRsZVBvaW50ZXIoa2V5KVxuICAgIH0pLCB7fSksXG4gICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICB2YXIgX2ludGVybmFsJGxhc3RFdmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoKF9pbnRlcm5hbCRsYXN0RXZlbnQgPSBpbnRlcm5hbC5sYXN0RXZlbnQpICE9IG51bGwgJiYgX2ludGVybmFsJGxhc3RFdmVudC5jdXJyZW50ICYmIGV2ZW50cy5oYW5kbGVycykgZXZlbnRzLmhhbmRsZXJzLm9uUG9pbnRlck1vdmUoaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQpO1xuICAgIH0sXG4gICAgY29ubmVjdDogdGFyZ2V0ID0+IHtcbiAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMgPSBldmVudHMuaGFuZGxlcnMpICE9IG51bGwgPyBfZXZlbnRzJGhhbmRsZXJzIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50LCB7XG4gICAgICAgICAgcGFzc2l2ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICB2YXIgX2V2ZW50cyRoYW5kbGVyczI7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKChfZXZlbnRzJGhhbmRsZXJzMiA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMyIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50cy5jb25uZWN0ZWQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgW2V2ZW50TmFtZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgICAgZXZlbnRzLmNvbm5lY3RlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IHVzZUluc3RhbmNlSGFuZGxlIGFzIEEsIEJsb2NrIGFzIEIsIHVzZVN0b3JlIGFzIEMsIHVzZVRocmVlIGFzIEQsIEVycm9yQm91bmRhcnkgYXMgRSwgdXNlRnJhbWUgYXMgRiwgdXNlR3JhcGggYXMgRywgdXNlTG9hZGVyIGFzIEgsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgYXMgYSwgY3JlYXRlUm9vdCBhcyBiLCBjcmVhdGVQb2ludGVyRXZlbnRzIGFzIGMsIHVubW91bnRDb21wb25lbnRBdE5vZGUgYXMgZCwgZXh0ZW5kIGFzIGUsIGNyZWF0ZUV2ZW50cyBhcyBmLCBjb250ZXh0IGFzIGcsIGNyZWF0ZVBvcnRhbCBhcyBoLCBpc1JlZiBhcyBpLCByZWNvbmNpbGVyIGFzIGosIGFwcGx5UHJvcHMgYXMgaywgZGlzcG9zZSBhcyBsLCBpbnZhbGlkYXRlIGFzIG0sIGFkdmFuY2UgYXMgbiwgYWRkRWZmZWN0IGFzIG8sIGFkZEFmdGVyRWZmZWN0IGFzIHAsIGFkZFRhaWwgYXMgcSwgcmVuZGVyIGFzIHIsIGZsdXNoR2xvYmFsRWZmZWN0cyBhcyBzLCB0aHJlZVR5cGVzIGFzIHQsIHVzZU11dGFibGVDYWxsYmFjayBhcyB1LCBmbHVzaFN5bmMgYXMgdiwgZ2V0Um9vdFN0YXRlIGFzIHcsIGFjdCBhcyB4LCBidWlsZEdyYXBoIGFzIHksIHJvb3RzIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJUSFJFRSIsIlJlYWN0IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbmN1cnJlbnRSb290IiwiY3JlYXRlIiwic3VzcGVuZCIsInByZWxvYWQiLCJjbGVhciIsImpzeCIsIkZyYWdtZW50IiwiUmVjb25jaWxlciIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJ0aHJlZVR5cGVzIiwiT2JqZWN0IiwiZnJlZXplIiwiX19wcm90b19fIiwiY2F0YWxvZ3VlIiwiZXh0ZW5kIiwib2JqZWN0cyIsImFzc2lnbiIsImNyZWF0ZVJlbmRlcmVyIiwiX3Jvb3RzIiwiX2dldEV2ZW50UHJpb3JpdHkiLCJjcmVhdGVJbnN0YW5jZSIsInR5cGUiLCJhcmdzIiwiYXR0YWNoIiwicHJvcHMiLCJyb290IiwibmFtZSIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJpbnN0YW5jZSIsIm9iamVjdCIsInVuZGVmaW5lZCIsIkVycm9yIiwicHJlcGFyZSIsInByaW1pdGl2ZSIsInRhcmdldCIsIkFycmF5IiwiaXNBcnJheSIsIm1lbW9pemVkUHJvcHMiLCJfX3IzZiIsIkJ1ZmZlckdlb21ldHJ5IiwiTWF0ZXJpYWwiLCJhcHBseVByb3BzJDEiLCJhcHBlbmRDaGlsZCIsInBhcmVudEluc3RhbmNlIiwiY2hpbGQiLCJhZGRlZCIsIl9jaGlsZCRfX3IzZiIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZiIsImlzT2JqZWN0M0QiLCJhZGQiLCJwdXNoIiwicGFyZW50IiwidXBkYXRlSW5zdGFuY2UiLCJpbnZhbGlkYXRlSW5zdGFuY2UiLCJpbnNlcnRCZWZvcmUiLCJiZWZvcmVDaGlsZCIsIl9jaGlsZCRfX3IzZjIiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YyIiwiZGlzcGF0Y2hFdmVudCIsInJlc3RTaWJsaW5ncyIsImNoaWxkcmVuIiwiZmlsdGVyIiwic2libGluZyIsImluZGV4IiwiaW5kZXhPZiIsInJlbW92ZVJlY3Vyc2l2ZSIsImFycmF5IiwiZGlzcG9zZSIsImZvckVhY2giLCJyZW1vdmVDaGlsZCIsIl9wYXJlbnRJbnN0YW5jZSRfX3IzZjMiLCJfY2hpbGQkX19yM2YzIiwiX2NoaWxkJF9fcjNmNSIsIngiLCJkZXRhY2giLCJfY2hpbGQkX19yM2Y0IiwicmVtb3ZlIiwicmVtb3ZlSW50ZXJhY3Rpdml0eSIsImZpbmRJbml0aWFsUm9vdCIsImlzUHJpbWl0aXZlIiwic2hvdWxkRGlzcG9zZSIsIl9jaGlsZCRfX3IzZjYiLCJjYWxsYmFjayIsImUiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJzd2l0Y2hJbnN0YW5jZSIsIm5ld1Byb3BzIiwiZmliZXIiLCJfaW5zdGFuY2UkX19yM2YiLCJuZXdJbnN0YW5jZSIsImF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kIiwicmF5Y2FzdCIsImV2ZW50Q291bnQiLCJyb290U3RhdGUiLCJnZXRTdGF0ZSIsImludGVybmFsIiwiaW50ZXJhY3Rpb24iLCJhbHRlcm5hdGUiLCJzdGF0ZU5vZGUiLCJyZWYiLCJjdXJyZW50IiwiaGFuZGxlVGV4dEluc3RhbmNlIiwicmVjb25jaWxlciIsImFwcGVuZEluaXRpYWxDaGlsZCIsInN1cHBvcnRzTXV0YXRpb24iLCJpc1ByaW1hcnlSZW5kZXJlciIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsIm5vVGltZW91dCIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJjb250YWluZXIiLCJzY2VuZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0IiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJfaW5zdGFuY2UkX19yM2YyIiwibG9jYWxTdGF0ZSIsIkJvb2xlYW4iLCJoYW5kbGVycyIsInByZXBhcmVVcGRhdGUiLCJfdHlwZSIsIm9sZFByb3BzIiwiX2luc3RhbmNlJF9fcjNmMyIsImFyZ3NOZXciLCJjTiIsInJlc3ROZXciLCJhcmdzT2xkIiwiY08iLCJyZXN0T2xkIiwic29tZSIsInZhbHVlIiwiZGlmZiIsImRpZmZQcm9wcyIsImNoYW5nZXMiLCJsZW5ndGgiLCJjb21taXRVcGRhdGUiLCJyZWNvbnN0cnVjdCIsIl9vbGRQcm9wcyIsImNvbW1pdE1vdW50IiwiX3Byb3BzIiwiX2ludCIsIl9pbnN0YW5jZSRfX3IzZjQiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJyZXNldEFmdGVyQ29tbWl0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJjbGVhckNvbnRhaW5lciIsImhpZGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRfX3IzZjUiLCJ2aXNpYmxlIiwidW5oaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkX19yM2Y2IiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsImdldEN1cnJlbnRFdmVudFByaW9yaXR5IiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJub3ciLCJwZXJmb3JtYW5jZSIsImlzIiwiZnVuIiwiRGF0ZSIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiYXBwbHlQcm9wcyIsIl93aW5kb3ckZG9jdW1lbnQiLCJfd2luZG93JG5hdmlnYXRvciIsImhhc0NvbG9yU3BhY2UiLCJnZXRDb2xvck1hbmFnZW1lbnQiLCJfQ29sb3JNYW5hZ2VtZW50IiwiQ29sb3JNYW5hZ2VtZW50IiwiaXNPcnRob2dyYXBoaWNDYW1lcmEiLCJkZWYiLCJpc1JlZiIsIm9iaiIsImhhc093blByb3BlcnR5IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJmbiIsInVzZVJlZiIsIkJsb2NrIiwic2V0IiwiUHJvbWlzZSIsIkVycm9yQm91bmRhcnkiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwiZXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVyciIsInJlbmRlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIkRFRkFVTFQiLCJERUZBVUxUUyIsIk1hcCIsImlzRGlmZlNldCIsIm1lbW9pemVkIiwiY2FsY3VsYXRlRHByIiwiZHByIiwiX3dpbmRvdyRkZXZpY2VQaXhlbFJhIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRSb290U3RhdGUiLCJfcjNmIiwicHJldmlvdXNSb290IiwiYSIsImFyciIsInN0ciIsIm51bSIsImJvbyIsInVuZCIsImVxdSIsImIiLCJhcnJheXMiLCJzdHJpY3QiLCJpc09iaiIsImlzQXJyIiwiaSIsImtleXMiLCJidWlsZEdyYXBoIiwiZGF0YSIsIm5vZGVzIiwibWF0ZXJpYWxzIiwidHJhdmVyc2UiLCJtYXRlcmlhbCIsInAiLCJwcmV2aW91c0F0dGFjaCIsInJlc29sdmUiLCJrZXkiLCJpbmNsdWRlcyIsImVudHJpZXMiLCJzcGxpdCIsImxhc3QiLCJwb3AiLCJyZWR1Y2UiLCJhY2MiLCJJTkRFWF9SRUdFWCIsInRlc3QiLCJyZXBsYWNlIiwicHJldmlvdXMiLCJrTiIsInJOIiwiY1AiLCJrUCIsInJQIiwicHJldmlvdXNLZXlzIiwidW5zaGlmdCIsInByb3AiLCJzdGFydHNXaXRoIiwiX19ERVZfXyIsInByb2Nlc3MiLCJwcmV2SGFuZGxlcnMiLCJpc0V2ZW50Iiwic1JHQkVuY29kaW5nIiwiU1JHQkNvbG9yU3BhY2UiLCJMaW5lYXJTUkdCQ29sb3JTcGFjZSIsImN1cnJlbnRJbnN0YW5jZSIsInRhcmdldFByb3AiLCJyZXZlcnNlRW50cmllcyIsInJldmVyc2UiLCJjdG9yIiwiZ2V0IiwiY29weSIsIkxheWVycyIsImZyb21BcnJheSIsImlzQ29sb3IiLCJDb2xvciIsInNldFNjYWxhciIsIm1hc2siLCJsaW5lYXIiLCJjb252ZXJ0U1JHQlRvTGluZWFyIiwiVGV4dHVyZSIsImZvcm1hdCIsIlJHQkFGb3JtYXQiLCJVbnNpZ25lZEJ5dGVUeXBlIiwidGV4dHVyZSIsImdsIiwiY29sb3JTcGFjZSIsIm91dHB1dENvbG9yU3BhY2UiLCJlbmNvZGluZyIsIm91dHB1dEVuY29kaW5nIiwic3BsaWNlIiwiaXNDaXJjdWxhciIsIl9pbnN0YW5jZSRfX3IzZjMkcm9vdCIsImZyYW1lcyIsImludmFsaWRhdGUiLCJvblVwZGF0ZSIsInVwZGF0ZUNhbWVyYSIsImNhbWVyYSIsInNpemUiLCJtYW51YWwiLCJsZWZ0Iiwid2lkdGgiLCJyaWdodCIsInRvcCIsImhlaWdodCIsImJvdHRvbSIsImFzcGVjdCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJ1cGRhdGVNYXRyaXhXb3JsZCIsIm1ha2VJZCIsImV2ZW50IiwiZXZlbnRPYmplY3QiLCJ1dWlkIiwiaW5zdGFuY2VJZCIsImdldEV2ZW50UHJpb3JpdHkiLCJfZ2xvYmFsU2NvcGUkZXZlbnQiLCJnbG9iYWxTY29wZSIsInNlbGYiLCJyZWxlYXNlSW50ZXJuYWxQb2ludGVyQ2FwdHVyZSIsImNhcHR1cmVkTWFwIiwiY2FwdHVyZXMiLCJwb2ludGVySWQiLCJjYXB0dXJlRGF0YSIsImRlbGV0ZSIsInJlbGVhc2VQb2ludGVyQ2FwdHVyZSIsInN0b3JlIiwibyIsImluaXRpYWxIaXRzIiwiaG92ZXJlZCIsImNyZWF0ZUV2ZW50cyIsImNhbGN1bGF0ZURpc3RhbmNlIiwiZHgiLCJvZmZzZXRYIiwiaW5pdGlhbENsaWNrIiwiZHkiLCJvZmZzZXRZIiwicm91bmQiLCJzcXJ0IiwiZmlsdGVyUG9pbnRlckV2ZW50cyIsImludGVyc2VjdCIsImR1cGxpY2F0ZXMiLCJTZXQiLCJpbnRlcnNlY3Rpb25zIiwiZXZlbnRzT2JqZWN0cyIsInJheWNhc3RlciIsImV2ZW50cyIsImNvbXB1dGUiLCJoYW5kbGVSYXljYXN0IiwiZW5hYmxlZCIsIl9zdGF0ZSRwcmV2aW91c1Jvb3QiLCJpbnRlcnNlY3RPYmplY3QiLCJoaXRzIiwiZmxhdE1hcCIsInNvcnQiLCJhU3RhdGUiLCJiU3RhdGUiLCJkaXN0YW5jZSIsInByaW9yaXR5IiwiaXRlbSIsImlkIiwiaGFzIiwiaGl0IiwiX3IzZjIiLCJ2YWx1ZXMiLCJpbnRlcnNlY3Rpb24iLCJoYW5kbGVJbnRlcnNlY3RzIiwiZGVsdGEiLCJzdG9wcGVkIiwicG9pbnRlciIsInVucHJvamVjdGVkUG9pbnQiLCJWZWN0b3IzIiwieSIsInVucHJvamVjdCIsImhhc1BvaW50ZXJDYXB0dXJlIiwiX2ludGVybmFsJGNhcHR1cmVkTWFwIiwiX2ludGVybmFsJGNhcHR1cmVkTWFwMiIsInNldFBvaW50ZXJDYXB0dXJlIiwiZXh0cmFjdEV2ZW50UHJvcHMiLCJwcm9wZXJ0eSIsInJheWNhc3RFdmVudCIsInJheSIsInN0b3BQcm9wYWdhdGlvbiIsImNhcHR1cmVzRm9yUG9pbnRlciIsImZyb20iLCJmaW5kIiwiaGlnaGVyIiwiY2FuY2VsUG9pbnRlciIsImN1cnJlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsImhvdmVyZWRPYmoiLCJvblBvaW50ZXJPdXQiLCJvblBvaW50ZXJMZWF2ZSIsInBvaW50ZXJNaXNzZWQiLCJvblBvaW50ZXJNaXNzZWQiLCJoYW5kbGVQb2ludGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlRXZlbnQiLCJsYXN0RXZlbnQiLCJpc1BvaW50ZXJNb3ZlIiwiaXNDbGlja0V2ZW50IiwibWFwIiwib25JbnRlcnNlY3QiLCJvblBvaW50ZXJPdmVyIiwib25Qb2ludGVyRW50ZXIiLCJob3ZlcmVkSXRlbSIsIm9uUG9pbnRlck1vdmUiLCJoYW5kbGVyIiwicHJpdmF0ZUtleXMiLCJpc1JlbmRlcmVyIiwiY29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVTdG9yZSIsImFkdmFuY2UiLCJwb3NpdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJ0ZW1wVGFyZ2V0IiwiZ2V0Q3VycmVudFZpZXdwb3J0IiwiZ2V0V29ybGRQb3NpdGlvbiIsImRpc3RhbmNlVG8iLCJ6b29tIiwiZmFjdG9yIiwiZm92IiwiUEkiLCJoIiwidGFuIiwidyIsInBlcmZvcm1hbmNlVGltZW91dCIsInNldFBlcmZvcm1hbmNlQ3VycmVudCIsIlZlY3RvcjIiLCJjb25uZWN0ZWQiLCJ4ciIsInRpbWVzdGFtcCIsInJ1bkdsb2JhbEVmZmVjdHMiLCJsZWdhY3kiLCJmbGF0IiwiY29udHJvbHMiLCJjbG9jayIsIkNsb2NrIiwibW91c2UiLCJmcmFtZWxvb3AiLCJkZWJvdW5jZSIsInJlZ3Jlc3MiLCJ1cGRhdGVTdHlsZSIsInZpZXdwb3J0IiwiaW5pdGlhbERwciIsInNldEV2ZW50cyIsInNldFNpemUiLCJzZXREcHIiLCJyZXNvbHZlZCIsInNldEZyYW1lbG9vcCIsInN0b3AiLCJlbGFwc2VkVGltZSIsInN0YXJ0IiwiYWN0aXZlIiwiY3JlYXRlUmVmIiwic3Vic2NyaWJlcnMiLCJzdWJzY3JpYmUiLCJzIiwib2xkU2l6ZSIsIm9sZERwciIsIm9sZENhbWVyYSIsIl9zaXplJHVwZGF0ZVN0eWxlIiwic2V0UGl4ZWxSYXRpbyIsIkhUTUxDYW52YXNFbGVtZW50IiwiZG9tRWxlbWVudCIsImNyZWF0ZVN1YnMiLCJzdWJzIiwic3ViIiwiZ2xvYmFsRWZmZWN0cyIsImdsb2JhbEFmdGVyRWZmZWN0cyIsImdsb2JhbFRhaWxFZmZlY3RzIiwiYWRkRWZmZWN0IiwiYWRkQWZ0ZXJFZmZlY3QiLCJhZGRUYWlsIiwicnVuIiwiZWZmZWN0cyIsImZsdXNoR2xvYmFsRWZmZWN0cyIsInN1YnNjcmlwdGlvbiIsInJlbmRlciQxIiwiZnJhbWUiLCJnZXREZWx0YSIsIm9sZFRpbWUiLCJjcmVhdGVMb29wIiwicm9vdHMiLCJydW5uaW5nIiwidXNlRnJhbWVJblByb2dyZXNzIiwicmVwZWF0IiwibG9vcCIsIl9zdGF0ZSRnbCR4ciIsImlzUHJlc2VudGluZyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX3N0YXRlJGdsJHhyMiIsInVzZUluc3RhbmNlSGFuZGxlIiwidXNlU3RvcmUiLCJ1c2VDb250ZXh0IiwidXNlVGhyZWUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJ1c2VGcmFtZSIsInJlbmRlclByaW9yaXR5IiwidXNlR3JhcGgiLCJ1c2VNZW1vIiwibWVtb2l6ZWRMb2FkZXJzIiwiV2Vha01hcCIsImxvYWRpbmdGbiIsImV4dGVuc2lvbnMiLCJvblByb2dyZXNzIiwiUHJvdG8iLCJpbnB1dCIsImxvYWRlciIsImFsbCIsInJlcyIsInJlamVjdCIsImxvYWQiLCJtZXNzYWdlIiwidXNlTG9hZGVyIiwicmVzdWx0cyIsImVxdWFsIiwic2hhbGxvd0xvb3NlIiwiY3JlYXRlUmVuZGVyZXJJbnN0YW5jZSIsImNhbnZhcyIsImN1c3RvbVJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsInBvd2VyUHJlZmVyZW5jZSIsImFudGlhbGlhcyIsImFscGhhIiwiY29tcHV0ZUluaXRpYWxTaXplIiwiZGVmYXVsdFNpemUiLCJkZWZhdWx0U3R5bGUiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlUm9vdCIsInByZXZSb290IiwicHJldkZpYmVyIiwicHJldlN0b3JlIiwiY29uc29sZSIsIndhcm4iLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwicmVwb3J0RXJyb3IiLCJjcmVhdGVDb250YWluZXIiLCJvbkNyZWF0ZWQiLCJjb25maWd1cmVkIiwibGFzdENhbWVyYSIsImNvbmZpZ3VyZSIsImdsQ29uZmlnIiwicHJvcHNTaXplIiwic2NlbmVPcHRpb25zIiwib25DcmVhdGVkQ2FsbGJhY2siLCJzaGFkb3dzIiwib3J0aG9ncmFwaGljIiwicmF5Y2FzdE9wdGlvbnMiLCJjYW1lcmFPcHRpb25zIiwiUmF5Y2FzdGVyIiwicGFyYW1zIiwib3B0aW9ucyIsImlzQ2FtZXJhIiwiQ2FtZXJhIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ6Iiwicm90YXRpb24iLCJsb29rQXQiLCJTY2VuZSIsIl9nbCR4ciIsImhhbmRsZVhSRnJhbWUiLCJoYW5kbGVTZXNzaW9uQ2hhbmdlIiwic2V0QW5pbWF0aW9uTG9vcCIsImNvbm5lY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzaGFkb3dNYXAiLCJvbGRFbmFibGVkIiwib2xkVHlwZSIsIlBDRlNvZnRTaGFkb3dNYXAiLCJfdHlwZXMkc2hhZG93cyIsInR5cGVzIiwiYmFzaWMiLCJCYXNpY1NoYWRvd01hcCIsInBlcmNlbnRhZ2UiLCJQQ0ZTaGFkb3dNYXAiLCJzb2Z0IiwidmFyaWFuY2UiLCJWU01TaGFkb3dNYXAiLCJuZWVkc1VwZGF0ZSIsImxlZ2FjeU1vZGUiLCJMaW5lYXJFbmNvZGluZyIsInRvbmVNYXBwaW5nIiwiTm9Ub25lTWFwcGluZyIsIkFDRVNGaWxtaWNUb25lTWFwcGluZyIsInVwZGF0ZUNvbnRhaW5lciIsIlByb3ZpZGVyIiwicm9vdEVsZW1lbnQiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImNvbmZpZyIsIl9zdGF0ZSRnbCIsIl9zdGF0ZSRnbCRyZW5kZXJMaXN0cyIsIl9zdGF0ZSRnbDIiLCJfc3RhdGUkZ2wzIiwicmVuZGVyTGlzdHMiLCJmb3JjZUNvbnRleHRMb3NzIiwiY3JlYXRlUG9ydGFsIiwiUG9ydGFsIiwicmVzdCIsInVzZVN0YXRlIiwiaW5qZWN0IiwidXNlQ2FsbGJhY2siLCJpbmplY3RTdGF0ZSIsInVzZVBvcnRhbFN0b3JlIiwicHJldmlvdXNTdGF0ZSIsInVuc3ViIiwicHJldiIsInNldFN0YXRlIiwiZGVzdHJveSIsImZsdXNoU3luYyIsImluamVjdEludG9EZXZUb29scyIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwidmVyc2lvbiIsImFjdCIsInVuc3RhYmxlX2FjdCIsIkRPTV9FVkVOVFMiLCJvbkNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uRG91YmxlQ2xpY2siLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlclVwIiwib25Qb2ludGVyQ2FuY2VsIiwib25Mb3N0UG9pbnRlckNhcHR1cmUiLCJjcmVhdGVQb2ludGVyRXZlbnRzIiwic2V0RnJvbUNhbWVyYSIsInVwZGF0ZSIsIl9pbnRlcm5hbCRsYXN0RXZlbnQiLCJfZXZlbnRzJGhhbmRsZXJzIiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsIl9ldmVudHMkaGFuZGxlcnMyIiwiSFRNTEVsZW1lbnQiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJHIiwiSCIsImMiLCJkIiwiZiIsImciLCJqIiwiayIsImwiLCJtIiwibiIsInEiLCJyIiwidCIsInUiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   act: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   addEffect: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addTail: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   advance: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   applyProps: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   context: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createEvents: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createPointerEvents: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   createRoot: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   events: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   extend: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   flushSync: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   getRootState: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   invalidate: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   reconciler: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   render: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useGraph: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useLoader: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   useStore: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useThree: () => (/* reexport safe */ _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.D)\n/* harmony export */ });\n/* harmony import */ var _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events-321b05fb.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/events-321b05fb.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debounce */ \"(ssr)/./node_modules/debounce/index.js\");\n/* harmony import */ var debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debounce__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* eslint-disable react-hooks/rules-of-hooks */ function useMeasure({ debounce, scroll, polyfill, offsetSize } = {\n    debounce: 0,\n    scroll: false,\n    offsetSize: false\n}) {\n    const ResizeObserver = polyfill ||  false && 0;\n    const [bounds, set] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        bottom: 0,\n        right: 0,\n        x: 0,\n        y: 0\n    });\n    // In test mode\n    if (!ResizeObserver) {\n        // @ts-ignore\n        bounds.width = 1280;\n        // @ts-ignore\n        bounds.height = 800;\n        return [\n            ()=>{},\n            bounds,\n            ()=>{}\n        ];\n    }\n    // keep all state in a ref\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        element: null,\n        scrollContainers: null,\n        resizeObserver: null,\n        lastBounds: bounds,\n        orientationHandler: null\n    });\n    // set actual debounce values early, so effects know if they should react accordingly\n    const scrollDebounce = debounce ? typeof debounce === \"number\" ? debounce : debounce.scroll : null;\n    const resizeDebounce = debounce ? typeof debounce === \"number\" ? debounce : debounce.resize : null;\n    // make sure to update state only as long as the component is truly mounted\n    const mounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        mounted.current = true;\n        return ()=>void (mounted.current = false);\n    });\n    // memoize handlers, so event-listeners know when they should update\n    const [forceRefresh, resizeChange, scrollChange] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const callback = ()=>{\n            if (!state.current.element) return;\n            const { left, top, width, height, bottom, right, x, y } = state.current.element.getBoundingClientRect();\n            const size = {\n                left,\n                top,\n                width,\n                height,\n                bottom,\n                right,\n                x,\n                y\n            };\n            if (state.current.element instanceof HTMLElement && offsetSize) {\n                size.height = state.current.element.offsetHeight;\n                size.width = state.current.element.offsetWidth;\n            }\n            Object.freeze(size);\n            if (mounted.current && !areBoundsEqual(state.current.lastBounds, size)) set(state.current.lastBounds = size);\n        };\n        return [\n            callback,\n            resizeDebounce ? debounce__WEBPACK_IMPORTED_MODULE_2___default()(callback, resizeDebounce) : callback,\n            scrollDebounce ? debounce__WEBPACK_IMPORTED_MODULE_2___default()(callback, scrollDebounce) : callback\n        ];\n    }, [\n        set,\n        offsetSize,\n        scrollDebounce,\n        resizeDebounce\n    ]);\n    // cleanup current scroll-listeners / observers\n    function removeListeners() {\n        if (state.current.scrollContainers) {\n            state.current.scrollContainers.forEach((element)=>element.removeEventListener(\"scroll\", scrollChange, true));\n            state.current.scrollContainers = null;\n        }\n        if (state.current.resizeObserver) {\n            state.current.resizeObserver.disconnect();\n            state.current.resizeObserver = null;\n        }\n        if (state.current.orientationHandler) {\n            if (\"orientation\" in screen && \"removeEventListener\" in screen.orientation) {\n                screen.orientation.removeEventListener(\"change\", state.current.orientationHandler);\n            } else if (\"onorientationchange\" in window) {\n                window.removeEventListener(\"orientationchange\", state.current.orientationHandler);\n            }\n        }\n    }\n    // add scroll-listeners / observers\n    function addListeners() {\n        var _state$current$resize;\n        if (!state.current.element) return;\n        state.current.resizeObserver = new ResizeObserver(resizeChange);\n        (_state$current$resize = state.current.resizeObserver) == null ? void 0 : _state$current$resize.observe(state.current.element);\n        if (scroll && state.current.scrollContainers) {\n            state.current.scrollContainers.forEach((scrollContainer)=>scrollContainer.addEventListener(\"scroll\", scrollChange, {\n                    capture: true,\n                    passive: true\n                }));\n        }\n        // Handle orientation changes\n        state.current.orientationHandler = ()=>{\n            scrollChange();\n        };\n        // Use screen.orientation if available\n        if (\"orientation\" in screen && \"addEventListener\" in screen.orientation) {\n            screen.orientation.addEventListener(\"change\", state.current.orientationHandler);\n        } else if (\"onorientationchange\" in window) {\n            // Fallback to orientationchange event\n            window.addEventListener(\"orientationchange\", state.current.orientationHandler);\n        }\n    }\n    // the ref we expose to the user\n    const ref = (node)=>{\n        if (!node || node === state.current.element) return;\n        removeListeners();\n        state.current.element = node;\n        state.current.scrollContainers = findScrollContainers(node);\n        addListeners();\n    };\n    // add general event listeners\n    useOnWindowScroll(scrollChange, Boolean(scroll));\n    useOnWindowResize(resizeChange);\n    // respond to changes that are relevant for the listeners\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        removeListeners();\n        addListeners();\n    }, [\n        scroll,\n        scrollChange,\n        resizeChange\n    ]);\n    // remove all listeners when the components unmounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>removeListeners, []);\n    return [\n        ref,\n        bounds,\n        forceRefresh\n    ];\n}\n// Adds native resize listener to window\nfunction useOnWindowResize(onWindowResize) {\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const cb = onWindowResize;\n        window.addEventListener(\"resize\", cb);\n        return ()=>void window.removeEventListener(\"resize\", cb);\n    }, [\n        onWindowResize\n    ]);\n}\nfunction useOnWindowScroll(onScroll, enabled) {\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (enabled) {\n            const cb = onScroll;\n            window.addEventListener(\"scroll\", cb, {\n                capture: true,\n                passive: true\n            });\n            return ()=>void window.removeEventListener(\"scroll\", cb, true);\n        }\n    }, [\n        onScroll,\n        enabled\n    ]);\n}\n// Returns a list of scroll offsets\nfunction findScrollContainers(element) {\n    const result = [];\n    if (!element || element === document.body) return result;\n    const { overflow, overflowX, overflowY } = window.getComputedStyle(element);\n    if ([\n        overflow,\n        overflowX,\n        overflowY\n    ].some((prop)=>prop === \"auto\" || prop === \"scroll\")) result.push(element);\n    return [\n        ...result,\n        ...findScrollContainers(element.parentElement)\n    ];\n}\n// Checks if element boundaries are equal\nconst keys = [\n    \"x\",\n    \"y\",\n    \"top\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"width\",\n    \"height\"\n];\nconst areBoundsEqual = (a, b)=>keys.every((key)=>a[key] === b[key]);\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = _events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.c, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_7__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_8__.useContextBridge)();\n    const [containerRef, containerRect] = useMeasure({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    (0,_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(Bridge, {\n                children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                    set: setError,\n                    children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(react__WEBPACK_IMPORTED_MODULE_1__.Suspense, {\n                        fallback: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                            set: setBlock\n                        }),\n                        children: children\n                    })\n                })\n            }));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_events_321b05fb_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        },\n        ...props,\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"div\", {\n            ref: containerRef,\n            style: {\n                width: \"100%\",\n                height: \"100%\"\n            },\n            children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    display: \"block\"\n                },\n                children: fallback\n            })\n        })\n    });\n});\n/**\r\n * A DOM canvas which accepts threejs elements as children.\r\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\r\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(its_fine__WEBPACK_IMPORTED_MODULE_8__.FiberProvider, {\n        children: /*#__PURE__*/ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(CanvasImpl, {\n            ...props,\n            ref: ref\n        })\n    });\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9PO0FBQ3lVO0FBQzlnQjtBQUM4QjtBQUM5QjtBQUNPO0FBQ3FCO0FBQ25CO0FBQ0o7QUFDbkI7QUFDTTtBQUNHO0FBQ1A7QUFFbkIsNkNBQTZDLEdBQzdDLFNBQVMrRSxXQUFXLEVBQ2xCQyxRQUFRLEVBQ1JDLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1gsR0FBRztJQUNGSCxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkUsWUFBWTtBQUNkLENBQUM7SUFDQyxNQUFNQyxpQkFBaUJGLFlBQVksTUFBa0IsSUFBZUcsQ0FBcUI7SUFDekYsTUFBTSxDQUFDQyxRQUFRQyxJQUFJLEdBQUdqQiwrQ0FBUUEsQ0FBQztRQUM3QmtCLE1BQU07UUFDTkMsS0FBSztRQUNMQyxPQUFPO1FBQ1BDLFFBQVE7UUFDUkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1B2RSxHQUFHO1FBQ0hZLEdBQUc7SUFDTDtJQUVBLGVBQWU7SUFDZixJQUFJLENBQUNrRCxnQkFBZ0I7UUFDbkIsYUFBYTtRQUNiRSxPQUFPSSxLQUFLLEdBQUc7UUFDZixhQUFhO1FBQ2JKLE9BQU9LLE1BQU0sR0FBRztRQUNoQixPQUFPO1lBQUMsS0FBTztZQUFHTDtZQUFRLEtBQU87U0FBRTtJQUNyQztJQUVBLDBCQUEwQjtJQUMxQixNQUFNUSxRQUFRdkIsNkNBQU1BLENBQUM7UUFDbkJ3QixTQUFTO1FBQ1RDLGtCQUFrQjtRQUNsQkMsZ0JBQWdCO1FBQ2hCQyxZQUFZWjtRQUNaYSxvQkFBb0I7SUFDdEI7SUFFQSxxRkFBcUY7SUFDckYsTUFBTUMsaUJBQWlCcEIsV0FBVyxPQUFPQSxhQUFhLFdBQVdBLFdBQVdBLFNBQVNDLE1BQU0sR0FBRztJQUM5RixNQUFNb0IsaUJBQWlCckIs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QixLQUFLO1FBQ1JuQixVQUFVLFdBQVcsR0FBRS9FLHNEQUFHQSxDQUFDLE9BQU87WUFDaENvRCxLQUFLaUQ7WUFDTHBCLE9BQU87Z0JBQ0xyRSxPQUFPO2dCQUNQQyxRQUFRO1lBQ1Y7WUFDQWtFLFVBQVUsV0FBVyxHQUFFL0Usc0RBQUdBLENBQUMsVUFBVTtnQkFDbkNvRCxLQUFLbUQ7Z0JBQ0x0QixPQUFPO29CQUNMMkMsU0FBUztnQkFDWDtnQkFDQTdDLFVBQVVDO1lBQ1o7UUFDRjtJQUNGO0FBQ0Y7QUFFQTs7O0NBR0MsR0FDRCxNQUFNRixTQUFTLFdBQVcsR0FBRXZGLDZDQUFnQixDQUFDLFNBQVNzSSxjQUFjM0IsS0FBSyxFQUFFOUMsR0FBRztJQUM1RSxPQUFPLFdBQVcsR0FBRXBELHNEQUFHQSxDQUFDRixtREFBYUEsRUFBRTtRQUNyQ2lGLFVBQVUsV0FBVyxHQUFFL0Usc0RBQUdBLENBQUM0RSxZQUFZO1lBQ3JDLEdBQUdzQixLQUFLO1lBQ1I5QyxLQUFLQTtRQUNQO0lBQ0Y7QUFDRjtBQUVrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByYWJsby1zdHVkaW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzPzc5Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyBhcyBjcmVhdGVQb2ludGVyRXZlbnRzLCBlIGFzIGV4dGVuZCwgdSBhcyB1c2VNdXRhYmxlQ2FsbGJhY2ssIGEgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgYiBhcyBjcmVhdGVSb290LCBpIGFzIGlzUmVmLCBFIGFzIEVycm9yQm91bmRhcnksIEIgYXMgQmxvY2ssIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB9IGZyb20gJy4vZXZlbnRzLTMyMWIwNWZiLmVzbS5qcyc7XG5leHBvcnQgeyB0IGFzIFJlYWN0VGhyZWVGaWJlciwgeiBhcyBfcm9vdHMsIHggYXMgYWN0LCBwIGFzIGFkZEFmdGVyRWZmZWN0LCBvIGFzIGFkZEVmZmVjdCwgcSBhcyBhZGRUYWlsLCBuIGFzIGFkdmFuY2UsIGsgYXMgYXBwbHlQcm9wcywgeSBhcyBidWlsZEdyYXBoLCBnIGFzIGNvbnRleHQsIGYgYXMgY3JlYXRlRXZlbnRzLCBjIGFzIGNyZWF0ZVBvaW50ZXJFdmVudHMsIGggYXMgY3JlYXRlUG9ydGFsLCBiIGFzIGNyZWF0ZVJvb3QsIGwgYXMgZGlzcG9zZSwgYyBhcyBldmVudHMsIGUgYXMgZXh0ZW5kLCBzIGFzIGZsdXNoR2xvYmFsRWZmZWN0cywgdiBhcyBmbHVzaFN5bmMsIHcgYXMgZ2V0Um9vdFN0YXRlLCBtIGFzIGludmFsaWRhdGUsIGogYXMgcmVjb25jaWxlciwgciBhcyByZW5kZXIsIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSwgRiBhcyB1c2VGcmFtZSwgRyBhcyB1c2VHcmFwaCwgQSBhcyB1c2VJbnN0YW5jZUhhbmRsZSwgSCBhcyB1c2VMb2FkZXIsIEMgYXMgdXNlU3RvcmUsIEQgYXMgdXNlVGhyZWUgfSBmcm9tICcuL2V2ZW50cy0zMjFiMDVmYi5lc20uanMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IGNyZWF0ZURlYm91bmNlIGZyb20gJ2RlYm91bmNlJztcbmltcG9ydCB7IEZpYmVyUHJvdmlkZXIsIHVzZUNvbnRleHRCcmlkZ2UgfSBmcm9tICdpdHMtZmluZSc7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAnenVzdGFuZCc7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuaW1wb3J0ICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCAnc2NoZWR1bGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3MgKi9cbmZ1bmN0aW9uIHVzZU1lYXN1cmUoe1xuICBkZWJvdW5jZSxcbiAgc2Nyb2xsLFxuICBwb2x5ZmlsbCxcbiAgb2Zmc2V0U2l6ZVxufSA9IHtcbiAgZGVib3VuY2U6IDAsXG4gIHNjcm9sbDogZmFsc2UsXG4gIG9mZnNldFNpemU6IGZhbHNlXG59KSB7XG4gIGNvbnN0IFJlc2l6ZU9ic2VydmVyID0gcG9seWZpbGwgfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlJlc2l6ZU9ic2VydmVyO1xuICBjb25zdCBbYm91bmRzLCBzZXRdID0gdXNlU3RhdGUoe1xuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0pO1xuXG4gIC8vIEluIHRlc3QgbW9kZVxuICBpZiAoIVJlc2l6ZU9ic2VydmVyKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGJvdW5kcy53aWR0aCA9IDEyODA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGJvdW5kcy5oZWlnaHQgPSA4MDA7XG4gICAgcmV0dXJuIFsoKSA9PiB7fSwgYm91bmRzLCAoKSA9PiB7fV07XG4gIH1cblxuICAvLyBrZWVwIGFsbCBzdGF0ZSBpbiBhIHJlZlxuICBjb25zdCBzdGF0ZSA9IHVzZVJlZih7XG4gICAgZWxlbWVudDogbnVsbCxcbiAgICBzY3JvbGxDb250YWluZXJzOiBudWxsLFxuICAgIHJlc2l6ZU9ic2VydmVyOiBudWxsLFxuICAgIGxhc3RCb3VuZHM6IGJvdW5kcyxcbiAgICBvcmllbnRhdGlvbkhhbmRsZXI6IG51bGxcbiAgfSk7XG5cbiAgLy8gc2V0IGFjdHVhbCBkZWJvdW5jZSB2YWx1ZXMgZWFybHksIHNvIGVmZmVjdHMga25vdyBpZiB0aGV5IHNob3VsZCByZWFjdCBhY2NvcmRpbmdseVxuICBjb25zdCBzY3JvbGxEZWJvdW5jZSA9IGRlYm91bmNlID8gdHlwZW9mIGRlYm91bmNlID09PSAnbnVtYmVyJyA/IGRlYm91bmNlIDogZGVib3VuY2Uuc2Nyb2xsIDogbnVsbDtcbiAgY29uc3QgcmVzaXplRGVib3VuY2UgPSBkZWJvdW5jZSA/IHR5cGVvZiBkZWJvdW5jZSA9PT0gJ251bWJlcicgPyBkZWJvdW5jZSA6IGRlYm91bmNlLnJlc2l6ZSA6IG51bGw7XG5cbiAgLy8gbWFrZSBzdXJlIHRvIHVwZGF0ZSBzdGF0ZSBvbmx5IGFzIGxvbmcgYXMgdGhlIGNvbXBvbmVudCBpcyB0cnVseSBtb3VudGVkXG4gIGNvbnN0IG1vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHZvaWQgKG1vdW50ZWQuY3VycmVudCA9IGZhbHNlKTtcbiAgfSk7XG5cbiAgLy8gbWVtb2l6ZSBoYW5kbGVycywgc28gZXZlbnQtbGlzdGVuZXJzIGtub3cgd2hlbiB0aGV5IHNob3VsZCB1cGRhdGVcbiAgY29uc3QgW2ZvcmNlUmVmcmVzaCwgcmVzaXplQ2hhbmdlLCBzY3JvbGxDaGFuZ2VdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXN0YXRlLmN1cnJlbnQuZWxlbWVudCkgcmV0dXJuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBzdGF0ZS5jdXJyZW50LmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBpZiAoc3RhdGUuY3VycmVudC5lbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgb2Zmc2V0U2l6ZSkge1xuICAgICAgICBzaXplLmhlaWdodCA9IHN0YXRlLmN1cnJlbnQuZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHNpemUud2lkdGggPSBzdGF0ZS5jdXJyZW50LmVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICB9XG4gICAgICBPYmplY3QuZnJlZXplKHNpemUpO1xuICAgICAgaWYgKG1vdW50ZWQuY3VycmVudCAmJiAhYXJlQm91bmRzRXF1YWwoc3RhdGUuY3VycmVudC5sYXN0Qm91bmRzLCBzaXplKSkgc2V0KHN0YXRlLmN1cnJlbnQubGFzdEJvdW5kcyA9IHNpemUpO1xuICAgIH07XG4gICAgcmV0dXJuIFtjYWxsYmFjaywgcmVzaXplRGVib3VuY2UgPyBjcmVhdGVEZWJvdW5jZShjYWxsYmFjaywgcmVzaXplRGVib3VuY2UpIDogY2FsbGJhY2ssIHNjcm9sbERlYm91bmNlID8gY3JlYXRlRGVib3VuY2UoY2FsbGJhY2ssIHNjcm9sbERlYm91bmNlKSA6IGNhbGxiYWNrXTtcbiAgfSwgW3NldCwgb2Zmc2V0U2l6ZSwgc2Nyb2xsRGVib3VuY2UsIHJlc2l6ZURlYm91bmNlXSk7XG5cbiAgLy8gY2xlYW51cCBjdXJyZW50IHNjcm9sbC1saXN0ZW5lcnMgLyBvYnNlcnZlcnNcbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGlmIChzdGF0ZS5jdXJyZW50LnNjcm9sbENvbnRhaW5lcnMpIHtcbiAgICAgIHN0YXRlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycy5mb3JFYWNoKGVsZW1lbnQgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxDaGFuZ2UsIHRydWUpKTtcbiAgICAgIHN0YXRlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycyA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jdXJyZW50LnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICBzdGF0ZS5jdXJyZW50LnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHN0YXRlLmN1cnJlbnQucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY3VycmVudC5vcmllbnRhdGlvbkhhbmRsZXIpIHtcbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIHNjcmVlbiAmJiAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gc2NyZWVuLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIHNjcmVlbi5vcmllbnRhdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBzdGF0ZS5jdXJyZW50Lm9yaWVudGF0aW9uSGFuZGxlcik7XG4gICAgICB9IGVsc2UgaWYgKCdvbm9yaWVudGF0aW9uY2hhbmdlJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgc3RhdGUuY3VycmVudC5vcmllbnRhdGlvbkhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBzY3JvbGwtbGlzdGVuZXJzIC8gb2JzZXJ2ZXJzXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVycygpIHtcbiAgICB2YXIgX3N0YXRlJGN1cnJlbnQkcmVzaXplO1xuICAgIGlmICghc3RhdGUuY3VycmVudC5lbGVtZW50KSByZXR1cm47XG4gICAgc3RhdGUuY3VycmVudC5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihyZXNpemVDaGFuZ2UpO1xuICAgIChfc3RhdGUkY3VycmVudCRyZXNpemUgPSBzdGF0ZS5jdXJyZW50LnJlc2l6ZU9ic2VydmVyKSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGN1cnJlbnQkcmVzaXplLm9ic2VydmUoc3RhdGUuY3VycmVudC5lbGVtZW50KTtcbiAgICBpZiAoc2Nyb2xsICYmIHN0YXRlLmN1cnJlbnQuc2Nyb2xsQ29udGFpbmVycykge1xuICAgICAgc3RhdGUuY3VycmVudC5zY3JvbGxDb250YWluZXJzLmZvckVhY2goc2Nyb2xsQ29udGFpbmVyID0+IHNjcm9sbENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzY3JvbGxDaGFuZ2UsIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvcmllbnRhdGlvbiBjaGFuZ2VzXG4gICAgc3RhdGUuY3VycmVudC5vcmllbnRhdGlvbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBzY3JvbGxDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgLy8gVXNlIHNjcmVlbi5vcmllbnRhdGlvbiBpZiBhdmFpbGFibGVcbiAgICBpZiAoJ29yaWVudGF0aW9uJyBpbiBzY3JlZW4gJiYgJ2FkZEV2ZW50TGlzdGVuZXInIGluIHNjcmVlbi5vcmllbnRhdGlvbikge1xuICAgICAgc2NyZWVuLm9yaWVudGF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHN0YXRlLmN1cnJlbnQub3JpZW50YXRpb25IYW5kbGVyKTtcbiAgICB9IGVsc2UgaWYgKCdvbm9yaWVudGF0aW9uY2hhbmdlJyBpbiB3aW5kb3cpIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG9yaWVudGF0aW9uY2hhbmdlIGV2ZW50XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCBzdGF0ZS5jdXJyZW50Lm9yaWVudGF0aW9uSGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlIHJlZiB3ZSBleHBvc2UgdG8gdGhlIHVzZXJcbiAgY29uc3QgcmVmID0gbm9kZSA9PiB7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUgPT09IHN0YXRlLmN1cnJlbnQuZWxlbWVudCkgcmV0dXJuO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgIHN0YXRlLmN1cnJlbnQuZWxlbWVudCA9IG5vZGU7XG4gICAgc3RhdGUuY3VycmVudC5zY3JvbGxDb250YWluZXJzID0gZmluZFNjcm9sbENvbnRhaW5lcnMobm9kZSk7XG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gIH07XG5cbiAgLy8gYWRkIGdlbmVyYWwgZXZlbnQgbGlzdGVuZXJzXG4gIHVzZU9uV2luZG93U2Nyb2xsKHNjcm9sbENoYW5nZSwgQm9vbGVhbihzY3JvbGwpKTtcbiAgdXNlT25XaW5kb3dSZXNpemUocmVzaXplQ2hhbmdlKTtcblxuICAvLyByZXNwb25kIHRvIGNoYW5nZXMgdGhhdCBhcmUgcmVsZXZhbnQgZm9yIHRoZSBsaXN0ZW5lcnNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgfSwgW3Njcm9sbCwgc2Nyb2xsQ2hhbmdlLCByZXNpemVDaGFuZ2VdKTtcblxuICAvLyByZW1vdmUgYWxsIGxpc3RlbmVycyB3aGVuIHRoZSBjb21wb25lbnRzIHVubW91bnRzXG4gIHVzZUVmZmVjdCgoKSA9PiByZW1vdmVMaXN0ZW5lcnMsIFtdKTtcbiAgcmV0dXJuIFtyZWYsIGJvdW5kcywgZm9yY2VSZWZyZXNoXTtcbn1cblxuLy8gQWRkcyBuYXRpdmUgcmVzaXplIGxpc3RlbmVyIHRvIHdpbmRvd1xuZnVuY3Rpb24gdXNlT25XaW5kb3dSZXNpemUob25XaW5kb3dSZXNpemUpIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYiA9IG9uV2luZG93UmVzaXplO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBjYik7XG4gICAgcmV0dXJuICgpID0+IHZvaWQgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNiKTtcbiAgfSwgW29uV2luZG93UmVzaXplXSk7XG59XG5mdW5jdGlvbiB1c2VPbldpbmRvd1Njcm9sbChvblNjcm9sbCwgZW5hYmxlZCkge1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkKSB7XG4gICAgICBjb25zdCBjYiA9IG9uU2Nyb2xsO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGNiLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHZvaWQgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGNiLCB0cnVlKTtcbiAgICB9XG4gIH0sIFtvblNjcm9sbCwgZW5hYmxlZF0pO1xufVxuXG4vLyBSZXR1cm5zIGEgbGlzdCBvZiBzY3JvbGwgb2Zmc2V0c1xuZnVuY3Rpb24gZmluZFNjcm9sbENvbnRhaW5lcnMoZWxlbWVudCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHJldHVybiByZXN1bHQ7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdyxcbiAgICBvdmVyZmxvd1gsXG4gICAgb3ZlcmZsb3dZXG4gIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgaWYgKFtvdmVyZmxvdywgb3ZlcmZsb3dYLCBvdmVyZmxvd1ldLnNvbWUocHJvcCA9PiBwcm9wID09PSAnYXV0bycgfHwgcHJvcCA9PT0gJ3Njcm9sbCcpKSByZXN1bHQucHVzaChlbGVtZW50KTtcbiAgcmV0dXJuIFsuLi5yZXN1bHQsIC4uLmZpbmRTY3JvbGxDb250YWluZXJzKGVsZW1lbnQucGFyZW50RWxlbWVudCldO1xufVxuXG4vLyBDaGVja3MgaWYgZWxlbWVudCBib3VuZGFyaWVzIGFyZSBlcXVhbFxuY29uc3Qga2V5cyA9IFsneCcsICd5JywgJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICd3aWR0aCcsICdoZWlnaHQnXTtcbmNvbnN0IGFyZUJvdW5kc0VxdWFsID0gKGEsIGIpID0+IGtleXMuZXZlcnkoa2V5ID0+IGFba2V5XSA9PT0gYltrZXldKTtcblxuY29uc3QgQ2FudmFzSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENhbnZhcyh7XG4gIGNoaWxkcmVuLFxuICBmYWxsYmFjayxcbiAgcmVzaXplLFxuICBzdHlsZSxcbiAgZ2wsXG4gIGV2ZW50cyA9IGNyZWF0ZVBvaW50ZXJFdmVudHMsXG4gIGV2ZW50U291cmNlLFxuICBldmVudFByZWZpeCxcbiAgc2hhZG93cyxcbiAgbGluZWFyLFxuICBmbGF0LFxuICBsZWdhY3ksXG4gIG9ydGhvZ3JhcGhpYyxcbiAgZnJhbWVsb29wLFxuICBkcHIsXG4gIHBlcmZvcm1hbmNlLFxuICByYXljYXN0ZXIsXG4gIGNhbWVyYSxcbiAgc2NlbmUsXG4gIG9uUG9pbnRlck1pc3NlZCxcbiAgb25DcmVhdGVkLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSB7XG4gIC8vIENyZWF0ZSBhIGtub3duIGNhdGFsb2d1ZSBvZiBUaHJlZWpzLW5hdGl2ZSBlbGVtZW50c1xuICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgZW50aXJlIFRIUkVFIG5hbWVzcGFjZSBieSBkZWZhdWx0LCB1c2VycyBjYW4gZXh0ZW5kXG4gIC8vIHRoZWlyIG93biBlbGVtZW50cyBieSB1c2luZyB0aGUgY3JlYXRlUm9vdCBBUEkgaW5zdGVhZFxuICBSZWFjdC51c2VNZW1vKCgpID0+IGV4dGVuZChUSFJFRSksIFtdKTtcbiAgY29uc3QgQnJpZGdlID0gdXNlQ29udGV4dEJyaWRnZSgpO1xuICBjb25zdCBbY29udGFpbmVyUmVmLCBjb250YWluZXJSZWN0XSA9IHVzZU1lYXN1cmUoe1xuICAgIHNjcm9sbDogdHJ1ZSxcbiAgICBkZWJvdW5jZToge1xuICAgICAgc2Nyb2xsOiA1MCxcbiAgICAgIHJlc2l6ZTogMFxuICAgIH0sXG4gICAgLi4ucmVzaXplXG4gIH0pO1xuICBjb25zdCBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGRpdlJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+IGNhbnZhc1JlZi5jdXJyZW50KTtcbiAgY29uc3QgaGFuZGxlUG9pbnRlck1pc3NlZCA9IHVzZU11dGFibGVDYWxsYmFjayhvblBvaW50ZXJNaXNzZWQpO1xuICBjb25zdCBbYmxvY2ssIHNldEJsb2NrXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gU3VzcGVuZCB0aGlzIGNvbXBvbmVudCBpZiBibG9jayBpcyBhIHByb21pc2UgKDJuZCBydW4pXG4gIGlmIChibG9jaykgdGhyb3cgYmxvY2s7XG4gIC8vIFRocm93IGV4Y2VwdGlvbiBvdXR3YXJkcyBpZiBhbnl0aGluZyB3aXRoaW4gY2FudmFzIHRocm93c1xuICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICBjb25zdCByb290ID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoY29udGFpbmVyUmVjdC53aWR0aCA+IDAgJiYgY29udGFpbmVyUmVjdC5oZWlnaHQgPiAwICYmIGNhbnZhcykge1xuICAgICAgaWYgKCFyb290LmN1cnJlbnQpIHJvb3QuY3VycmVudCA9IGNyZWF0ZVJvb3QoY2FudmFzKTtcbiAgICAgIHJvb3QuY3VycmVudC5jb25maWd1cmUoe1xuICAgICAgICBnbCxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBsaW5lYXIsXG4gICAgICAgIGZsYXQsXG4gICAgICAgIGxlZ2FjeSxcbiAgICAgICAgb3J0aG9ncmFwaGljLFxuICAgICAgICBmcmFtZWxvb3AsXG4gICAgICAgIGRwcixcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcixcbiAgICAgICAgY2FtZXJhLFxuICAgICAgICBzY2VuZSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovanN4KEJyaWRnZSwge1xuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgc2V0OiBzZXRFcnJvcixcbiAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChSZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9qc3goQmxvY2ssIHtcbiAgICAgICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykgcmV0dXJuICgpID0+IHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgfSwgW10pO1xuXG4gIC8vIFdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBub3QgdGhpcyBkaXYsIHdlIG5lZWQgdG8gc2V0IHBvaW50ZXItZXZlbnRzIHRvIG5vbmVcbiAgLy8gT3IgZWxzZSB0aGUgY2FudmFzIHdpbGwgYmxvY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGV2ZW50IHNvdXJjZVxuICBjb25zdCBwb2ludGVyRXZlbnRzID0gZXZlbnRTb3VyY2UgPyAnbm9uZScgOiAnYXV0byc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICByZWY6IGRpdlJlZixcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICBwb2ludGVyRXZlbnRzLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnByb3BzLFxuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwJSdcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChcImNhbnZhc1wiLCB7XG4gICAgICAgIHJlZjogY2FudmFzUmVmLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGZhbGxiYWNrXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufSk7XG5cbi8qKlxyXG4gKiBBIERPTSBjYW52YXMgd2hpY2ggYWNjZXB0cyB0aHJlZWpzIGVsZW1lbnRzIGFzIGNoaWxkcmVuLlxyXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9jYW52YXNcclxuICovXG5jb25zdCBDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXNXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goRmliZXJQcm92aWRlciwge1xuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KENhbnZhc0ltcGwsIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmOiByZWZcbiAgICB9KVxuICB9KTtcbn0pO1xuXG5leHBvcnQgeyBDYW52YXMgfTtcbiJdLCJuYW1lcyI6WyJjIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsImUiLCJleHRlbmQiLCJ1IiwidXNlTXV0YWJsZUNhbGxiYWNrIiwiYSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJiIiwiY3JlYXRlUm9vdCIsImkiLCJpc1JlZiIsIkUiLCJFcnJvckJvdW5kYXJ5IiwiQiIsIkJsb2NrIiwiZCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJ0IiwiUmVhY3RUaHJlZUZpYmVyIiwieiIsIl9yb290cyIsIngiLCJhY3QiLCJwIiwiYWRkQWZ0ZXJFZmZlY3QiLCJvIiwiYWRkRWZmZWN0IiwicSIsImFkZFRhaWwiLCJuIiwiYWR2YW5jZSIsImsiLCJhcHBseVByb3BzIiwieSIsImJ1aWxkR3JhcGgiLCJnIiwiY29udGV4dCIsImYiLCJjcmVhdGVFdmVudHMiLCJoIiwiY3JlYXRlUG9ydGFsIiwibCIsImRpc3Bvc2UiLCJldmVudHMiLCJzIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwidiIsImZsdXNoU3luYyIsInciLCJnZXRSb290U3RhdGUiLCJtIiwiaW52YWxpZGF0ZSIsImoiLCJyZWNvbmNpbGVyIiwiciIsInJlbmRlciIsIkYiLCJ1c2VGcmFtZSIsIkciLCJ1c2VHcmFwaCIsIkEiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsIkgiLCJ1c2VMb2FkZXIiLCJDIiwidXNlU3RvcmUiLCJEIiwidXNlVGhyZWUiLCJSZWFjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsIlRIUkVFIiwiY3JlYXRlRGVib3VuY2UiLCJGaWJlclByb3ZpZGVyIiwidXNlQ29udGV4dEJyaWRnZSIsImpzeCIsInVzZU1lYXN1cmUiLCJkZWJvdW5jZSIsInNjcm9sbCIsInBvbHlmaWxsIiwib2Zmc2V0U2l6ZSIsIlJlc2l6ZU9ic2VydmVyIiwid2luZG93IiwiYm91bmRzIiwic2V0IiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiYm90dG9tIiwicmlnaHQiLCJzdGF0ZSIsImVsZW1lbnQiLCJzY3JvbGxDb250YWluZXJzIiwicmVzaXplT2JzZXJ2ZXIiLCJsYXN0Qm91bmRzIiwib3JpZW50YXRpb25IYW5kbGVyIiwic2Nyb2xsRGVib3VuY2UiLCJyZXNpemVEZWJvdW5jZSIsInJlc2l6ZSIsIm1vdW50ZWQiLCJjdXJyZW50IiwiZm9yY2VSZWZyZXNoIiwicmVzaXplQ2hhbmdlIiwic2Nyb2xsQ2hhbmdlIiwiY2FsbGJhY2siLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzaXplIiwiSFRNTEVsZW1lbnQiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIk9iamVjdCIsImZyZWV6ZSIsImFyZUJvdW5kc0VxdWFsIiwicmVtb3ZlTGlzdGVuZXJzIiwiZm9yRWFjaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkaXNjb25uZWN0Iiwic2NyZWVuIiwib3JpZW50YXRpb24iLCJhZGRMaXN0ZW5lcnMiLCJfc3RhdGUkY3VycmVudCRyZXNpemUiLCJvYnNlcnZlIiwic2Nyb2xsQ29udGFpbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhcHR1cmUiLCJwYXNzaXZlIiwicmVmIiwibm9kZSIsImZpbmRTY3JvbGxDb250YWluZXJzIiwidXNlT25XaW5kb3dTY3JvbGwiLCJCb29sZWFuIiwidXNlT25XaW5kb3dSZXNpemUiLCJvbldpbmRvd1Jlc2l6ZSIsImNiIiwib25TY3JvbGwiLCJlbmFibGVkIiwicmVzdWx0IiwiZG9jdW1lbnQiLCJib2R5Iiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRDb21wdXRlZFN0eWxlIiwic29tZSIsInByb3AiLCJwdXNoIiwicGFyZW50RWxlbWVudCIsImtleXMiLCJldmVyeSIsImtleSIsIkNhbnZhc0ltcGwiLCJmb3J3YXJkUmVmIiwiQ2FudmFzIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsInN0eWxlIiwiZ2wiLCJldmVudFNvdXJjZSIsImV2ZW50UHJlZml4Iiwic2hhZG93cyIsImxpbmVhciIsImZsYXQiLCJsZWdhY3kiLCJvcnRob2dyYXBoaWMiLCJmcmFtZWxvb3AiLCJkcHIiLCJwZXJmb3JtYW5jZSIsInJheWNhc3RlciIsImNhbWVyYSIsInNjZW5lIiwib25Qb2ludGVyTWlzc2VkIiwib25DcmVhdGVkIiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJCcmlkZ2UiLCJjb250YWluZXJSZWYiLCJjb250YWluZXJSZWN0IiwiY2FudmFzUmVmIiwiZGl2UmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImhhbmRsZVBvaW50ZXJNaXNzZWQiLCJibG9jayIsInNldEJsb2NrIiwiZXJyb3IiLCJzZXRFcnJvciIsInJvb3QiLCJjYW52YXMiLCJjb25maWd1cmUiLCJhcmdzIiwiY29ubmVjdCIsInNldEV2ZW50cyIsImNvbXB1dGUiLCJldmVudCIsInBvaW50ZXIiLCJzZXRGcm9tQ2FtZXJhIiwiU3VzcGVuc2UiLCJwb2ludGVyRXZlbnRzIiwicG9zaXRpb24iLCJkaXNwbGF5IiwiQ2FudmFzV3JhcHBlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        function push(heap, node) {\n            var index = heap.length;\n            heap.push(node);\n            siftUp(heap, node, index);\n        }\n        function peek(heap) {\n            return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n            if (heap.length === 0) {\n                return null;\n            }\n            var first = heap[0];\n            var last = heap.pop();\n            if (last !== first) {\n                heap[0] = last;\n                siftDown(heap, last, 0);\n            }\n            return first;\n        }\n        function siftUp(heap, node, i) {\n            var index = i;\n            while(index > 0){\n                var parentIndex = index - 1 >>> 1;\n                var parent = heap[parentIndex];\n                if (compare(parent, node) > 0) {\n                    // The parent is larger. Swap positions.\n                    heap[parentIndex] = node;\n                    heap[index] = parent;\n                    index = parentIndex;\n                } else {\n                    // The parent is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function siftDown(heap, node, i) {\n            var index = i;\n            var length = heap.length;\n            var halfLength = length >>> 1;\n            while(index < halfLength){\n                var leftIndex = (index + 1) * 2 - 1;\n                var left = heap[leftIndex];\n                var rightIndex = leftIndex + 1;\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n                if (compare(left, node) < 0) {\n                    if (rightIndex < length && compare(right, left) < 0) {\n                        heap[index] = right;\n                        heap[rightIndex] = node;\n                        index = rightIndex;\n                    } else {\n                        heap[index] = left;\n                        heap[leftIndex] = node;\n                        index = leftIndex;\n                    }\n                } else if (rightIndex < length && compare(right, node) < 0) {\n                    heap[index] = right;\n                    heap[rightIndex] = node;\n                    index = rightIndex;\n                } else {\n                    // Neither child is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function compare(a, b) {\n            // Compare sort index first, then task id.\n            var diff = a.sortIndex - b.sortIndex;\n            return diff !== 0 ? diff : a.id - b.id;\n        }\n        // TODO: Use symbols?\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {}\n        /* eslint-disable no-var */ var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n            var localPerformance = performance;\n            exports.unstable_now = function() {\n                return localPerformance.now();\n            };\n        } else {\n            var localDate = Date;\n            var initialTime = localDate.now();\n            exports.unstable_now = function() {\n                return localDate.now() - initialTime;\n            };\n        } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n        // Math.pow(2, 30) - 1\n        // 0b111111111111111111111111111111\n        var maxSigned31BitInt = 1073741823; // Times out immediately\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5000;\n        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n        var taskQueue = [];\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null; // IE and Node.js + jsdom\n        var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n            // Check for tasks that are no longer delayed and add them to the queue.\n            var timer = peek(timerQueue);\n            while(timer !== null){\n                if (timer.callback === null) {\n                    // Timer was cancelled.\n                    pop(timerQueue);\n                } else if (timer.startTime <= currentTime) {\n                    // Timer fired. Transfer to the task queue.\n                    pop(timerQueue);\n                    timer.sortIndex = timer.expirationTime;\n                    push(taskQueue, timer);\n                } else {\n                    // Remaining timers are pending.\n                    return;\n                }\n                timer = peek(timerQueue);\n            }\n        }\n        function handleTimeout(currentTime) {\n            isHostTimeoutScheduled = false;\n            advanceTimers(currentTime);\n            if (!isHostCallbackScheduled) {\n                if (peek(taskQueue) !== null) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                } else {\n                    var firstTimer = peek(timerQueue);\n                    if (firstTimer !== null) {\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                    }\n                }\n            }\n        }\n        function flushWork(hasTimeRemaining, initialTime) {\n            isHostCallbackScheduled = false;\n            if (isHostTimeoutScheduled) {\n                // We scheduled a timeout but it's no longer needed. Cancel it.\n                isHostTimeoutScheduled = false;\n                cancelHostTimeout();\n            }\n            isPerformingWork = true;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n                if (enableProfiling) {\n                    try {\n                        return workLoop(hasTimeRemaining, initialTime);\n                    } catch (error) {\n                        if (currentTask !== null) {\n                            var currentTime = exports.unstable_now();\n                            markTaskErrored(currentTask, currentTime);\n                            currentTask.isQueued = false;\n                        }\n                        throw error;\n                    }\n                } else {\n                    // No catch in prod code path.\n                    return workLoop(hasTimeRemaining, initialTime);\n                }\n            } finally{\n                currentTask = null;\n                currentPriorityLevel = previousPriorityLevel;\n                isPerformingWork = false;\n            }\n        }\n        function workLoop(hasTimeRemaining, initialTime) {\n            var currentTime = initialTime;\n            advanceTimers(currentTime);\n            currentTask = peek(taskQueue);\n            while(currentTask !== null && !enableSchedulerDebugging){\n                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n                    break;\n                }\n                var callback = currentTask.callback;\n                if (typeof callback === \"function\") {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    var continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = exports.unstable_now();\n                    if (typeof continuationCallback === \"function\") {\n                        currentTask.callback = continuationCallback;\n                    } else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                } else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n            } // Return whether there's additional work\n            if (currentTask !== null) {\n                return true;\n            } else {\n                var firstTimer = peek(timerQueue);\n                if (firstTimer !== null) {\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                }\n                return false;\n            }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                case LowPriority:\n                case IdlePriority:\n                    break;\n                default:\n                    priorityLevel = NormalPriority;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_next(eventHandler) {\n            var priorityLevel;\n            switch(currentPriorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                    // Shift down to normal priority\n                    priorityLevel = NormalPriority;\n                    break;\n                default:\n                    // Anything lower than normal priority should remain at the current level.\n                    priorityLevel = currentPriorityLevel;\n                    break;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_wrapCallback(callback) {\n            var parentPriorityLevel = currentPriorityLevel;\n            return function() {\n                // This is a fork of runWithPriority, inlined for performance.\n                var previousPriorityLevel = currentPriorityLevel;\n                currentPriorityLevel = parentPriorityLevel;\n                try {\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentPriorityLevel = previousPriorityLevel;\n                }\n            };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n            var currentTime = exports.unstable_now();\n            var startTime;\n            if (typeof options === \"object\" && options !== null) {\n                var delay = options.delay;\n                if (typeof delay === \"number\" && delay > 0) {\n                    startTime = currentTime + delay;\n                } else {\n                    startTime = currentTime;\n                }\n            } else {\n                startTime = currentTime;\n            }\n            var timeout;\n            switch(priorityLevel){\n                case ImmediatePriority:\n                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n                    break;\n                case UserBlockingPriority:\n                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n                    break;\n                case IdlePriority:\n                    timeout = IDLE_PRIORITY_TIMEOUT;\n                    break;\n                case LowPriority:\n                    timeout = LOW_PRIORITY_TIMEOUT;\n                    break;\n                case NormalPriority:\n                default:\n                    timeout = NORMAL_PRIORITY_TIMEOUT;\n                    break;\n            }\n            var expirationTime = startTime + timeout;\n            var newTask = {\n                id: taskIdCounter++,\n                callback: callback,\n                priorityLevel: priorityLevel,\n                startTime: startTime,\n                expirationTime: expirationTime,\n                sortIndex: -1\n            };\n            if (startTime > currentTime) {\n                // This is a delayed task.\n                newTask.sortIndex = startTime;\n                push(timerQueue, newTask);\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n                    // All tasks are delayed, and this is the task with the earliest delay.\n                    if (isHostTimeoutScheduled) {\n                        // Cancel an existing timeout.\n                        cancelHostTimeout();\n                    } else {\n                        isHostTimeoutScheduled = true;\n                    } // Schedule a timeout.\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\n                }\n            } else {\n                newTask.sortIndex = expirationTime;\n                push(taskQueue, newTask);\n                // wait until the next time we yield.\n                if (!isHostCallbackScheduled && !isPerformingWork) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                }\n            }\n            return newTask;\n        }\n        function unstable_pauseExecution() {}\n        function unstable_continueExecution() {\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n                isHostCallbackScheduled = true;\n                requestHostCallback(flushWork);\n            }\n        }\n        function unstable_getFirstCallbackNode() {\n            return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n            // remove from the queue because you can't remove arbitrary nodes from an\n            // array based heap, only the first one.)\n            task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n            return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var scheduledHostCallback = null;\n        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n        // thread, like user events. By default, it yields multiple times per frame.\n        // It does not attempt to align with frame boundaries, since most tasks don't\n        // need to be frame aligned; for those that do, use requestAnimationFrame.\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n            var timeElapsed = exports.unstable_now() - startTime;\n            if (timeElapsed < frameInterval) {\n                // The main thread has only been blocked for a really short amount of time;\n                // smaller than a single frame. Don't yield yet.\n                return false;\n            } // The main thread has been blocked for a non-negligible amount of time. We\n            return true;\n        }\n        function requestPaint() {}\n        function forceFrameRate(fps) {\n            if (fps < 0 || fps > 125) {\n                // Using console['error'] to evade Babel and ESLint\n                console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing frame rates higher than 125 fps is not supported\");\n                return;\n            }\n            if (fps > 0) {\n                frameInterval = Math.floor(1000 / fps);\n            } else {\n                // reset the framerate\n                frameInterval = frameYieldMs;\n            }\n        }\n        var performWorkUntilDeadline = function() {\n            if (scheduledHostCallback !== null) {\n                var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n                // has been blocked.\n                startTime = currentTime;\n                var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n                // error can be observed.\n                //\n                // Intentionally not using a try-catch, since that makes some debugging\n                // techniques harder. Instead, if `scheduledHostCallback` errors, then\n                // `hasMoreWork` will remain true, and we'll continue the work loop.\n                var hasMoreWork = true;\n                try {\n                    hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n                } finally{\n                    if (hasMoreWork) {\n                        // If there's more work, schedule the next message event at the end\n                        // of the preceding one.\n                        schedulePerformWorkUntilDeadline();\n                    } else {\n                        isMessageLoopRunning = false;\n                        scheduledHostCallback = null;\n                    }\n                }\n            } else {\n                isMessageLoopRunning = false;\n            } // Yielding to the browser will give it a chance to paint, so we can\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n            // Node.js and old IE.\n            // There's a few reasons for why we prefer setImmediate.\n            //\n            // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n            // (Even though this is a DOM fork of the Scheduler, you could get here\n            // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n            // https://github.com/facebook/react/issues/20756\n            //\n            // But also, it runs earlier which is the semantic we want.\n            // If other browsers ever implement it, it's better to use it.\n            // Although both of these would be inferior to native scheduling.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetImmediate(performWorkUntilDeadline);\n            };\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // DOM and Worker environments.\n            // We prefer MessageChannel because of the 4ms setTimeout clamping.\n            var channel = new MessageChannel();\n            var port = channel.port2;\n            channel.port1.onmessage = performWorkUntilDeadline;\n            schedulePerformWorkUntilDeadline = function() {\n                port.postMessage(null);\n            };\n        } else {\n            // We should only fallback here in non-browser environments.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetTimeout(performWorkUntilDeadline, 0);\n            };\n        }\n        function requestHostCallback(callback) {\n            scheduledHostCallback = callback;\n            if (!isMessageLoopRunning) {\n                isMessageLoopRunning = true;\n                schedulePerformWorkUntilDeadline();\n            }\n        }\n        function requestHostTimeout(callback, ms) {\n            taskTimeoutID = localSetTimeout(function() {\n                callback(exports.unstable_now());\n            }, ms);\n        }\n        function cancelHostTimeout() {\n            localClearTimeout(taskTimeoutID);\n            taskTimeoutID = -1;\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUVPO1FBRVYseUNBQXlDLEdBQ3pDLElBQ0UsT0FBT0MsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQkMsMkJBQTJCLEtBQy9ELFlBQ0Y7WUFDQUQsK0JBQStCQywyQkFBMkIsQ0FBQyxJQUFJQztRQUNqRTtRQUNVLElBQUlDLDJCQUEyQjtRQUN6QyxJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSUMsZUFBZTtRQUVuQixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLElBQUk7WUFDdEIsSUFBSUMsUUFBUUYsS0FBS0csTUFBTTtZQUN2QkgsS0FBS0QsSUFBSSxDQUFDRTtZQUNWRyxPQUFPSixNQUFNQyxNQUFNQztRQUNyQjtRQUNBLFNBQVNHLEtBQUtMLElBQUk7WUFDaEIsT0FBT0EsS0FBS0csTUFBTSxLQUFLLElBQUksT0FBT0gsSUFBSSxDQUFDLEVBQUU7UUFDM0M7UUFDQSxTQUFTTSxJQUFJTixJQUFJO1lBQ2YsSUFBSUEsS0FBS0csTUFBTSxLQUFLLEdBQUc7Z0JBQ3JCLE9BQU87WUFDVDtZQUVBLElBQUlJLFFBQVFQLElBQUksQ0FBQyxFQUFFO1lBQ25CLElBQUlRLE9BQU9SLEtBQUtNLEdBQUc7WUFFbkIsSUFBSUUsU0FBU0QsT0FBTztnQkFDbEJQLElBQUksQ0FBQyxFQUFFLEdBQUdRO2dCQUNWQyxTQUFTVCxNQUFNUSxNQUFNO1lBQ3ZCO1lBRUEsT0FBT0Q7UUFDVDtRQUVBLFNBQVNILE9BQU9KLElBQUksRUFBRUMsSUFBSSxFQUFFUyxDQUFDO1lBQzNCLElBQUlSLFFBQVFRO1lBRVosTUFBT1IsUUFBUSxFQUFHO2dCQUNoQixJQUFJUyxjQUFjVCxRQUFRLE1BQU07Z0JBQ2hDLElBQUlV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LHdDQUF3QyxHQUFHbUU7UUFDM0NuRSxxQ0FBcUMsR0FBR2lFO1FBQ3hDakUscUJBQXFCLEdBQUdxRDtRQUN4QnJELCtCQUErQixHQUFHK0Q7UUFDbEMvRCw2QkFBNkIsR0FBR3lGO1FBQ2hDekYsZ0NBQWdDLEdBQUdtRDtRQUNuQ25ELGlDQUFpQyxHQUFHMEQ7UUFDcEMxRCw0QkFBNEIsR0FBRytDO1FBQy9CL0MsNkJBQTZCLEdBQUdzRDtRQUN0Qix5Q0FBeUMsR0FDbkQsSUFDRSxPQUFPakcsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQjZJLDBCQUEwQixLQUM5RCxZQUNGO1lBQ0E3SSwrQkFBK0I2SSwwQkFBMEIsQ0FBQyxJQUFJM0k7UUFDaEU7SUFFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzP2IxMTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PT1cbiAgICAnZnVuY3Rpb24nXG4pIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgICAgdmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xudmFyIGVuYWJsZVByb2ZpbGluZyA9IGZhbHNlO1xudmFyIGZyYW1lWWllbGRNcyA9IDU7XG5cbmZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcbiAgaGVhcC5wdXNoKG5vZGUpO1xuICBzaWZ0VXAoaGVhcCwgbm9kZSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gIHJldHVybiBoZWFwLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBoZWFwWzBdO1xufVxuZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgaWYgKGhlYXAubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cbiAgaWYgKGxhc3QgIT09IGZpcnN0KSB7XG4gICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gIH1cblxuICByZXR1cm4gZmlyc3Q7XG59XG5cbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG5cbiAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgIHZhciBwYXJlbnRJbmRleCA9IGluZGV4IC0gMSA+Pj4gMTtcbiAgICB2YXIgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG5cbiAgICBpZiAoY29tcGFyZShwYXJlbnQsIG5vZGUpID4gMCkge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBsYXJnZXIuIFN3YXAgcG9zaXRpb25zLlxuICAgICAgaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlO1xuICAgICAgaGVhcFtpbmRleF0gPSBwYXJlbnQ7XG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnREb3duKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcbiAgdmFyIGxlbmd0aCA9IGhlYXAubGVuZ3RoO1xuICB2YXIgaGFsZkxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcblxuICB3aGlsZSAoaW5kZXggPCBoYWxmTGVuZ3RoKSB7XG4gICAgdmFyIGxlZnRJbmRleCA9IChpbmRleCArIDEpICogMiAtIDE7XG4gICAgdmFyIGxlZnQgPSBoZWFwW2xlZnRJbmRleF07XG4gICAgdmFyIHJpZ2h0SW5kZXggPSBsZWZ0SW5kZXggKyAxO1xuICAgIHZhciByaWdodCA9IGhlYXBbcmlnaHRJbmRleF07IC8vIElmIHRoZSBsZWZ0IG9yIHJpZ2h0IG5vZGUgaXMgc21hbGxlciwgc3dhcCB3aXRoIHRoZSBzbWFsbGVyIG9mIHRob3NlLlxuXG4gICAgaWYgKGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbn1cblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbmZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cblxudmFyIGhhc1BlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG5pZiAoaGFzUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICB2YXIgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xuICB9O1xufSAvLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG5cblxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cbnZhciBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCA9IC0xOyAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuXG52YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUID0gMjUwO1xudmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcbnZhciBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwOyAvLyBOZXZlciB0aW1lcyBvdXRcblxudmFyIElETEVfUFJJT1JJVFlfVElNRU9VVCA9IG1heFNpZ25lZDMxQml0SW50OyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxudmFyIHRhc2tRdWV1ZSA9IFtdO1xudmFyIHRpbWVyUXVldWUgPSBbXTsgLy8gSW5jcmVtZW50aW5nIGlkIGNvdW50ZXIuIFVzZWQgdG8gbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLlxuXG52YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbnZhciBjdXJyZW50VGFzayA9IG51bGw7XG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTsgLy8gVGhpcyBpcyBzZXQgd2hpbGUgcGVyZm9ybWluZyB3b3JrLCB0byBwcmV2ZW50IHJlLWVudHJhbmNlLlxuXG52YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlOyAvLyBDYXB0dXJlIGxvY2FsIHJlZmVyZW5jZXMgdG8gbmF0aXZlIEFQSXMsIGluIGNhc2UgYSBwb2x5ZmlsbCBvdmVycmlkZXMgdGhlbS5cblxudmFyIGxvY2FsU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IG51bGw7XG52YXIgbG9jYWxDbGVhclRpbWVvdXQgPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogbnVsbDtcbnZhciBsb2NhbFNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnID8gc2V0SW1tZWRpYXRlIDogbnVsbDsgLy8gSUUgYW5kIE5vZGUuanMgKyBqc2RvbVxuXG52YXIgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3Iuc2NoZWR1bGluZyAhPT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nICE9PSB1bmRlZmluZWQgPyBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZy5iaW5kKG5hdmlnYXRvci5zY2hlZHVsaW5nKSA6IG51bGw7XG5cbmZ1bmN0aW9uIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpIHtcbiAgLy8gQ2hlY2sgZm9yIHRhc2tzIHRoYXQgYXJlIG5vIGxvbmdlciBkZWxheWVkIGFuZCBhZGQgdGhlbSB0byB0aGUgcXVldWUuXG4gIHZhciB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgd2hpbGUgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgaWYgKHRpbWVyLmNhbGxiYWNrID09PSBudWxsKSB7XG4gICAgICAvLyBUaW1lciB3YXMgY2FuY2VsbGVkLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgIH0gZWxzZSBpZiAodGltZXIuc3RhcnRUaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaW1lciBmaXJlZC4gVHJhbnNmZXIgdG8gdGhlIHRhc2sgcXVldWUuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgICB0aW1lci5zb3J0SW5kZXggPSB0aW1lci5leHBpcmF0aW9uVGltZTtcbiAgICAgIHB1c2godGFza1F1ZXVlLCB0aW1lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbWFpbmluZyB0aW1lcnMgYXJlIHBlbmRpbmcuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoY3VycmVudFRpbWUpIHtcbiAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKSB7XG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSAhPT0gbnVsbCkge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hXb3JrKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG5cblxuICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgLy8gV2Ugc2NoZWR1bGVkIGEgdGltZW91dCBidXQgaXQncyBubyBsb25nZXIgbmVlZGVkLiBDYW5jZWwgaXQuXG4gICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gIH1cblxuICBpc1BlcmZvcm1pbmdXb3JrID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVByb2ZpbGluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgICAgbWFya1Rhc2tFcnJvcmVkKGN1cnJlbnRUYXNrLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgY3VycmVudFRhc2suaXNRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjYXRjaCBpbiBwcm9kIGNvZGUgcGF0aC5cbiAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRUYXNrID0gbnVsbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gaW5pdGlhbFRpbWU7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcblxuICB3aGlsZSAoY3VycmVudFRhc2sgIT09IG51bGwgJiYgIShlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgKSkge1xuICAgIGlmIChjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA+IGN1cnJlbnRUaW1lICYmICghaGFzVGltZVJlbWFpbmluZyB8fCBzaG91bGRZaWVsZFRvSG9zdCgpKSkge1xuICAgICAgLy8gVGhpcyBjdXJyZW50VGFzayBoYXNuJ3QgZXhwaXJlZCwgYW5kIHdlJ3ZlIHJlYWNoZWQgdGhlIGRlYWRsaW5lLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICB2YXIgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuXG4gICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSkge1xuICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgfSAvLyBSZXR1cm4gd2hldGhlciB0aGVyZSdzIGFkZGl0aW9uYWwgd29ya1xuXG5cbiAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfbmV4dChldmVudEhhbmRsZXIpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWw7XG5cbiAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgLy8gU2hpZnQgZG93biB0byBub3JtYWwgcHJpb3JpdHlcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gIHZhciBzdGFydFRpbWU7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5kZWxheTtcblxuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG5cbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElETEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBMT1dfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBkZWZhdWx0OlxuICAgICAgdGltZW91dCA9IE5PUk1BTF9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyB0aW1lb3V0O1xuICB2YXIgbmV3VGFzayA9IHtcbiAgICBpZDogdGFza0lkQ291bnRlcisrLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICBzb3J0SW5kZXg6IC0xXG4gIH07XG5cbiAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuXG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxuXG5cbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xuICAgIC8vIHdhaXQgdW50aWwgdGhlIG5leHQgdGltZSB3ZSB5aWVsZC5cblxuXG4gICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdUYXNrO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbigpIHtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY29udGludWVFeGVjdXRpb24oKSB7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XG4gIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKHRhc2spIHtcbiAgLy8gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlIGJlY2F1c2UgeW91IGNhbid0IHJlbW92ZSBhcmJpdHJhcnkgbm9kZXMgZnJvbSBhblxuICAvLyBhcnJheSBiYXNlZCBoZWFwLCBvbmx5IHRoZSBmaXJzdCBvbmUuKVxuXG5cbiAgdGFzay5jYWxsYmFjayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xuICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG59XG5cbnZhciBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xudmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG52YXIgdGFza1RpbWVvdXRJRCA9IC0xOyAvLyBTY2hlZHVsZXIgcGVyaW9kaWNhbGx5IHlpZWxkcyBpbiBjYXNlIHRoZXJlIGlzIG90aGVyIHdvcmsgb24gdGhlIG1haW5cbi8vIHRocmVhZCwgbGlrZSB1c2VyIGV2ZW50cy4gQnkgZGVmYXVsdCwgaXQgeWllbGRzIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZS5cbi8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG4vLyBuZWVkIHRvIGJlIGZyYW1lIGFsaWduZWQ7IGZvciB0aG9zZSB0aGF0IGRvLCB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuXG52YXIgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbnZhciBzdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gc2hvdWxkWWllbGRUb0hvc3QoKSB7XG4gIHZhciB0aW1lRWxhcHNlZCA9IGV4cG9ydHMudW5zdGFibGVfbm93KCkgLSBzdGFydFRpbWU7XG5cbiAgaWYgKHRpbWVFbGFwc2VkIDwgZnJhbWVJbnRlcnZhbCkge1xuICAgIC8vIFRoZSBtYWluIHRocmVhZCBoYXMgb25seSBiZWVuIGJsb2NrZWQgZm9yIGEgcmVhbGx5IHNob3J0IGFtb3VudCBvZiB0aW1lO1xuICAgIC8vIHNtYWxsZXIgdGhhbiBhIHNpbmdsZSBmcmFtZS4gRG9uJ3QgeWllbGQgeWV0LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgbWFpbiB0aHJlYWQgaGFzIGJlZW4gYmxvY2tlZCBmb3IgYSBub24tbmVnbGlnaWJsZSBhbW91bnQgb2YgdGltZS4gV2VcblxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0UGFpbnQoKSB7XG5cbn1cblxuZnVuY3Rpb24gZm9yY2VGcmFtZVJhdGUoZnBzKSB7XG4gIGlmIChmcHMgPCAwIHx8IGZwcyA+IDEyNSkge1xuICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGZwcyA+IDApIHtcbiAgICBmcmFtZUludGVydmFsID0gTWF0aC5mbG9vcigxMDAwIC8gZnBzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG4gICAgZnJhbWVJbnRlcnZhbCA9IGZyYW1lWWllbGRNcztcbiAgfVxufVxuXG52YXIgcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgc3RhcnQgdGltZSBzbyB3ZSBjYW4gbWVhc3VyZSBob3cgbG9uZyB0aGUgbWFpbiB0aHJlYWRcbiAgICAvLyBoYXMgYmVlbiBibG9ja2VkLlxuXG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlOyAvLyBJZiBhIHNjaGVkdWxlciB0YXNrIHRocm93cywgZXhpdCB0aGUgY3VycmVudCBicm93c2VyIHRhc2sgc28gdGhlXG4gICAgLy8gZXJyb3IgY2FuIGJlIG9ic2VydmVkLlxuICAgIC8vXG4gICAgLy8gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYSB0cnktY2F0Y2gsIHNpbmNlIHRoYXQgbWFrZXMgc29tZSBkZWJ1Z2dpbmdcbiAgICAvLyB0ZWNobmlxdWVzIGhhcmRlci4gSW5zdGVhZCwgaWYgYHNjaGVkdWxlZEhvc3RDYWxsYmFja2AgZXJyb3JzLCB0aGVuXG4gICAgLy8gYGhhc01vcmVXb3JrYCB3aWxsIHJlbWFpbiB0cnVlLCBhbmQgd2UnbGwgY29udGludWUgdGhlIHdvcmsgbG9vcC5cblxuICAgIHZhciBoYXNNb3JlV29yayA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoaGFzTW9yZVdvcmspIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgcHJlY2VkaW5nIG9uZS5cbiAgICAgICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gIH0gLy8gWWllbGRpbmcgdG8gdGhlIGJyb3dzZXIgd2lsbCBnaXZlIGl0IGEgY2hhbmNlIHRvIHBhaW50LCBzbyB3ZSBjYW5cbn07XG5cbnZhciBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuaWYgKHR5cGVvZiBsb2NhbFNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBOb2RlLmpzIGFuZCBvbGQgSUUuXG4gIC8vIFRoZXJlJ3MgYSBmZXcgcmVhc29ucyBmb3Igd2h5IHdlIHByZWZlciBzZXRJbW1lZGlhdGUuXG4gIC8vXG4gIC8vIFVubGlrZSBNZXNzYWdlQ2hhbm5lbCwgaXQgZG9lc24ndCBwcmV2ZW50IGEgTm9kZS5qcyBwcm9jZXNzIGZyb20gZXhpdGluZy5cbiAgLy8gKEV2ZW4gdGhvdWdoIHRoaXMgaXMgYSBET00gZm9yayBvZiB0aGUgU2NoZWR1bGVyLCB5b3UgY291bGQgZ2V0IGhlcmVcbiAgLy8gd2l0aCBhIG1peCBvZiBOb2RlLmpzIDE1Kywgd2hpY2ggaGFzIGEgTWVzc2FnZUNoYW5uZWwsIGFuZCBqc2RvbS4pXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjA3NTZcbiAgLy9cbiAgLy8gQnV0IGFsc28sIGl0IHJ1bnMgZWFybGllciB3aGljaCBpcyB0aGUgc2VtYW50aWMgd2Ugd2FudC5cbiAgLy8gSWYgb3RoZXIgYnJvd3NlcnMgZXZlciBpbXBsZW1lbnQgaXQsIGl0J3MgYmV0dGVyIHRvIHVzZSBpdC5cbiAgLy8gQWx0aG91Z2ggYm90aCBvZiB0aGVzZSB3b3VsZCBiZSBpbmZlcmlvciB0byBuYXRpdmUgc2NoZWR1bGluZy5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRJbW1lZGlhdGUocGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBET00gYW5kIFdvcmtlciBlbnZpcm9ubWVudHMuXG4gIC8vIFdlIHByZWZlciBNZXNzYWdlQ2hhbm5lbCBiZWNhdXNlIG9mIHRoZSA0bXMgc2V0VGltZW91dCBjbGFtcGluZy5cbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gV2Ugc2hvdWxkIG9ubHkgZmFsbGJhY2sgaGVyZSBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU2V0VGltZW91dChwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUsIDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0SG9zdENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gIGlmICghaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG4gICAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXF1ZXN0SG9zdFRpbWVvdXQoY2FsbGJhY2ssIG1zKSB7XG4gIHRhc2tUaW1lb3V0SUQgPSBsb2NhbFNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICB9LCBtcyk7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbEhvc3RUaW1lb3V0KCkge1xuICBsb2NhbENsZWFyVGltZW91dCh0YXNrVGltZW91dElEKTtcbiAgdGFza1RpbWVvdXRJRCA9IC0xO1xufVxuXG52YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xudmFyIHVuc3RhYmxlX1Byb2ZpbGluZyA9ICBudWxsO1xuXG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSA9IGZvcmNlRnJhbWVSYXRlO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IHNob3VsZFlpZWxkVG9Ib3N0O1xuZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSB1bnN0YWJsZV93cmFwQ2FsbGJhY2s7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0IiwiRXJyb3IiLCJlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmciLCJlbmFibGVQcm9maWxpbmciLCJmcmFtZVlpZWxkTXMiLCJwdXNoIiwiaGVhcCIsIm5vZGUiLCJpbmRleCIsImxlbmd0aCIsInNpZnRVcCIsInBlZWsiLCJwb3AiLCJmaXJzdCIsImxhc3QiLCJzaWZ0RG93biIsImkiLCJwYXJlbnRJbmRleCIsInBhcmVudCIsImNvbXBhcmUiLCJoYWxmTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdCIsInJpZ2h0SW5kZXgiLCJyaWdodCIsImEiLCJiIiwiZGlmZiIsInNvcnRJbmRleCIsImlkIiwiSW1tZWRpYXRlUHJpb3JpdHkiLCJVc2VyQmxvY2tpbmdQcmlvcml0eSIsIk5vcm1hbFByaW9yaXR5IiwiTG93UHJpb3JpdHkiLCJJZGxlUHJpb3JpdHkiLCJtYXJrVGFza0Vycm9yZWQiLCJ0YXNrIiwibXMiLCJoYXNQZXJmb3JtYW5jZU5vdyIsInBlcmZvcm1hbmNlIiwibm93IiwibG9jYWxQZXJmb3JtYW5jZSIsImV4cG9ydHMiLCJ1bnN0YWJsZV9ub3ciLCJsb2NhbERhdGUiLCJEYXRlIiwiaW5pdGlhbFRpbWUiLCJtYXhTaWduZWQzMUJpdEludCIsIklNTUVESUFURV9QUklPUklUWV9USU1FT1VUIiwiVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUIiwiTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQiLCJMT1dfUFJJT1JJVFlfVElNRU9VVCIsIklETEVfUFJJT1JJVFlfVElNRU9VVCIsInRhc2tRdWV1ZSIsInRpbWVyUXVldWUiLCJ0YXNrSWRDb3VudGVyIiwiY3VycmVudFRhc2siLCJjdXJyZW50UHJpb3JpdHlMZXZlbCIsImlzUGVyZm9ybWluZ1dvcmsiLCJpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCIsImlzSG9zdFRpbWVvdXRTY2hlZHVsZWQiLCJsb2NhbFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibG9jYWxDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJsb2NhbFNldEltbWVkaWF0ZSIsInNldEltbWVkaWF0ZSIsImlzSW5wdXRQZW5kaW5nIiwibmF2aWdhdG9yIiwic2NoZWR1bGluZyIsInVuZGVmaW5lZCIsImJpbmQiLCJhZHZhbmNlVGltZXJzIiwiY3VycmVudFRpbWUiLCJ0aW1lciIsImNhbGxiYWNrIiwic3RhcnRUaW1lIiwiZXhwaXJhdGlvblRpbWUiLCJoYW5kbGVUaW1lb3V0IiwicmVxdWVzdEhvc3RDYWxsYmFjayIsImZsdXNoV29yayIsImZpcnN0VGltZXIiLCJyZXF1ZXN0SG9zdFRpbWVvdXQiLCJoYXNUaW1lUmVtYWluaW5nIiwiY2FuY2VsSG9zdFRpbWVvdXQiLCJwcmV2aW91c1ByaW9yaXR5TGV2ZWwiLCJ3b3JrTG9vcCIsImVycm9yIiwiaXNRdWV1ZWQiLCJzaG91bGRZaWVsZFRvSG9zdCIsInByaW9yaXR5TGV2ZWwiLCJkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0IiwiY29udGludWF0aW9uQ2FsbGJhY2siLCJ1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkiLCJldmVudEhhbmRsZXIiLCJ1bnN0YWJsZV9uZXh0IiwidW5zdGFibGVfd3JhcENhbGxiYWNrIiwicGFyZW50UHJpb3JpdHlMZXZlbCIsImFwcGx5IiwiYXJndW1lbnRzIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsIm9wdGlvbnMiLCJkZWxheSIsInRpbWVvdXQiLCJuZXdUYXNrIiwidW5zdGFibGVfcGF1c2VFeGVjdXRpb24iLCJ1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJ1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCIsImlzTWVzc2FnZUxvb3BSdW5uaW5nIiwic2NoZWR1bGVkSG9zdENhbGxiYWNrIiwidGFza1RpbWVvdXRJRCIsImZyYW1lSW50ZXJ2YWwiLCJ0aW1lRWxhcHNlZCIsInJlcXVlc3RQYWludCIsImZvcmNlRnJhbWVSYXRlIiwiZnBzIiwiY29uc29sZSIsIk1hdGgiLCJmbG9vciIsInBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSIsImhhc01vcmVXb3JrIiwic2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0IiwicG9ydDIiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwidW5zdGFibGVfcmVxdWVzdFBhaW50IiwidW5zdGFibGVfUHJvZmlsaW5nIiwidW5zdGFibGVfSWRsZVByaW9yaXR5IiwidW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkiLCJ1bnN0YWJsZV9Mb3dQcmlvcml0eSIsInVuc3RhYmxlX05vcm1hbFByaW9yaXR5IiwidW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSIsInVuc3RhYmxlX3Nob3VsZFlpZWxkIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMseUtBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJhYmxvLXN0dWRpby8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZmliZXIvbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcz82YmE5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\n");

/***/ })

};
;